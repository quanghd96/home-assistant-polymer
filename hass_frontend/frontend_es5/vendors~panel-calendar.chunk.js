(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
  ["vendors~panel-calendar"],
  {
    /***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
      /*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return _assertThisInitialized;
          }
        );
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return self;
        }

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
      /*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return _createClass;
          }
        );
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
      /*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return _extends;
          }
        );
        function _extends() {
          _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];

                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }

              return target;
            };

          return _extends.apply(this, arguments);
        }

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
      /*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return _inheritsLoose;
          }
        );
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
      /*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return _objectWithoutPropertiesLoose;
          }
        );
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;

          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }

          return target;
        }

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/extends.js":
      /*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _extends() {
          module.exports = _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];

                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }

              return target;
            };

          return _extends.apply(this, arguments);
        }

        module.exports = _extends;

        /***/
      },

    /***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
      /*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        module.exports = _interopRequireDefault;

        /***/
      },

    /***/ "./node_modules/@polymer/iron-checked-element-behavior/iron-checked-element-behavior.js":
      /*!**********************************************************************************************!*\
  !*** ./node_modules/@polymer/iron-checked-element-behavior/iron-checked-element-behavior.js ***!
  \**********************************************************************************************/
      /*! exports provided: IronCheckedElementBehaviorImpl, IronCheckedElementBehavior */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "IronCheckedElementBehaviorImpl",
          function() {
            return IronCheckedElementBehaviorImpl;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "IronCheckedElementBehavior",
          function() {
            return IronCheckedElementBehavior;
          }
        );
        /* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @polymer/polymer/polymer-legacy.js */ "./node_modules/@polymer/polymer/polymer-legacy.js"
        );
        /* harmony import */ var _polymer_iron_form_element_behavior_iron_form_element_behavior_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @polymer/iron-form-element-behavior/iron-form-element-behavior.js */ "./node_modules/@polymer/iron-form-element-behavior/iron-form-element-behavior.js"
        );
        /* harmony import */ var _polymer_iron_validatable_behavior_iron_validatable_behavior_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! @polymer/iron-validatable-behavior/iron-validatable-behavior.js */ "./node_modules/@polymer/iron-validatable-behavior/iron-validatable-behavior.js"
        );
        /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

        /**
         * Use `IronCheckedElementBehavior` to implement a custom element that has a
         * `checked` property, which can be used for validation if the element is also
         * `required`. Element instances implementing this behavior will also be
         * registered for use in an `iron-form` element.
         *
         * @demo demo/index.html
         * @polymerBehavior IronCheckedElementBehavior
         */

        var IronCheckedElementBehaviorImpl = {
          properties: {
            /**
             * Fired when the checked state changes.
             *
             * @event iron-change
             */

            /**
             * Gets or sets the state, `true` is checked and `false` is unchecked.
             */
            checked: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true,
              observer: "_checkedChanged",
            },

            /**
             * If true, the button toggles the active state with each tap or press
             * of the spacebar.
             */
            toggles: {
              type: Boolean,
              value: true,
              reflectToAttribute: true,
            },

            /* Overriden from IronFormElementBehavior */
            value: {
              type: String,
              value: "on",
              observer: "_valueChanged",
            },
          },
          observers: ["_requiredChanged(required)"],
          created: function created() {
            // Used by `iron-form` to handle the case that an element with this behavior
            // doesn't have a role of 'checkbox' or 'radio', but should still only be
            // included when the form is serialized if `this.checked === true`.
            this._hasIronCheckedElementBehavior = true;
          },

          /**
           * Returns false if the element is required and not checked, and true
           * otherwise.
           * @param {*=} _value Ignored.
           * @return {boolean} true if `required` is false or if `checked` is true.
           */
          _getValidity: function _getValidity(_value) {
            return this.disabled || !this.required || this.checked;
          },

          /**
           * Update the aria-required label when `required` is changed.
           */
          _requiredChanged: function _requiredChanged() {
            if (this.required) {
              this.setAttribute("aria-required", "true");
            } else {
              this.removeAttribute("aria-required");
            }
          },

          /**
           * Fire `iron-changed` when the checked state changes.
           */
          _checkedChanged: function _checkedChanged() {
            this.active = this.checked;
            this.fire("iron-change");
          },

          /**
           * Reset value to 'on' if it is set to `undefined`.
           */
          _valueChanged: function _valueChanged() {
            if (this.value === undefined || this.value === null) {
              this.value = "on";
            }
          },
        };
        /** @polymerBehavior */

        var IronCheckedElementBehavior = [
          _polymer_iron_form_element_behavior_iron_form_element_behavior_js__WEBPACK_IMPORTED_MODULE_1__[
            "IronFormElementBehavior"
          ],
          _polymer_iron_validatable_behavior_iron_validatable_behavior_js__WEBPACK_IMPORTED_MODULE_2__[
            "IronValidatableBehavior"
          ],
          IronCheckedElementBehaviorImpl,
        ];

        /***/
      },

    /***/ "./node_modules/@polymer/iron-form-element-behavior/iron-form-element-behavior.js":
      /*!****************************************************************************************!*\
  !*** ./node_modules/@polymer/iron-form-element-behavior/iron-form-element-behavior.js ***!
  \****************************************************************************************/
      /*! exports provided: IronFormElementBehavior */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "IronFormElementBehavior",
          function() {
            return IronFormElementBehavior;
          }
        );
        /* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @polymer/polymer/polymer-legacy.js */ "./node_modules/@polymer/polymer/polymer-legacy.js"
        );
        /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

        /**
  IronFormElementBehavior adds a `name`, `value` and `required` properties to
  a custom element. It mostly exists for backcompatibility with Polymer 1.x, and
  is probably not something you want to use.

  @demo demo/index.html
  @polymerBehavior
 */

        var IronFormElementBehavior = {
          properties: {
            /**
             * The name of this element.
             */
            name: {
              type: String,
            },

            /**
             * The value for this element.
             * @type {*}
             */
            value: {
              notify: true,
              type: String,
            },

            /**
             * Set to true to mark the input as required. If used in a form, a
             * custom element that uses this behavior should also use
             * IronValidatableBehavior and define a custom validation method.
             * Otherwise, a `required` element will always be considered valid.
             * It's also strongly recommended to provide a visual style for the element
             * when its value is invalid.
             */
            required: {
              type: Boolean,
              value: false,
            },
          },
          // Empty implementations for backcompatibility.
          attached: function attached() {},
          detached: function detached() {},
        };

        /***/
      },

    /***/ "./node_modules/@polymer/iron-validatable-behavior/iron-validatable-behavior.js":
      /*!**************************************************************************************!*\
  !*** ./node_modules/@polymer/iron-validatable-behavior/iron-validatable-behavior.js ***!
  \**************************************************************************************/
      /*! exports provided: IronValidatableBehaviorMeta, IronValidatableBehavior */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "IronValidatableBehaviorMeta",
          function() {
            return IronValidatableBehaviorMeta;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "IronValidatableBehavior",
          function() {
            return IronValidatableBehavior;
          }
        );
        /* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @polymer/polymer/polymer-legacy.js */ "./node_modules/@polymer/polymer/polymer-legacy.js"
        );
        /* harmony import */ var _polymer_iron_meta_iron_meta_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @polymer/iron-meta/iron-meta.js */ "./node_modules/@polymer/iron-meta/iron-meta.js"
        );
        /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

        /**
         * Singleton IronMeta instance.
         */

        var IronValidatableBehaviorMeta = null;
        /**
         * `Use IronValidatableBehavior` to implement an element that validates
         * user input. Use the related `IronValidatorBehavior` to add custom
         * validation logic to an iron-input.
         *
         * By default, an `<iron-form>` element validates its fields when the user
         * presses the submit button. To validate a form imperatively, call the form's
         * `validate()` method, which in turn will call `validate()` on all its
         * children. By using `IronValidatableBehavior`, your custom element
         * will get a public `validate()`, which will return the validity of the
         * element, and a corresponding `invalid` attribute, which can be used for
         * styling.
         *
         * To implement the custom validation logic of your element, you must override
         * the protected `_getValidity()` method of this behaviour, rather than
         * `validate()`. See
         * [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
         * for an example.
         *
         * ### Accessibility
         *
         * Changing the `invalid` property, either manually or by calling `validate()`
         * will update the `aria-invalid` attribute.
         *
         * @demo demo/index.html
         * @polymerBehavior
         */

        var IronValidatableBehavior = {
          properties: {
            /**
             * Name of the validator to use.
             */
            validator: {
              type: String,
            },

            /**
             * True if the last call to `validate` is invalid.
             */
            invalid: {
              notify: true,
              reflectToAttribute: true,
              type: Boolean,
              value: false,
              observer: "_invalidChanged",
            },
          },
          registered: function registered() {
            IronValidatableBehaviorMeta = new _polymer_iron_meta_iron_meta_js__WEBPACK_IMPORTED_MODULE_1__[
              "IronMeta"
            ]({
              type: "validator",
            });
          },
          _invalidChanged: function _invalidChanged() {
            if (this.invalid) {
              this.setAttribute("aria-invalid", "true");
            } else {
              this.removeAttribute("aria-invalid");
            }
          },

          /* Recompute this every time it's needed, because we don't know if the
           * underlying IronValidatableBehaviorMeta has changed. */
          get _validator() {
            return (
              IronValidatableBehaviorMeta &&
              IronValidatableBehaviorMeta.byKey(this.validator)
            );
          },

          /**
           * @return {boolean} True if the validator `validator` exists.
           */
          hasValidator: function hasValidator() {
            return this._validator != null;
          },

          /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.
    * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is
   set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
          validate: function validate(value) {
            // If this is an element that also has a value property, and there was
            // no explicit value argument passed, use the element's property instead.
            if (value === undefined && this.value !== undefined)
              this.invalid = !this._getValidity(this.value);
            else this.invalid = !this._getValidity(value);
            return !this.invalid;
          },

          /**
           * Returns true if `value` is valid.  By default, it is passed
           * to the validator's `validate()` function, if a validator is set. You
           * should override this method if you want to implement custom validity
           * logic for your element.
           *
           * @param {Object} value The value to be validated.
           * @return {boolean} True if `value` is valid.
           */
          _getValidity: function _getValidity(value) {
            if (this.hasValidator()) {
              return this._validator.validate(value);
            }

            return true;
          },
        };

        /***/
      },

    /***/ "./node_modules/@polymer/paper-behaviors/paper-checked-element-behavior.js":
      /*!*********************************************************************************!*\
  !*** ./node_modules/@polymer/paper-behaviors/paper-checked-element-behavior.js ***!
  \*********************************************************************************/
      /*! exports provided: PaperCheckedElementBehaviorImpl, PaperCheckedElementBehavior */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "PaperCheckedElementBehaviorImpl",
          function() {
            return PaperCheckedElementBehaviorImpl;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "PaperCheckedElementBehavior",
          function() {
            return PaperCheckedElementBehavior;
          }
        );
        /* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @polymer/polymer/polymer-legacy.js */ "./node_modules/@polymer/polymer/polymer-legacy.js"
        );
        /* harmony import */ var _polymer_iron_checked_element_behavior_iron_checked_element_behavior_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @polymer/iron-checked-element-behavior/iron-checked-element-behavior.js */ "./node_modules/@polymer/iron-checked-element-behavior/iron-checked-element-behavior.js"
        );
        /* harmony import */ var _paper_inky_focus_behavior_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ./paper-inky-focus-behavior.js */ "./node_modules/@polymer/paper-behaviors/paper-inky-focus-behavior.js"
        );
        /* harmony import */ var _paper_ripple_behavior_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          /*! ./paper-ripple-behavior.js */ "./node_modules/@polymer/paper-behaviors/paper-ripple-behavior.js"
        );
        /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

        /**
         * Use `PaperCheckedElementBehavior` to implement a custom element that has a
         * `checked` property similar to `IronCheckedElementBehavior` and is compatible
         * with having a ripple effect.
         * @polymerBehavior PaperCheckedElementBehavior
         */

        var PaperCheckedElementBehaviorImpl = {
          /**
           * Synchronizes the element's checked state with its ripple effect.
           */
          _checkedChanged: function _checkedChanged() {
            _polymer_iron_checked_element_behavior_iron_checked_element_behavior_js__WEBPACK_IMPORTED_MODULE_1__[
              "IronCheckedElementBehaviorImpl"
            ]._checkedChanged.call(this);

            if (this.hasRipple()) {
              if (this.checked) {
                this._ripple.setAttribute("checked", "");
              } else {
                this._ripple.removeAttribute("checked");
              }
            }
          },

          /**
           * Synchronizes the element's `active` and `checked` state.
           */
          _buttonStateChanged: function _buttonStateChanged() {
            _paper_ripple_behavior_js__WEBPACK_IMPORTED_MODULE_3__[
              "PaperRippleBehavior"
            ]._buttonStateChanged.call(this);

            if (this.disabled) {
              return;
            }

            if (this.isAttached) {
              this.checked = this.active;
            }
          },
        };
        /** @polymerBehavior */

        var PaperCheckedElementBehavior = [
          _paper_inky_focus_behavior_js__WEBPACK_IMPORTED_MODULE_2__[
            "PaperInkyFocusBehavior"
          ],
          _polymer_iron_checked_element_behavior_iron_checked_element_behavior_js__WEBPACK_IMPORTED_MODULE_1__[
            "IronCheckedElementBehavior"
          ],
          PaperCheckedElementBehaviorImpl,
        ];

        /***/
      },

    /***/ "./node_modules/@polymer/paper-listbox/paper-listbox.js":
      /*!**************************************************************!*\
  !*** ./node_modules/@polymer/paper-listbox/paper-listbox.js ***!
  \**************************************************************/
      /*! no exports provided */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @polymer/polymer/polymer-legacy.js */ "./node_modules/@polymer/polymer/polymer-legacy.js"
        );
        /* harmony import */ var _polymer_paper_styles_default_theme_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @polymer/paper-styles/default-theme.js */ "./node_modules/@polymer/paper-styles/default-theme.js"
        );
        /* harmony import */ var _polymer_iron_menu_behavior_iron_menu_behavior_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! @polymer/iron-menu-behavior/iron-menu-behavior.js */ "./node_modules/@polymer/iron-menu-behavior/iron-menu-behavior.js"
        );
        /* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          /*! @polymer/polymer/lib/legacy/polymer-fn.js */ "./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js"
        );
        /* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          /*! @polymer/polymer/lib/utils/html-tag.js */ "./node_modules/@polymer/polymer/lib/utils/html-tag.js"
        );
        function _templateObject() {
          var data = _taggedTemplateLiteral([
            "\n    <style>\n      :host {\n        display: block;\n        padding: 8px 0;\n\n        background: var(--paper-listbox-background-color, var(--primary-background-color));\n        color: var(--paper-listbox-color, var(--primary-text-color));\n\n        @apply --paper-listbox;\n      }\n    </style>\n\n    <slot></slot>\n",
          ]);

          _templateObject = function _templateObject() {
            return data;
          };

          return data;
        }

        function _taggedTemplateLiteral(strings, raw) {
          if (!raw) {
            raw = strings.slice(0);
          }
          return Object.freeze(
            Object.defineProperties(strings, {
              raw: { value: Object.freeze(raw) },
            })
          );
        }

        /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

        /**
Material design:
[Menus](https://www.google.com/design/spec/components/menus.html)

`<paper-listbox>` implements an accessible listbox control with Material Design
styling. The focused item is highlighted, and the selected item has bolded text.

    <paper-listbox>
      <paper-item>Item 1</paper-item>
      <paper-item>Item 2</paper-item>
    </paper-listbox>

An initial selection can be specified with the `selected` attribute.

    <paper-listbox selected="0">
      <paper-item>Item 1</paper-item>
      <paper-item>Item 2</paper-item>
    </paper-listbox>

Make a multi-select listbox with the `multi` attribute. Items in a multi-select
listbox can be deselected, and multiple item can be selected.

    <paper-listbox multi>
      <paper-item>Item 1</paper-item>
      <paper-item>Item 2</paper-item>
    </paper-listbox>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-listbox-background-color`   | Menu background color |
`--primary-background-color`
`--paper-listbox-color`              | Menu foreground color |
`--primary-text-color`
`--paper-listbox`                    | Mixin applied to the listbox | `{}`

### Accessibility

`<paper-listbox>` has `role="listbox"` by default. A multi-select listbox will
also have `aria-multiselectable` set. It implements key bindings to navigate
through the listbox with the up and down arrow keys, esc to exit the listbox,
and enter to activate a listbox item. Typing the first letter of a listbox item
will also focus it.

@group Paper Elements
@element paper-listbox
@demo demo/index.html
*/

        Object(
          _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__[
            "Polymer"
          ]
        )({
          _template: Object(
            _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__[
              "html"
            ]
          )(_templateObject()),
          is: "paper-listbox",
          behaviors: [
            _polymer_iron_menu_behavior_iron_menu_behavior_js__WEBPACK_IMPORTED_MODULE_2__[
              "IronMenuBehavior"
            ],
          ],

          /** @private */
          hostAttributes: {
            role: "listbox",
          },
        });

        /***/
      },

    /***/ "./node_modules/classnames/index.js":
      /*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

        /* global define */
        (function() {
          "use strict";

          var hasOwn = {}.hasOwnProperty;

          function classNames() {
            var classes = [];

            for (var i = 0; i < arguments.length; i++) {
              var arg = arguments[i];
              if (!arg) continue;

              var argType = _typeof(arg);

              if (argType === "string" || argType === "number") {
                classes.push(arg);
              } else if (Array.isArray(arg) && arg.length) {
                var inner = classNames.apply(null, arg);

                if (inner) {
                  classes.push(inner);
                }
              } else if (argType === "object") {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              }
            }

            return classes.join(" ");
          }

          if (true && module.exports) {
            classNames.default = classNames;
            module.exports = classNames;
          } else if (
            true &&
            _typeof(
              __webpack_require__(
                /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
              )
            ) === "object" &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            )
          ) {
            // register as 'classnames', consistent with npm package name
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
              return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            window.classNames = classNames;
          }
        })();

        /***/
      },

    /***/ "./node_modules/date-arithmetic/index.js":
      /*!***********************************************!*\
  !*** ./node_modules/date-arithmetic/index.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        var MILI = "milliseconds",
          SECONDS = "seconds",
          MINUTES = "minutes",
          HOURS = "hours",
          DAY = "day",
          WEEK = "week",
          MONTH = "month",
          YEAR = "year",
          DECADE = "decade",
          CENTURY = "century";
        var dates = (module.exports = {
          add: function add(date, num, unit) {
            date = new Date(date);

            switch (unit) {
              case MILI:
              case SECONDS:
              case MINUTES:
              case HOURS:
              case YEAR:
                return dates[unit](date, dates[unit](date) + num);

              case DAY:
                return dates.date(date, dates.date(date) + num);

              case WEEK:
                return dates.date(date, dates.date(date) + 7 * num);

              case MONTH:
                return monthMath(date, num);

              case DECADE:
                return dates.year(date, dates.year(date) + num * 10);

              case CENTURY:
                return dates.year(date, dates.year(date) + num * 100);
            }

            throw new TypeError('Invalid units: "' + unit + '"');
          },
          subtract: function subtract(date, num, unit) {
            return dates.add(date, -num, unit);
          },
          startOf: function startOf(date, unit, firstOfWeek) {
            date = new Date(date);

            switch (unit) {
              case "century":
              case "decade":
              case "year":
                date = dates.month(date, 0);

              case "month":
                date = dates.date(date, 1);

              case "week":
              case "day":
                date = dates.hours(date, 0);

              case "hours":
                date = dates.minutes(date, 0);

              case "minutes":
                date = dates.seconds(date, 0);

              case "seconds":
                date = dates.milliseconds(date, 0);
            }

            if (unit === DECADE)
              date = dates.subtract(date, dates.year(date) % 10, "year");
            if (unit === CENTURY)
              date = dates.subtract(date, dates.year(date) % 100, "year");
            if (unit === WEEK) date = dates.weekday(date, 0, firstOfWeek);
            return date;
          },
          endOf: function endOf(date, unit, firstOfWeek) {
            date = new Date(date);
            date = dates.startOf(date, unit, firstOfWeek);
            date = dates.add(date, 1, unit);
            date = dates.subtract(date, 1, MILI);
            return date;
          },
          eq: createComparer(function(a, b) {
            return a === b;
          }),
          neq: createComparer(function(a, b) {
            return a !== b;
          }),
          gt: createComparer(function(a, b) {
            return a > b;
          }),
          gte: createComparer(function(a, b) {
            return a >= b;
          }),
          lt: createComparer(function(a, b) {
            return a < b;
          }),
          lte: createComparer(function(a, b) {
            return a <= b;
          }),
          min: function min() {
            return new Date(Math.min.apply(Math, arguments));
          },
          max: function max() {
            return new Date(Math.max.apply(Math, arguments));
          },
          inRange: function inRange(day, min, max, unit) {
            unit = unit || "day";
            return (
              (!min || dates.gte(day, min, unit)) &&
              (!max || dates.lte(day, max, unit))
            );
          },
          milliseconds: createAccessor("Milliseconds"),
          seconds: createAccessor("Seconds"),
          minutes: createAccessor("Minutes"),
          hours: createAccessor("Hours"),
          day: createAccessor("Day"),
          date: createAccessor("Date"),
          month: createAccessor("Month"),
          year: createAccessor("FullYear"),
          decade: function decade(date, val) {
            return val === undefined
              ? dates.year(dates.startOf(date, DECADE))
              : dates.add(date, val + 10, YEAR);
          },
          century: function century(date, val) {
            return val === undefined
              ? dates.year(dates.startOf(date, CENTURY))
              : dates.add(date, val + 100, YEAR);
          },
          weekday: function weekday(date, val, firstDay) {
            var weekday = (dates.day(date) + 7 - (firstDay || 0)) % 7;
            return val === undefined
              ? weekday
              : dates.add(date, val - weekday, DAY);
          },
          diff: function diff(date1, date2, unit, asFloat) {
            var dividend, divisor, result;

            switch (unit) {
              case MILI:
              case SECONDS:
              case MINUTES:
              case HOURS:
              case DAY:
              case WEEK:
                dividend = date2.getTime() - date1.getTime();
                break;

              case MONTH:
              case YEAR:
              case DECADE:
              case CENTURY:
                dividend =
                  (dates.year(date2) - dates.year(date1)) * 12 +
                  dates.month(date2) -
                  dates.month(date1);
                break;

              default:
                throw new TypeError('Invalid units: "' + unit + '"');
            }

            switch (unit) {
              case MILI:
                divisor = 1;
                break;

              case SECONDS:
                divisor = 1000;
                break;

              case MINUTES:
                divisor = 1000 * 60;
                break;

              case HOURS:
                divisor = 1000 * 60 * 60;
                break;

              case DAY:
                divisor = 1000 * 60 * 60 * 24;
                break;

              case WEEK:
                divisor = 1000 * 60 * 60 * 24 * 7;
                break;

              case MONTH:
                divisor = 1;
                break;

              case YEAR:
                divisor = 12;
                break;

              case DECADE:
                divisor = 120;
                break;

              case CENTURY:
                divisor = 1200;
                break;

              default:
                throw new TypeError('Invalid units: "' + unit + '"');
            }

            result = dividend / divisor;
            return asFloat ? result : absoluteFloor(result);
          },
        });

        function absoluteFloor(number) {
          return number < 0 ? Math.ceil(number) : Math.floor(number);
        }

        function monthMath(date, val) {
          var current = dates.month(date),
            newMonth = current + val;
          date = dates.month(date, newMonth);

          while (newMonth < 0) {
            newMonth = 12 + newMonth;
          } //month rollover

          if (dates.month(date) !== newMonth % 12) date = dates.date(date, 0); //move to last of month

          return date;
        }

        function createAccessor(method) {
          return function(date, val) {
            if (val === undefined) return date["get" + method]();
            date = new Date(date);
            date["set" + method](val);
            return date;
          };
        }

        function createComparer(operator) {
          return function(a, b, unit) {
            return operator(+dates.startOf(a, unit), +dates.startOf(b, unit));
          };
        }

        /***/
      },

    /***/ "./node_modules/dom-helpers/class/addClass.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/class/addClass.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = addClass;

        var _hasClass = _interopRequireDefault(
          __webpack_require__(
            /*! ./hasClass */ "./node_modules/dom-helpers/class/hasClass.js"
          )
        );

        function addClass(element, className) {
          if (element.classList) element.classList.add(className);
          else if (!(0, _hasClass.default)(element, className))
            if (typeof element.className === "string")
              element.className = element.className + " " + className;
            else
              element.setAttribute(
                "class",
                ((element.className && element.className.baseVal) || "") +
                  " " +
                  className
              );
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/class/hasClass.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/class/hasClass.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = hasClass;

        function hasClass(element, className) {
          if (element.classList)
            return !!className && element.classList.contains(className);
          else
            return (
              (
                " " +
                (element.className.baseVal || element.className) +
                " "
              ).indexOf(" " + className + " ") !== -1
            );
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/class/index.js":
      /*!*************************************************!*\
  !*** ./node_modules/dom-helpers/class/index.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _addClass = _interopRequireDefault(
          __webpack_require__(
            /*! ./addClass */ "./node_modules/dom-helpers/class/addClass.js"
          )
        );

        exports.addClass = _addClass.default;

        var _removeClass = _interopRequireDefault(
          __webpack_require__(
            /*! ./removeClass */ "./node_modules/dom-helpers/class/removeClass.js"
          )
        );

        exports.removeClass = _removeClass.default;

        var _hasClass = _interopRequireDefault(
          __webpack_require__(
            /*! ./hasClass */ "./node_modules/dom-helpers/class/hasClass.js"
          )
        );

        exports.hasClass = _hasClass.default;
        var _default = {
          addClass: _addClass.default,
          removeClass: _removeClass.default,
          hasClass: _hasClass.default,
        };
        exports.default = _default;

        /***/
      },

    /***/ "./node_modules/dom-helpers/class/removeClass.js":
      /*!*******************************************************!*\
  !*** ./node_modules/dom-helpers/class/removeClass.js ***!
  \*******************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function replaceClassName(origClass, classToRemove) {
          return origClass
            .replace(
              new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"),
              "$1"
            )
            .replace(/\s+/g, " ")
            .replace(/^\s*|\s*$/g, "");
        }

        module.exports = function removeClass(element, className) {
          if (element.classList) element.classList.remove(className);
          else if (typeof element.className === "string")
            element.className = replaceClassName(element.className, className);
          else
            element.setAttribute(
              "class",
              replaceClassName(
                (element.className && element.className.baseVal) || "",
                className
              )
            );
        };

        /***/
      },

    /***/ "./node_modules/dom-helpers/events/filter.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/events/filter.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = filterEvents;

        var _contains = _interopRequireDefault(
          __webpack_require__(
            /*! ../query/contains */ "./node_modules/dom-helpers/query/contains.js"
          )
        );

        var _querySelectorAll = _interopRequireDefault(
          __webpack_require__(
            /*! ../query/querySelectorAll */ "./node_modules/dom-helpers/query/querySelectorAll.js"
          )
        );

        function filterEvents(selector, handler) {
          return function filterHandler(e) {
            var top = e.currentTarget,
              target = e.target,
              matches = (0, _querySelectorAll.default)(top, selector);
            if (
              matches.some(function(match) {
                return (0, _contains.default)(match, target);
              })
            )
              handler.call(this, e);
          };
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/events/index.js":
      /*!**************************************************!*\
  !*** ./node_modules/dom-helpers/events/index.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _on = _interopRequireDefault(
          __webpack_require__(
            /*! ./on */ "./node_modules/dom-helpers/events/on.js"
          )
        );

        exports.on = _on.default;

        var _off = _interopRequireDefault(
          __webpack_require__(
            /*! ./off */ "./node_modules/dom-helpers/events/off.js"
          )
        );

        exports.off = _off.default;

        var _filter = _interopRequireDefault(
          __webpack_require__(
            /*! ./filter */ "./node_modules/dom-helpers/events/filter.js"
          )
        );

        exports.filter = _filter.default;

        var _listen = _interopRequireDefault(
          __webpack_require__(
            /*! ./listen */ "./node_modules/dom-helpers/events/listen.js"
          )
        );

        exports.listen = _listen.default;
        var _default = {
          on: _on.default,
          off: _off.default,
          filter: _filter.default,
          listen: _listen.default,
        };
        exports.default = _default;

        /***/
      },

    /***/ "./node_modules/dom-helpers/events/listen.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/events/listen.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var _on = _interopRequireDefault(
          __webpack_require__(
            /*! ./on */ "./node_modules/dom-helpers/events/on.js"
          )
        );

        var _off = _interopRequireDefault(
          __webpack_require__(
            /*! ./off */ "./node_modules/dom-helpers/events/off.js"
          )
        );

        var listen = function listen() {};

        if (_inDOM.default) {
          listen = function listen(node, eventName, handler, capture) {
            (0, _on.default)(node, eventName, handler, capture);
            return function() {
              (0, _off.default)(node, eventName, handler, capture);
            };
          };
        }

        var _default = listen;
        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/events/off.js":
      /*!************************************************!*\
  !*** ./node_modules/dom-helpers/events/off.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var off = function off() {};

        if (_inDOM.default) {
          off = (function() {
            if (document.addEventListener)
              return function(node, eventName, handler, capture) {
                return node.removeEventListener(
                  eventName,
                  handler,
                  capture || false
                );
              };
            else if (document.attachEvent)
              return function(node, eventName, handler) {
                return node.detachEvent("on" + eventName, handler);
              };
          })();
        }

        var _default = off;
        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/events/on.js":
      /*!***********************************************!*\
  !*** ./node_modules/dom-helpers/events/on.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var on = function on() {};

        if (_inDOM.default) {
          on = (function() {
            if (document.addEventListener)
              return function(node, eventName, handler, capture) {
                return node.addEventListener(
                  eventName,
                  handler,
                  capture || false
                );
              };
            else if (document.attachEvent)
              return function(node, eventName, handler) {
                return node.attachEvent("on" + eventName, function(e) {
                  e = e || window.event;
                  e.target = e.target || e.srcElement;
                  e.currentTarget = node;
                  handler.call(node, e);
                });
              };
          })();
        }

        var _default = on;
        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/ownerDocument.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/ownerDocument.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = ownerDocument;

        function ownerDocument(node) {
          return (node && node.ownerDocument) || document;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/closest.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/query/closest.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = closest;

        var _matches = _interopRequireDefault(
          __webpack_require__(
            /*! ./matches */ "./node_modules/dom-helpers/query/matches.js"
          )
        );

        var isDoc = function isDoc(obj) {
          return obj != null && obj.nodeType === obj.DOCUMENT_NODE;
        };

        function closest(node, selector, context) {
          while (
            node &&
            (isDoc(node) || !(0, _matches.default)(node, selector))
          ) {
            node =
              node !== context && !isDoc(node) ? node.parentNode : undefined;
          }

          return node;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/contains.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/query/contains.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var _default = (function() {
          // HTML DOM and SVG DOM may have different support levels,
          // so we need to check on context instead of a document root element.
          return _inDOM.default
            ? function(context, node) {
                if (context.contains) {
                  return context.contains(node);
                } else if (context.compareDocumentPosition) {
                  return (
                    context === node ||
                    !!(context.compareDocumentPosition(node) & 16)
                  );
                } else {
                  return fallback(context, node);
                }
              }
            : fallback;
        })();

        exports.default = _default;

        function fallback(context, node) {
          if (node)
            do {
              if (node === context) return true;
            } while ((node = node.parentNode));
          return false;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/height.js":
      /*!**************************************************!*\
  !*** ./node_modules/dom-helpers/query/height.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = height;

        var _offset = _interopRequireDefault(
          __webpack_require__(
            /*! ./offset */ "./node_modules/dom-helpers/query/offset.js"
          )
        );

        var _isWindow = _interopRequireDefault(
          __webpack_require__(
            /*! ./isWindow */ "./node_modules/dom-helpers/query/isWindow.js"
          )
        );

        function height(node, client) {
          var win = (0, _isWindow.default)(node);
          return win
            ? win.innerHeight
            : client
            ? node.clientHeight
            : (0, _offset.default)(node).height;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/isWindow.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/query/isWindow.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = getWindow;

        function getWindow(node) {
          return node === node.window
            ? node
            : node.nodeType === 9
            ? node.defaultView || node.parentWindow
            : false;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/matches.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/query/matches.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = matches;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var _querySelectorAll = _interopRequireDefault(
          __webpack_require__(
            /*! ./querySelectorAll */ "./node_modules/dom-helpers/query/querySelectorAll.js"
          )
        );

        var matchesCache;

        function matches(node, selector) {
          if (!matchesCache && _inDOM.default) {
            var body = document.body;
            var nativeMatch =
              body.matches ||
              body.matchesSelector ||
              body.webkitMatchesSelector ||
              body.mozMatchesSelector ||
              body.msMatchesSelector;
            matchesCache = nativeMatch
              ? function(node, selector) {
                  return nativeMatch.call(node, selector);
                }
              : ie8MatchesSelector;
          }

          return matchesCache ? matchesCache(node, selector) : null;
        }

        function ie8MatchesSelector(node, selector) {
          var matches = (0, _querySelectorAll.default)(
              node.document || node.ownerDocument,
              selector
            ),
            i = 0;

          while (matches[i] && matches[i] !== node) {
            i++;
          }

          return !!matches[i];
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/offset.js":
      /*!**************************************************!*\
  !*** ./node_modules/dom-helpers/query/offset.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = offset;

        var _contains = _interopRequireDefault(
          __webpack_require__(
            /*! ./contains */ "./node_modules/dom-helpers/query/contains.js"
          )
        );

        var _isWindow = _interopRequireDefault(
          __webpack_require__(
            /*! ./isWindow */ "./node_modules/dom-helpers/query/isWindow.js"
          )
        );

        var _ownerDocument = _interopRequireDefault(
          __webpack_require__(
            /*! ../ownerDocument */ "./node_modules/dom-helpers/ownerDocument.js"
          )
        );

        function offset(node) {
          var doc = (0, _ownerDocument.default)(node),
            win = (0, _isWindow.default)(doc),
            docElem = doc && doc.documentElement,
            box = {
              top: 0,
              left: 0,
              height: 0,
              width: 0,
            };
          if (!doc) return; // Make sure it's not a disconnected DOM node

          if (!(0, _contains.default)(docElem, node)) return box;
          if (node.getBoundingClientRect !== undefined)
            box = node.getBoundingClientRect(); // IE8 getBoundingClientRect doesn't support width & height

          box = {
            top:
              box.top +
              (win.pageYOffset || docElem.scrollTop) -
              (docElem.clientTop || 0),
            left:
              box.left +
              (win.pageXOffset || docElem.scrollLeft) -
              (docElem.clientLeft || 0),
            width: (box.width == null ? node.offsetWidth : box.width) || 0,
            height: (box.height == null ? node.offsetHeight : box.height) || 0,
          };
          return box;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/offsetParent.js":
      /*!********************************************************!*\
  !*** ./node_modules/dom-helpers/query/offsetParent.js ***!
  \********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = offsetParent;

        var _ownerDocument = _interopRequireDefault(
          __webpack_require__(
            /*! ../ownerDocument */ "./node_modules/dom-helpers/ownerDocument.js"
          )
        );

        var _style = _interopRequireDefault(
          __webpack_require__(
            /*! ../style */ "./node_modules/dom-helpers/style/index.js"
          )
        );

        function nodeName(node) {
          return node.nodeName && node.nodeName.toLowerCase();
        }

        function offsetParent(node) {
          var doc = (0, _ownerDocument.default)(node),
            offsetParent = node && node.offsetParent;

          while (
            offsetParent &&
            nodeName(node) !== "html" &&
            (0, _style.default)(offsetParent, "position") === "static"
          ) {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || doc.documentElement;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/position.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/query/position.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = position;

        var _extends2 = _interopRequireDefault(
          __webpack_require__(
            /*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"
          )
        );

        var _offset = _interopRequireDefault(
          __webpack_require__(
            /*! ./offset */ "./node_modules/dom-helpers/query/offset.js"
          )
        );

        var _offsetParent = _interopRequireDefault(
          __webpack_require__(
            /*! ./offsetParent */ "./node_modules/dom-helpers/query/offsetParent.js"
          )
        );

        var _scrollTop = _interopRequireDefault(
          __webpack_require__(
            /*! ./scrollTop */ "./node_modules/dom-helpers/query/scrollTop.js"
          )
        );

        var _scrollLeft = _interopRequireDefault(
          __webpack_require__(
            /*! ./scrollLeft */ "./node_modules/dom-helpers/query/scrollLeft.js"
          )
        );

        var _style = _interopRequireDefault(
          __webpack_require__(
            /*! ../style */ "./node_modules/dom-helpers/style/index.js"
          )
        );

        function nodeName(node) {
          return node.nodeName && node.nodeName.toLowerCase();
        }

        function position(node, offsetParent) {
          var parentOffset = {
              top: 0,
              left: 0,
            },
            offset; // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
          // because it is its only offset parent

          if ((0, _style.default)(node, "position") === "fixed") {
            offset = node.getBoundingClientRect();
          } else {
            offsetParent = offsetParent || (0, _offsetParent.default)(node);
            offset = (0, _offset.default)(node);
            if (nodeName(offsetParent) !== "html")
              parentOffset = (0, _offset.default)(offsetParent);
            parentOffset.top +=
              parseInt(
                (0, _style.default)(offsetParent, "borderTopWidth"),
                10
              ) - (0, _scrollTop.default)(offsetParent) || 0;
            parentOffset.left +=
              parseInt(
                (0, _style.default)(offsetParent, "borderLeftWidth"),
                10
              ) - (0, _scrollLeft.default)(offsetParent) || 0;
          } // Subtract parent offsets and node margins

          return (0, _extends2.default)({}, offset, {
            top:
              offset.top -
              parentOffset.top -
              (parseInt((0, _style.default)(node, "marginTop"), 10) || 0),
            left:
              offset.left -
              parentOffset.left -
              (parseInt((0, _style.default)(node, "marginLeft"), 10) || 0),
          });
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/querySelectorAll.js":
      /*!************************************************************!*\
  !*** ./node_modules/dom-helpers/query/querySelectorAll.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = qsa; // Zepto.js
        // (c) 2010-2015 Thomas Fuchs
        // Zepto.js may be freely distributed under the MIT license.

        var simpleSelectorRE = /^[\w-]*$/;
        var toArray = Function.prototype.bind.call(
          Function.prototype.call,
          [].slice
        );

        function qsa(element, selector) {
          var maybeID = selector[0] === "#",
            maybeClass = selector[0] === ".",
            nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
            isSimple = simpleSelectorRE.test(nameOnly),
            found;

          if (isSimple) {
            if (maybeID) {
              element = element.getElementById ? element : document;
              return (found = element.getElementById(nameOnly)) ? [found] : [];
            }

            if (element.getElementsByClassName && maybeClass)
              return toArray(element.getElementsByClassName(nameOnly));
            return toArray(element.getElementsByTagName(selector));
          }

          return toArray(element.querySelectorAll(selector));
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/scrollLeft.js":
      /*!******************************************************!*\
  !*** ./node_modules/dom-helpers/query/scrollLeft.js ***!
  \******************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = scrollTop;

        var _isWindow = _interopRequireDefault(
          __webpack_require__(
            /*! ./isWindow */ "./node_modules/dom-helpers/query/isWindow.js"
          )
        );

        function scrollTop(node, val) {
          var win = (0, _isWindow.default)(node);
          if (val === undefined)
            return win
              ? "pageXOffset" in win
                ? win.pageXOffset
                : win.document.documentElement.scrollLeft
              : node.scrollLeft;
          if (win)
            win.scrollTo(
              val,
              "pageYOffset" in win
                ? win.pageYOffset
                : win.document.documentElement.scrollTop
            );
          else node.scrollLeft = val;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/scrollTop.js":
      /*!*****************************************************!*\
  !*** ./node_modules/dom-helpers/query/scrollTop.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = scrollTop;

        var _isWindow = _interopRequireDefault(
          __webpack_require__(
            /*! ./isWindow */ "./node_modules/dom-helpers/query/isWindow.js"
          )
        );

        function scrollTop(node, val) {
          var win = (0, _isWindow.default)(node);
          if (val === undefined)
            return win
              ? "pageYOffset" in win
                ? win.pageYOffset
                : win.document.documentElement.scrollTop
              : node.scrollTop;
          if (win)
            win.scrollTo(
              "pageXOffset" in win
                ? win.pageXOffset
                : win.document.documentElement.scrollLeft,
              val
            );
          else node.scrollTop = val;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/query/width.js":
      /*!*************************************************!*\
  !*** ./node_modules/dom-helpers/query/width.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = width;

        var _offset = _interopRequireDefault(
          __webpack_require__(
            /*! ./offset */ "./node_modules/dom-helpers/query/offset.js"
          )
        );

        var _isWindow = _interopRequireDefault(
          __webpack_require__(
            /*! ./isWindow */ "./node_modules/dom-helpers/query/isWindow.js"
          )
        );

        function width(node, client) {
          var win = (0, _isWindow.default)(node);
          return win
            ? win.innerWidth
            : client
            ? node.clientWidth
            : (0, _offset.default)(node).width;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/style/getComputedStyle.js":
      /*!************************************************************!*\
  !*** ./node_modules/dom-helpers/style/getComputedStyle.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = _getComputedStyle;

        var _camelizeStyle = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/camelizeStyle */ "./node_modules/dom-helpers/util/camelizeStyle.js"
          )
        );

        var rposition = /^(top|right|bottom|left)$/;
        var rnumnonpx = /^([+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|))(?!px)[a-z%]+$/i;

        function _getComputedStyle(node) {
          if (!node)
            throw new TypeError("No Element passed to `getComputedStyle()`");
          var doc = node.ownerDocument;
          return "defaultView" in doc
            ? doc.defaultView.opener
              ? node.ownerDocument.defaultView.getComputedStyle(node, null)
              : window.getComputedStyle(node, null)
            : {
                //ie 8 "magic" from: https://github.com/jquery/jquery/blob/1.11-stable/src/css/curCSS.js#L72
                getPropertyValue: function getPropertyValue(prop) {
                  var style = node.style;
                  prop = (0, _camelizeStyle.default)(prop);
                  if (prop == "float") prop = "styleFloat";
                  var current = node.currentStyle[prop] || null;
                  if (current == null && style && style[prop])
                    current = style[prop];

                  if (rnumnonpx.test(current) && !rposition.test(prop)) {
                    // Remember the original values
                    var left = style.left;
                    var runStyle = node.runtimeStyle;
                    var rsLeft = runStyle && runStyle.left; // Put in the new values to get a computed value out

                    if (rsLeft) runStyle.left = node.currentStyle.left;
                    style.left = prop === "fontSize" ? "1em" : current;
                    current = style.pixelLeft + "px"; // Revert the changed values

                    style.left = left;
                    if (rsLeft) runStyle.left = rsLeft;
                  }

                  return current;
                },
              };
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/style/index.js":
      /*!*************************************************!*\
  !*** ./node_modules/dom-helpers/style/index.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = style;

        var _camelizeStyle = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/camelizeStyle */ "./node_modules/dom-helpers/util/camelizeStyle.js"
          )
        );

        var _hyphenateStyle = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/hyphenateStyle */ "./node_modules/dom-helpers/util/hyphenateStyle.js"
          )
        );

        var _getComputedStyle2 = _interopRequireDefault(
          __webpack_require__(
            /*! ./getComputedStyle */ "./node_modules/dom-helpers/style/getComputedStyle.js"
          )
        );

        var _removeStyle = _interopRequireDefault(
          __webpack_require__(
            /*! ./removeStyle */ "./node_modules/dom-helpers/style/removeStyle.js"
          )
        );

        var _properties = __webpack_require__(
          /*! ../transition/properties */ "./node_modules/dom-helpers/transition/properties.js"
        );

        var _isTransform = _interopRequireDefault(
          __webpack_require__(
            /*! ../transition/isTransform */ "./node_modules/dom-helpers/transition/isTransform.js"
          )
        );

        function style(node, property, value) {
          var css = "";
          var transforms = "";
          var props = property;

          if (typeof property === "string") {
            if (value === undefined) {
              return (
                node.style[(0, _camelizeStyle.default)(property)] ||
                (0, _getComputedStyle2.default)(node).getPropertyValue(
                  (0, _hyphenateStyle.default)(property)
                )
              );
            } else {
              (props = {})[property] = value;
            }
          }

          Object.keys(props).forEach(function(key) {
            var value = props[key];

            if (!value && value !== 0) {
              (0, _removeStyle.default)(
                node,
                (0, _hyphenateStyle.default)(key)
              );
            } else if ((0, _isTransform.default)(key)) {
              transforms += key + "(" + value + ") ";
            } else {
              css += (0, _hyphenateStyle.default)(key) + ": " + value + ";";
            }
          });

          if (transforms) {
            css += _properties.transform + ": " + transforms + ";";
          }

          node.style.cssText += ";" + css;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/style/removeStyle.js":
      /*!*******************************************************!*\
  !*** ./node_modules/dom-helpers/style/removeStyle.js ***!
  \*******************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = removeStyle;

        function removeStyle(node, key) {
          return "removeProperty" in node.style
            ? node.style.removeProperty(key)
            : node.style.removeAttribute(key);
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/transition/isTransform.js":
      /*!************************************************************!*\
  !*** ./node_modules/dom-helpers/transition/isTransform.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = isTransform;
        var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;

        function isTransform(property) {
          return !!(property && supportedTransforms.test(property));
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/transition/properties.js":
      /*!***********************************************************!*\
  !*** ./node_modules/dom-helpers/transition/properties.js ***!
  \***********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = exports.animationEnd = exports.animationDelay = exports.animationTiming = exports.animationDuration = exports.animationName = exports.transitionEnd = exports.transitionDuration = exports.transitionDelay = exports.transitionTiming = exports.transitionProperty = exports.transform = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ../util/inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var transform = "transform";
        exports.transform = transform;
        var prefix, transitionEnd, animationEnd;
        exports.animationEnd = animationEnd;
        exports.transitionEnd = transitionEnd;
        var transitionProperty,
          transitionDuration,
          transitionTiming,
          transitionDelay;
        exports.transitionDelay = transitionDelay;
        exports.transitionTiming = transitionTiming;
        exports.transitionDuration = transitionDuration;
        exports.transitionProperty = transitionProperty;
        var animationName, animationDuration, animationTiming, animationDelay;
        exports.animationDelay = animationDelay;
        exports.animationTiming = animationTiming;
        exports.animationDuration = animationDuration;
        exports.animationName = animationName;

        if (_inDOM.default) {
          var _getTransitionPropert = getTransitionProperties();

          prefix = _getTransitionPropert.prefix;
          exports.transitionEnd = transitionEnd =
            _getTransitionPropert.transitionEnd;
          exports.animationEnd = animationEnd =
            _getTransitionPropert.animationEnd;
          exports.transform = transform = prefix + "-" + transform;
          exports.transitionProperty = transitionProperty =
            prefix + "-transition-property";
          exports.transitionDuration = transitionDuration =
            prefix + "-transition-duration";
          exports.transitionDelay = transitionDelay =
            prefix + "-transition-delay";
          exports.transitionTiming = transitionTiming =
            prefix + "-transition-timing-function";
          exports.animationName = animationName = prefix + "-animation-name";
          exports.animationDuration = animationDuration =
            prefix + "-animation-duration";
          exports.animationTiming = animationTiming =
            prefix + "-animation-delay";
          exports.animationDelay = animationDelay =
            prefix + "-animation-timing-function";
        }

        var _default = {
          transform: transform,
          end: transitionEnd,
          property: transitionProperty,
          timing: transitionTiming,
          delay: transitionDelay,
          duration: transitionDuration,
        };
        exports.default = _default;

        function getTransitionProperties() {
          var style = document.createElement("div").style;
          var vendorMap = {
            O: function O(e) {
              return "o" + e.toLowerCase();
            },
            Moz: function Moz(e) {
              return e.toLowerCase();
            },
            Webkit: function Webkit(e) {
              return "webkit" + e;
            },
            ms: function ms(e) {
              return "MS" + e;
            },
          };
          var vendors = Object.keys(vendorMap);
          var transitionEnd, animationEnd;
          var prefix = "";

          for (var i = 0; i < vendors.length; i++) {
            var vendor = vendors[i];

            if (vendor + "TransitionProperty" in style) {
              prefix = "-" + vendor.toLowerCase();
              transitionEnd = vendorMap[vendor]("TransitionEnd");
              animationEnd = vendorMap[vendor]("AnimationEnd");
              break;
            }
          }

          if (!transitionEnd && "transitionProperty" in style)
            transitionEnd = "transitionend";
          if (!animationEnd && "animationName" in style)
            animationEnd = "animationend";
          style = null;
          return {
            animationEnd: animationEnd,
            transitionEnd: transitionEnd,
            prefix: prefix,
          };
        }

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/camelize.js":
      /*!***************************************************!*\
  !*** ./node_modules/dom-helpers/util/camelize.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = camelize;
        var rHyphen = /-(.)/g;

        function camelize(string) {
          return string.replace(rHyphen, function(_, chr) {
            return chr.toUpperCase();
          });
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/camelizeStyle.js":
      /*!********************************************************!*\
  !*** ./node_modules/dom-helpers/util/camelizeStyle.js ***!
  \********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = camelizeStyleName;

        var _camelize = _interopRequireDefault(
          __webpack_require__(
            /*! ./camelize */ "./node_modules/dom-helpers/util/camelize.js"
          )
        );
        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/camelizeStyleName.js
         */

        var msPattern = /^-ms-/;

        function camelizeStyleName(string) {
          return (0, _camelize.default)(string.replace(msPattern, "ms-"));
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/hyphenate.js":
      /*!****************************************************!*\
  !*** ./node_modules/dom-helpers/util/hyphenate.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = hyphenate;
        var rUpper = /([A-Z])/g;

        function hyphenate(string) {
          return string.replace(rUpper, "-$1").toLowerCase();
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/hyphenateStyle.js":
      /*!*********************************************************!*\
  !*** ./node_modules/dom-helpers/util/hyphenateStyle.js ***!
  \*********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = hyphenateStyleName;

        var _hyphenate = _interopRequireDefault(
          __webpack_require__(
            /*! ./hyphenate */ "./node_modules/dom-helpers/util/hyphenate.js"
          )
        );
        /**
         * Copyright 2013-2014, Facebook, Inc.
         * All rights reserved.
         * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
         */

        var msPattern = /^ms-/;

        function hyphenateStyleName(string) {
          return (0, _hyphenate.default)(string).replace(msPattern, "-ms-");
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/inDOM.js":
      /*!************************************************!*\
  !*** ./node_modules/dom-helpers/util/inDOM.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = void 0;

        var _default = !!(
          typeof window !== "undefined" &&
          window.document &&
          window.document.createElement
        );

        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/requestAnimationFrame.js":
      /*!****************************************************************!*\
  !*** ./node_modules/dom-helpers/util/requestAnimationFrame.js ***!
  \****************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ./inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var vendors = ["", "webkit", "moz", "o", "ms"];
        var cancel = "clearTimeout";
        var raf = fallback;
        var compatRaf;

        var getKey = function getKey(vendor, k) {
          return (
            vendor +
            (!vendor ? k : k[0].toUpperCase() + k.substr(1)) +
            "AnimationFrame"
          );
        };

        if (_inDOM.default) {
          vendors.some(function(vendor) {
            var rafKey = getKey(vendor, "request");

            if (rafKey in window) {
              cancel = getKey(vendor, "cancel");
              return (raf = function raf(cb) {
                return window[rafKey](cb);
              });
            }
          });
        }
        /* https://github.com/component/raf */

        var prev = new Date().getTime();

        function fallback(fn) {
          var curr = new Date().getTime(),
            ms = Math.max(0, 16 - (curr - prev)),
            req = setTimeout(fn, ms);
          prev = curr;
          return req;
        }

        compatRaf = function compatRaf(cb) {
          return raf(cb);
        };

        compatRaf.cancel = function(id) {
          window[cancel] &&
            typeof window[cancel] === "function" &&
            window[cancel](id);
        };

        var _default = compatRaf;
        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/dom-helpers/util/scrollbarSize.js":
      /*!********************************************************!*\
  !*** ./node_modules/dom-helpers/util/scrollbarSize.js ***!
  \********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = scrollbarSize;

        var _inDOM = _interopRequireDefault(
          __webpack_require__(
            /*! ./inDOM */ "./node_modules/dom-helpers/util/inDOM.js"
          )
        );

        var size;

        function scrollbarSize(recalc) {
          if ((!size && size !== 0) || recalc) {
            if (_inDOM.default) {
              var scrollDiv = document.createElement("div");
              scrollDiv.style.position = "absolute";
              scrollDiv.style.top = "-9999px";
              scrollDiv.style.width = "50px";
              scrollDiv.style.height = "50px";
              scrollDiv.style.overflow = "scroll";
              document.body.appendChild(scrollDiv);
              size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
              document.body.removeChild(scrollDiv);
            }
          }

          return size;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/invariant/browser.js":
      /*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var invariant = function invariant(
          condition,
          format,
          a,
          b,
          c,
          d,
          e,
          f
        ) {
          if (true) {
            if (format === undefined) {
              throw new Error("invariant requires an error message argument");
            }
          }

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                "Minified exception occurred; use the non-minified dev environment " +
                  "for the full error message and additional helpful warnings."
              );
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = "Invariant Violation";
            }

            error.framesToPop = 1; // we don't care about invariant's own frame

            throw error;
          }
        };

        module.exports = invariant;

        /***/
      },

    /***/ "./node_modules/lodash/_DataView.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
          ),
          root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
        /* Built-in method references that are verified to be native. */

        var DataView = getNative(root, "DataView");
        module.exports = DataView;

        /***/
      },

    /***/ "./node_modules/lodash/_Hash.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var hashClear = __webpack_require__(
            /*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"
          ),
          hashDelete = __webpack_require__(
            /*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"
          ),
          hashGet = __webpack_require__(
            /*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"
          ),
          hashHas = __webpack_require__(
            /*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"
          ),
          hashSet = __webpack_require__(
            /*! ./_hashSet */ "./node_modules/lodash/_hashSet.js"
          );
        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `Hash`.

        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        module.exports = Hash;

        /***/
      },

    /***/ "./node_modules/lodash/_ListCache.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var listCacheClear = __webpack_require__(
            /*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"
          ),
          listCacheDelete = __webpack_require__(
            /*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"
          ),
          listCacheGet = __webpack_require__(
            /*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"
          ),
          listCacheHas = __webpack_require__(
            /*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"
          ),
          listCacheSet = __webpack_require__(
            /*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js"
          );
        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `ListCache`.

        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        module.exports = ListCache;

        /***/
      },

    /***/ "./node_modules/lodash/_Map.js":
      /*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
          ),
          root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
        /* Built-in method references that are verified to be native. */

        var Map = getNative(root, "Map");
        module.exports = Map;

        /***/
      },

    /***/ "./node_modules/lodash/_MapCache.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var mapCacheClear = __webpack_require__(
            /*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"
          ),
          mapCacheDelete = __webpack_require__(
            /*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"
          ),
          mapCacheGet = __webpack_require__(
            /*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"
          ),
          mapCacheHas = __webpack_require__(
            /*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"
          ),
          mapCacheSet = __webpack_require__(
            /*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js"
          );
        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `MapCache`.

        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        module.exports = MapCache;

        /***/
      },

    /***/ "./node_modules/lodash/_Promise.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
          ),
          root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
        /* Built-in method references that are verified to be native. */

        var Promise = getNative(root, "Promise");
        module.exports = Promise;

        /***/
      },

    /***/ "./node_modules/lodash/_Set.js":
      /*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
          ),
          root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
        /* Built-in method references that are verified to be native. */

        var Set = getNative(root, "Set");
        module.exports = Set;

        /***/
      },

    /***/ "./node_modules/lodash/_SetCache.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(
            /*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"
          ),
          setCacheAdd = __webpack_require__(
            /*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"
          ),
          setCacheHas = __webpack_require__(
            /*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js"
          );
        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */

        function SetCache(values) {
          var index = -1,
            length = values == null ? 0 : values.length;
          this.__data__ = new MapCache();

          while (++index < length) {
            this.add(values[index]);
          }
        } // Add methods to `SetCache`.

        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        module.exports = SetCache;

        /***/
      },

    /***/ "./node_modules/lodash/_Stack.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(
            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
          ),
          stackClear = __webpack_require__(
            /*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"
          ),
          stackDelete = __webpack_require__(
            /*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"
          ),
          stackGet = __webpack_require__(
            /*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"
          ),
          stackHas = __webpack_require__(
            /*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"
          ),
          stackSet = __webpack_require__(
            /*! ./_stackSet */ "./node_modules/lodash/_stackSet.js"
          );
        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Stack(entries) {
          var data = (this.__data__ = new ListCache(entries));
          this.size = data.size;
        } // Add methods to `Stack`.

        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        module.exports = Stack;

        /***/
      },

    /***/ "./node_modules/lodash/_Symbol.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var root = __webpack_require__(
          /*! ./_root */ "./node_modules/lodash/_root.js"
        );
        /** Built-in value references. */

        var _Symbol = root.Symbol;
        module.exports = _Symbol;

        /***/
      },

    /***/ "./node_modules/lodash/_Uint8Array.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var root = __webpack_require__(
          /*! ./_root */ "./node_modules/lodash/_root.js"
        );
        /** Built-in value references. */

        var Uint8Array = root.Uint8Array;
        module.exports = Uint8Array;

        /***/
      },

    /***/ "./node_modules/lodash/_WeakMap.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
          ),
          root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
        /* Built-in method references that are verified to be native. */

        var WeakMap = getNative(root, "WeakMap");
        module.exports = WeakMap;

        /***/
      },

    /***/ "./node_modules/lodash/_apply.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);

            case 1:
              return func.call(thisArg, args[0]);

            case 2:
              return func.call(thisArg, args[0], args[1]);

            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }

          return func.apply(thisArg, args);
        }

        module.exports = apply;

        /***/
      },

    /***/ "./node_modules/lodash/_arrayEach.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;

          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }

          return array;
        }

        module.exports = arrayEach;

        /***/
      },

    /***/ "./node_modules/lodash/_arrayFilter.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

          while (++index < length) {
            var value = array[index];

            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }

          return result;
        }

        module.exports = arrayFilter;

        /***/
      },

    /***/ "./node_modules/lodash/_arrayLikeKeys.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseTimes = __webpack_require__(
            /*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"
          ),
          isArguments = __webpack_require__(
            /*! ./isArguments */ "./node_modules/lodash/isArguments.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isBuffer = __webpack_require__(
            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
          ),
          isIndex = __webpack_require__(
            /*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"
          ),
          isTypedArray = __webpack_require__(
            /*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */

        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

          for (var key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                (isBuff && (key == "offset" || key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                (isType &&
                  (key == "buffer" ||
                    key == "byteLength" ||
                    key == "byteOffset")) || // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = arrayLikeKeys;

        /***/
      },

    /***/ "./node_modules/lodash/_arrayMap.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }

          return result;
        }

        module.exports = arrayMap;

        /***/
      },

    /***/ "./node_modules/lodash/_arrayPush.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;

          while (++index < length) {
            array[offset + index] = values[index];
          }

          return array;
        }

        module.exports = arrayPush;

        /***/
      },

    /***/ "./node_modules/lodash/_arraySome.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;

          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }

          return false;
        }

        module.exports = arraySome;

        /***/
      },

    /***/ "./node_modules/lodash/_assignValue.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(
            /*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"
          ),
          eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function assignValue(object, key, value) {
          var objValue = object[key];

          if (
            !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }

        module.exports = assignValue;

        /***/
      },

    /***/ "./node_modules/lodash/_assocIndexOf.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */

        function assocIndexOf(array, key) {
          var length = array.length;

          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }

          return -1;
        }

        module.exports = assocIndexOf;

        /***/
      },

    /***/ "./node_modules/lodash/_baseAssign.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(
            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
          ),
          keys = __webpack_require__(
            /*! ./keys */ "./node_modules/lodash/keys.js"
          );
        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */

        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        module.exports = baseAssign;

        /***/
      },

    /***/ "./node_modules/lodash/_baseAssignIn.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(
            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
          ),
          keysIn = __webpack_require__(
            /*! ./keysIn */ "./node_modules/lodash/keysIn.js"
          );
        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */

        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        module.exports = baseAssignIn;

        /***/
      },

    /***/ "./node_modules/lodash/_baseAssignValue.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var defineProperty = __webpack_require__(
          /*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"
        );
        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            });
          } else {
            object[key] = value;
          }
        }

        module.exports = baseAssignValue;

        /***/
      },

    /***/ "./node_modules/lodash/_baseClone.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var Stack = __webpack_require__(
            /*! ./_Stack */ "./node_modules/lodash/_Stack.js"
          ),
          arrayEach = __webpack_require__(
            /*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"
          ),
          assignValue = __webpack_require__(
            /*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"
          ),
          baseAssign = __webpack_require__(
            /*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"
          ),
          baseAssignIn = __webpack_require__(
            /*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"
          ),
          cloneBuffer = __webpack_require__(
            /*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"
          ),
          copyArray = __webpack_require__(
            /*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"
          ),
          copySymbols = __webpack_require__(
            /*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"
          ),
          copySymbolsIn = __webpack_require__(
            /*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"
          ),
          getAllKeys = __webpack_require__(
            /*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"
          ),
          getAllKeysIn = __webpack_require__(
            /*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"
          ),
          getTag = __webpack_require__(
            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
          ),
          initCloneArray = __webpack_require__(
            /*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"
          ),
          initCloneByTag = __webpack_require__(
            /*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"
          ),
          initCloneObject = __webpack_require__(
            /*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isBuffer = __webpack_require__(
            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
          ),
          isMap = __webpack_require__(
            /*! ./isMap */ "./node_modules/lodash/isMap.js"
          ),
          isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          ),
          isSet = __webpack_require__(
            /*! ./isSet */ "./node_modules/lodash/isSet.js"
          ),
          keys = __webpack_require__(
            /*! ./keys */ "./node_modules/lodash/keys.js"
          );
        /** Used to compose bitmasks for cloning. */

        var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          errorTag = "[object Error]",
          funcTag = "[object Function]",
          genTag = "[object GeneratorFunction]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          objectTag = "[object Object]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          symbolTag = "[object Symbol]",
          weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]";
        /** Used to identify `toStringTag` values supported by `_.clone`. */

        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
          arrayBufferTag
        ] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[
          dateTag
        ] = cloneableTags[float32Tag] = cloneableTags[
          float64Tag
        ] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[
          int32Tag
        ] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[
          objectTag
        ] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[
          stringTag
        ] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[
          uint8ClampedTag
        ] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
          weakMapTag
        ] = false;
        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */

        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object
              ? customizer(value, key, object, stack)
              : customizer(value);
          }

          if (result !== undefined) {
            return result;
          }

          if (!isObject(value)) {
            return value;
          }

          var isArr = isArray(value);

          if (isArr) {
            result = initCloneArray(value);

            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }

            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = isFlat || isFunc ? {} : initCloneObject(value);

              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }

              result = initCloneByTag(value, tag, isDeep);
            }
          } // Check for circular references and return its corresponding clone.

          stack || (stack = new Stack());
          var stacked = stack.get(value);

          if (stacked) {
            return stacked;
          }

          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(
                baseClone(subValue, bitmask, customizer, subValue, value, stack)
              );
            });
            return result;
          }

          if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(
                key,
                baseClone(subValue, bitmask, customizer, key, value, stack)
              );
            });
            return result;
          }

          var keysFunc = isFull
            ? isFlat
              ? getAllKeysIn
              : getAllKeys
            : isFlat
            ? keysIn
            : keys;
          var props = isArr ? undefined : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            } // Recursively populate clone (susceptible to call stack limits).

            assignValue(
              result,
              key,
              baseClone(subValue, bitmask, customizer, key, value, stack)
            );
          });
          return result;
        }

        module.exports = baseClone;

        /***/
      },

    /***/ "./node_modules/lodash/_baseCreate.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(
          /*! ./isObject */ "./node_modules/lodash/isObject.js"
        );
        /** Built-in value references. */

        var objectCreate = Object.create;
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */

        var baseCreate = (function() {
          function object() {}

          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }

            if (objectCreate) {
              return objectCreate(proto);
            }

            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        })();

        module.exports = baseCreate;

        /***/
      },

    /***/ "./node_modules/lodash/_baseEach.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseForOwn = __webpack_require__(
            /*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"
          ),
          createBaseEach = __webpack_require__(
            /*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js"
          );
        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */

        var baseEach = createBaseEach(baseForOwn);
        module.exports = baseEach;

        /***/
      },

    /***/ "./node_modules/lodash/_baseFindIndex.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }

          return -1;
        }

        module.exports = baseFindIndex;

        /***/
      },

    /***/ "./node_modules/lodash/_baseFlatten.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(
            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
          ),
          isFlattenable = __webpack_require__(
            /*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js"
          );
        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */

        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];

            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }

          return result;
        }

        module.exports = baseFlatten;

        /***/
      },

    /***/ "./node_modules/lodash/_baseFor.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var createBaseFor = __webpack_require__(
          /*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js"
        );
        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */

        var baseFor = createBaseFor();
        module.exports = baseFor;

        /***/
      },

    /***/ "./node_modules/lodash/_baseForOwn.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseFor = __webpack_require__(
            /*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"
          ),
          keys = __webpack_require__(
            /*! ./keys */ "./node_modules/lodash/keys.js"
          );
        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */

        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        module.exports = baseForOwn;

        /***/
      },

    /***/ "./node_modules/lodash/_baseGet.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var castPath = __webpack_require__(
            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
          ),
          toKey = __webpack_require__(
            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
          );
        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */

        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }

          return index && index == length ? object : undefined;
        }

        module.exports = baseGet;

        /***/
      },

    /***/ "./node_modules/lodash/_baseGetAllKeys.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(
            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          );
        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */

        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object)
            ? result
            : arrayPush(result, symbolsFunc(object));
        }

        module.exports = baseGetAllKeys;

        /***/
      },

    /***/ "./node_modules/lodash/_baseGetTag.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
          ),
          getRawTag = __webpack_require__(
            /*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"
          ),
          objectToString = __webpack_require__(
            /*! ./_objectToString */ "./node_modules/lodash/_objectToString.js"
          );
        /** `Object#toString` result references. */

        var nullTag = "[object Null]",
          undefinedTag = "[object Undefined]";
        /** Built-in value references. */

        var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */

        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }

          return symToStringTag && symToStringTag in Object(value)
            ? getRawTag(value)
            : objectToString(value);
        }

        module.exports = baseGetTag;

        /***/
      },

    /***/ "./node_modules/lodash/_baseHasIn.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        module.exports = baseHasIn;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsArguments.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]";
        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */

        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        module.exports = baseIsArguments;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsEqual.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsEqualDeep = __webpack_require__(
            /*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */

        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }

          if (
            value == null ||
            other == null ||
            (!isObjectLike(value) && !isObjectLike(other))
          ) {
            return value !== value && other !== other;
          }

          return baseIsEqualDeep(
            value,
            other,
            bitmask,
            customizer,
            baseIsEqual,
            stack
          );
        }

        module.exports = baseIsEqual;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsEqualDeep.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var Stack = __webpack_require__(
            /*! ./_Stack */ "./node_modules/lodash/_Stack.js"
          ),
          equalArrays = __webpack_require__(
            /*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"
          ),
          equalByTag = __webpack_require__(
            /*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"
          ),
          equalObjects = __webpack_require__(
            /*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"
          ),
          getTag = __webpack_require__(
            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isBuffer = __webpack_require__(
            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
          ),
          isTypedArray = __webpack_require__(
            /*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"
          );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1;
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          objectTag = "[object Object]";
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */

        function baseIsEqualDeep(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }

            objIsArr = true;
            objIsObj = false;
          }

          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object)
              ? equalArrays(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                )
              : equalByTag(
                  object,
                  other,
                  objTag,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                );
          }

          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped =
                objIsObj && hasOwnProperty.call(object, "__wrapped__"),
              othIsWrapped =
                othIsObj && hasOwnProperty.call(other, "__wrapped__");

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(
                objUnwrapped,
                othUnwrapped,
                bitmask,
                customizer,
                stack
              );
            }
          }

          if (!isSameTag) {
            return false;
          }

          stack || (stack = new Stack());
          return equalObjects(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          );
        }

        module.exports = baseIsEqualDeep;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsMap.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getTag = __webpack_require__(
            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var mapTag = "[object Map]";
        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */

        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        module.exports = baseIsMap;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsMatch.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var Stack = __webpack_require__(
            /*! ./_Stack */ "./node_modules/lodash/_Stack.js"
          ),
          baseIsEqual = __webpack_require__(
            /*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"
          );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;
        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */

        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }

          object = Object(object);

          while (index--) {
            var data = matchData[index];

            if (
              noCustomizer && data[2]
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
            ) {
              return false;
            }
          }

          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();

              if (customizer) {
                var result = customizer(
                  objValue,
                  srcValue,
                  key,
                  object,
                  source,
                  stack
                );
              }

              if (
                !(result === undefined
                  ? baseIsEqual(
                      srcValue,
                      objValue,
                      COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                      customizer,
                      stack
                    )
                  : result)
              ) {
                return false;
              }
            }
          }

          return true;
        }

        module.exports = baseIsMatch;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsNative.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(
            /*! ./isFunction */ "./node_modules/lodash/isFunction.js"
          ),
          isMasked = __webpack_require__(
            /*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"
          ),
          isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          ),
          toSource = __webpack_require__(
            /*! ./_toSource */ "./node_modules/lodash/_toSource.js"
          );
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */

        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        /** Used to detect host constructors (Safari). */

        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to detect if a method is native. */

        var reIsNative = RegExp(
          "^" +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        );
        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */

        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }

          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        module.exports = baseIsNative;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsSet.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getTag = __webpack_require__(
            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var setTag = "[object Set]";
        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */

        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        module.exports = baseIsSet;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIsTypedArray.js":
      /*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          isLength = __webpack_require__(
            /*! ./isLength */ "./node_modules/lodash/isLength.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          errorTag = "[object Error]",
          funcTag = "[object Function]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          objectTag = "[object Object]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]";
        /** Used to identify `toStringTag` values of typed arrays. */

        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[
          float64Tag
        ] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[
          int32Tag
        ] = typedArrayTags[uint8Tag] = typedArrayTags[
          uint8ClampedTag
        ] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
          arrayBufferTag
        ] = typedArrayTags[boolTag] = typedArrayTags[
          dataViewTag
        ] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[
          funcTag
        ] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[
          objectTag
        ] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[
          stringTag
        ] = typedArrayTags[weakMapTag] = false;
        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */

        function baseIsTypedArray(value) {
          return (
            isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]
          );
        }

        module.exports = baseIsTypedArray;

        /***/
      },

    /***/ "./node_modules/lodash/_baseIteratee.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var baseMatches = __webpack_require__(
            /*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"
          ),
          baseMatchesProperty = __webpack_require__(
            /*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"
          ),
          identity = __webpack_require__(
            /*! ./identity */ "./node_modules/lodash/identity.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          property = __webpack_require__(
            /*! ./property */ "./node_modules/lodash/property.js"
          );
        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */

        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == "function") {
            return value;
          }

          if (value == null) {
            return identity;
          }

          if (_typeof(value) == "object") {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }

          return property(value);
        }

        module.exports = baseIteratee;

        /***/
      },

    /***/ "./node_modules/lodash/_baseKeys.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isPrototype = __webpack_require__(
            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
          ),
          nativeKeys = __webpack_require__(
            /*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }

          var result = [];

          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = baseKeys;

        /***/
      },

    /***/ "./node_modules/lodash/_baseKeysIn.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          ),
          isPrototype = __webpack_require__(
            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
          ),
          nativeKeysIn = __webpack_require__(
            /*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }

          var isProto = isPrototype(object),
            result = [];

          for (var key in object) {
            if (
              !(
                key == "constructor" &&
                (isProto || !hasOwnProperty.call(object, key))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = baseKeysIn;

        /***/
      },

    /***/ "./node_modules/lodash/_baseMap.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseEach = __webpack_require__(
            /*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"
          ),
          isArrayLike = __webpack_require__(
            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
          );
        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */

        function baseMap(collection, iteratee) {
          var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        module.exports = baseMap;

        /***/
      },

    /***/ "./node_modules/lodash/_baseMatches.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsMatch = __webpack_require__(
            /*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"
          ),
          getMatchData = __webpack_require__(
            /*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"
          ),
          matchesStrictComparable = __webpack_require__(
            /*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"
          );
        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */

        function baseMatches(source) {
          var matchData = getMatchData(source);

          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }

          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        module.exports = baseMatches;

        /***/
      },

    /***/ "./node_modules/lodash/_baseMatchesProperty.js":
      /*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsEqual = __webpack_require__(
            /*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"
          ),
          get = __webpack_require__(
            /*! ./get */ "./node_modules/lodash/get.js"
          ),
          hasIn = __webpack_require__(
            /*! ./hasIn */ "./node_modules/lodash/hasIn.js"
          ),
          isKey = __webpack_require__(
            /*! ./_isKey */ "./node_modules/lodash/_isKey.js"
          ),
          isStrictComparable = __webpack_require__(
            /*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"
          ),
          matchesStrictComparable = __webpack_require__(
            /*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"
          ),
          toKey = __webpack_require__(
            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
          );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;
        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */

        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }

          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined && objValue === srcValue
              ? hasIn(object, path)
              : baseIsEqual(
                  srcValue,
                  objValue,
                  COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                );
          };
        }

        module.exports = baseMatchesProperty;

        /***/
      },

    /***/ "./node_modules/lodash/_baseOrderBy.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayMap = __webpack_require__(
            /*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"
          ),
          baseIteratee = __webpack_require__(
            /*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"
          ),
          baseMap = __webpack_require__(
            /*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"
          ),
          baseSortBy = __webpack_require__(
            /*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"
          ),
          baseUnary = __webpack_require__(
            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
          ),
          compareMultiple = __webpack_require__(
            /*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"
          ),
          identity = __webpack_require__(
            /*! ./identity */ "./node_modules/lodash/identity.js"
          );
        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */

        function baseOrderBy(collection, iteratees, orders) {
          var index = -1;
          iteratees = arrayMap(
            iteratees.length ? iteratees : [identity],
            baseUnary(baseIteratee)
          );
          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              criteria: criteria,
              index: ++index,
              value: value,
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        module.exports = baseOrderBy;

        /***/
      },

    /***/ "./node_modules/lodash/_baseProperty.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }

        module.exports = baseProperty;

        /***/
      },

    /***/ "./node_modules/lodash/_basePropertyDeep.js":
      /*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(
          /*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"
        );
        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */

        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }

        module.exports = basePropertyDeep;

        /***/
      },

    /***/ "./node_modules/lodash/_baseRange.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
          nativeMax = Math.max;
        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */

        function baseRange(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }

          return result;
        }

        module.exports = baseRange;

        /***/
      },

    /***/ "./node_modules/lodash/_baseRest.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var identity = __webpack_require__(
            /*! ./identity */ "./node_modules/lodash/identity.js"
          ),
          overRest = __webpack_require__(
            /*! ./_overRest */ "./node_modules/lodash/_overRest.js"
          ),
          setToString = __webpack_require__(
            /*! ./_setToString */ "./node_modules/lodash/_setToString.js"
          );
        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */

        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }

        module.exports = baseRest;

        /***/
      },

    /***/ "./node_modules/lodash/_baseSetToString.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var constant = __webpack_require__(
            /*! ./constant */ "./node_modules/lodash/constant.js"
          ),
          defineProperty = __webpack_require__(
            /*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"
          ),
          identity = __webpack_require__(
            /*! ./identity */ "./node_modules/lodash/identity.js"
          );
        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var baseSetToString = !defineProperty
          ? identity
          : function(func, string) {
              return defineProperty(func, "toString", {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              });
            };
        module.exports = baseSetToString;

        /***/
      },

    /***/ "./node_modules/lodash/_baseSlice.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseSlice.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
            length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }

          end = end > length ? length : end;

          if (end < 0) {
            end += length;
          }

          length = start > end ? 0 : (end - start) >>> 0;
          start >>>= 0;
          var result = Array(length);

          while (++index < length) {
            result[index] = array[index + start];
          }

          return result;
        }

        module.exports = baseSlice;

        /***/
      },

    /***/ "./node_modules/lodash/_baseSortBy.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define the
         * sort order of `array` and replaces criteria objects with their corresponding
         * values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);

          while (length--) {
            array[length] = array[length].value;
          }

          return array;
        }

        module.exports = baseSortBy;

        /***/
      },

    /***/ "./node_modules/lodash/_baseTimes.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);

          while (++index < n) {
            result[index] = iteratee(index);
          }

          return result;
        }

        module.exports = baseTimes;

        /***/
      },

    /***/ "./node_modules/lodash/_baseToString.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
          ),
          arrayMap = __webpack_require__(
            /*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isSymbol = __webpack_require__(
            /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
          );
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /** Used to convert symbols to primitives and strings. */

        var symbolProto = _Symbol ? _Symbol.prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */

        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == "string") {
            return value;
          }

          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + "";
          }

          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = baseToString;

        /***/
      },

    /***/ "./node_modules/lodash/_baseUnary.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }

        module.exports = baseUnary;

        /***/
      },

    /***/ "./node_modules/lodash/_baseUnset.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnset.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var castPath = __webpack_require__(
            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
          ),
          last = __webpack_require__(
            /*! ./last */ "./node_modules/lodash/last.js"
          ),
          parent = __webpack_require__(
            /*! ./_parent */ "./node_modules/lodash/_parent.js"
          ),
          toKey = __webpack_require__(
            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
          );
        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */

        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        module.exports = baseUnset;

        /***/
      },

    /***/ "./node_modules/lodash/_cacheHas.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function cacheHas(cache, key) {
          return cache.has(key);
        }

        module.exports = cacheHas;

        /***/
      },

    /***/ "./node_modules/lodash/_castPath.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isKey = __webpack_require__(
            /*! ./_isKey */ "./node_modules/lodash/_isKey.js"
          ),
          stringToPath = __webpack_require__(
            /*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"
          ),
          toString = __webpack_require__(
            /*! ./toString */ "./node_modules/lodash/toString.js"
          );
        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */

        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }

          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        module.exports = castPath;

        /***/
      },

    /***/ "./node_modules/lodash/_cloneArrayBuffer.js":
      /*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var Uint8Array = __webpack_require__(
          /*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"
        );
        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */

        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        module.exports = cloneArrayBuffer;

        /***/
      },

    /***/ "./node_modules/lodash/_cloneBuffer.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(module) {
          function _typeof(obj) {
            if (
              typeof Symbol === "function" &&
              typeof Symbol.iterator === "symbol"
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          var root = __webpack_require__(
            /*! ./_root */ "./node_modules/lodash/_root.js"
          );
          /** Detect free variable `exports`. */

          var freeExports =
            (false ? undefined : _typeof(exports)) == "object" &&
            exports &&
            !exports.nodeType &&
            exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            (false ? undefined : _typeof(module)) == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */

          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }

            var length = buffer.length,
              result = allocUnsafe
                ? allocUnsafe(length)
                : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }

          module.exports = cloneBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
          )(module)
        ));

        /***/
      },

    /***/ "./node_modules/lodash/_cloneDataView.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(
          /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
        );
        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */

        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(dataView.buffer)
            : dataView.buffer;
          return new dataView.constructor(
            buffer,
            dataView.byteOffset,
            dataView.byteLength
          );
        }

        module.exports = cloneDataView;

        /***/
      },

    /***/ "./node_modules/lodash/_cloneRegExp.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/;
        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */

        function cloneRegExp(regexp) {
          var result = new regexp.constructor(
            regexp.source,
            reFlags.exec(regexp)
          );
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        module.exports = cloneRegExp;

        /***/
      },

    /***/ "./node_modules/lodash/_cloneSymbol.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
          /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
        );
        /** Used to convert symbols to primitives and strings. */

        var symbolProto = _Symbol ? _Symbol.prototype : undefined,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */

        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        module.exports = cloneSymbol;

        /***/
      },

    /***/ "./node_modules/lodash/_cloneTypedArray.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(
          /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
        );
        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */

        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(typedArray.buffer)
            : typedArray.buffer;
          return new typedArray.constructor(
            buffer,
            typedArray.byteOffset,
            typedArray.length
          );
        }

        module.exports = cloneTypedArray;

        /***/
      },

    /***/ "./node_modules/lodash/_compareAscending.js":
      /*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(
          /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
        );
        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */

        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);

            if (
              (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
              (valIsSymbol &&
                othIsDefined &&
                othIsReflexive &&
                !othIsNull &&
                !othIsSymbol) ||
              (valIsNull && othIsDefined && othIsReflexive) ||
              (!valIsDefined && othIsReflexive) ||
              !valIsReflexive
            ) {
              return 1;
            }

            if (
              (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
              (othIsSymbol &&
                valIsDefined &&
                valIsReflexive &&
                !valIsNull &&
                !valIsSymbol) ||
              (othIsNull && valIsDefined && valIsReflexive) ||
              (!othIsDefined && valIsReflexive) ||
              !othIsReflexive
            ) {
              return -1;
            }
          }

          return 0;
        }

        module.exports = compareAscending;

        /***/
      },

    /***/ "./node_modules/lodash/_compareMultiple.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var compareAscending = __webpack_require__(
          /*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js"
        );
        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */

        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(
              objCriteria[index],
              othCriteria[index]
            );

            if (result) {
              if (index >= ordersLength) {
                return result;
              }

              var order = orders[index];
              return result * (order == "desc" ? -1 : 1);
            }
          } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.

          return object.index - other.index;
        }

        module.exports = compareMultiple;

        /***/
      },

    /***/ "./node_modules/lodash/_copyArray.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));

          while (++index < length) {
            array[index] = source[index];
          }

          return array;
        }

        module.exports = copyArray;

        /***/
      },

    /***/ "./node_modules/lodash/_copyObject.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(
            /*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"
          ),
          baseAssignValue = __webpack_require__(
            /*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"
          );
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */

        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;

          while (++index < length) {
            var key = props[index];
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined;

            if (newValue === undefined) {
              newValue = source[key];
            }

            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }

          return object;
        }

        module.exports = copyObject;

        /***/
      },

    /***/ "./node_modules/lodash/_copySymbols.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(
            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
          ),
          getSymbols = __webpack_require__(
            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
          );
        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */

        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        module.exports = copySymbols;

        /***/
      },

    /***/ "./node_modules/lodash/_copySymbolsIn.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(
            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
          ),
          getSymbolsIn = __webpack_require__(
            /*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"
          );
        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */

        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        module.exports = copySymbolsIn;

        /***/
      },

    /***/ "./node_modules/lodash/_coreJsData.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var root = __webpack_require__(
          /*! ./_root */ "./node_modules/lodash/_root.js"
        );
        /** Used to detect overreaching core-js shims. */

        var coreJsData = root["__core-js_shared__"];
        module.exports = coreJsData;

        /***/
      },

    /***/ "./node_modules/lodash/_createBaseEach.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isArrayLike = __webpack_require__(
          /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
        );
        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */

        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }

            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }

            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);

            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }

            return collection;
          };
        }

        module.exports = createBaseEach;

        /***/
      },

    /***/ "./node_modules/lodash/_createBaseFor.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];

              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }

            return object;
          };
        }

        module.exports = createBaseFor;

        /***/
      },

    /***/ "./node_modules/lodash/_createRange.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseRange = __webpack_require__(
            /*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"
          ),
          isIterateeCall = __webpack_require__(
            /*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"
          ),
          toFinite = __webpack_require__(
            /*! ./toFinite */ "./node_modules/lodash/toFinite.js"
          );
        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */

        function createRange(fromRight) {
          return function(start, end, step) {
            if (
              step &&
              typeof step != "number" &&
              isIterateeCall(start, end, step)
            ) {
              end = step = undefined;
            } // Ensure the sign of `-0` is preserved.

            start = toFinite(start);

            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }

            step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        module.exports = createRange;

        /***/
      },

    /***/ "./node_modules/lodash/_customOmitClone.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_customOmitClone.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isPlainObject = __webpack_require__(
          /*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"
        );
        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */

        function customOmitClone(value) {
          return isPlainObject(value) ? undefined : value;
        }

        module.exports = customOmitClone;

        /***/
      },

    /***/ "./node_modules/lodash/_defineProperty.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
          /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
        );

        var defineProperty = (function() {
          try {
            var func = getNative(Object, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {}
        })();

        module.exports = defineProperty;

        /***/
      },

    /***/ "./node_modules/lodash/_equalArrays.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var SetCache = __webpack_require__(
            /*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"
          ),
          arraySome = __webpack_require__(
            /*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"
          ),
          cacheHas = __webpack_require__(
            /*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"
          );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;
        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */

        function equalArrays(
          array,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          } // Assume cyclic values are equal.

          var stacked = stack.get(array);

          if (stacked && stack.get(other)) {
            return stacked == other;
          }

          var index = -1,
            result = true,
            seen =
              bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
          stack.set(array, other);
          stack.set(other, array); // Ignore non-index properties.

          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }

            if (compared !== undefined) {
              if (compared) {
                continue;
              }

              result = false;
              break;
            } // Recursively compare arrays (susceptible to call stack limits).

            if (seen) {
              if (
                !arraySome(other, function(othValue, othIndex) {
                  if (
                    !cacheHas(seen, othIndex) &&
                    (arrValue === othValue ||
                      equalFunc(arrValue, othValue, bitmask, customizer, stack))
                  ) {
                    return seen.push(othIndex);
                  }
                })
              ) {
                result = false;
                break;
              }
            } else if (
              !(
                arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
              )
            ) {
              result = false;
              break;
            }
          }

          stack["delete"](array);
          stack["delete"](other);
          return result;
        }

        module.exports = equalArrays;

        /***/
      },

    /***/ "./node_modules/lodash/_equalByTag.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
          ),
          Uint8Array = __webpack_require__(
            /*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"
          ),
          eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
          equalArrays = __webpack_require__(
            /*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"
          ),
          mapToArray = __webpack_require__(
            /*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"
          ),
          setToArray = __webpack_require__(
            /*! ./_setToArray */ "./node_modules/lodash/_setToArray.js"
          );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;
        /** `Object#toString` result references. */

        var boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          errorTag = "[object Error]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          symbolTag = "[object Symbol]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]";
        /** Used to convert symbols to primitives and strings. */

        var symbolProto = _Symbol ? _Symbol.prototype : undefined,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */

        function equalByTag(
          object,
          other,
          tag,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          switch (tag) {
            case dataViewTag:
              if (
                object.byteLength != other.byteLength ||
                object.byteOffset != other.byteOffset
              ) {
                return false;
              }

              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if (
                object.byteLength != other.byteLength ||
                !equalFunc(new Uint8Array(object), new Uint8Array(other))
              ) {
                return false;
              }

              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return (
                object.name == other.name && object.message == other.message
              );

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + "";

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              } // Assume cyclic values are equal.

              var stacked = stack.get(object);

              if (stacked) {
                return stacked == other;
              }

              bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

              stack.set(object, other);
              var result = equalArrays(
                convert(object),
                convert(other),
                bitmask,
                customizer,
                equalFunc,
                stack
              );
              stack["delete"](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }

          return false;
        }

        module.exports = equalByTag;

        /***/
      },

    /***/ "./node_modules/lodash/_equalObjects.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getAllKeys = __webpack_require__(
          /*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"
        );
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1;
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */

        function equalObjects(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }

          var index = objLength;

          while (index--) {
            var key = objProps[index];

            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          } // Assume cyclic values are equal.

          var stacked = stack.get(object);

          if (stacked && stack.get(other)) {
            return stacked == other;
          }

          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;

          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            } // Recursively compare objects (susceptible to call stack limits).

            if (
              !(compared === undefined
                ? objValue === othValue ||
                  equalFunc(objValue, othValue, bitmask, customizer, stack)
                : compared)
            ) {
              result = false;
              break;
            }

            skipCtor || (skipCtor = key == "constructor");
          }

          if (result && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

            if (
              objCtor != othCtor &&
              "constructor" in object &&
              "constructor" in other &&
              !(
                typeof objCtor == "function" &&
                objCtor instanceof objCtor &&
                typeof othCtor == "function" &&
                othCtor instanceof othCtor
              )
            ) {
              result = false;
            }
          }

          stack["delete"](object);
          stack["delete"](other);
          return result;
        }

        module.exports = equalObjects;

        /***/
      },

    /***/ "./node_modules/lodash/_flatRest.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var flatten = __webpack_require__(
            /*! ./flatten */ "./node_modules/lodash/flatten.js"
          ),
          overRest = __webpack_require__(
            /*! ./_overRest */ "./node_modules/lodash/_overRest.js"
          ),
          setToString = __webpack_require__(
            /*! ./_setToString */ "./node_modules/lodash/_setToString.js"
          );
        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */

        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + "");
        }

        module.exports = flatRest;

        /***/
      },

    /***/ "./node_modules/lodash/_freeGlobal.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(global) {
          function _typeof(obj) {
            if (
              typeof Symbol === "function" &&
              typeof Symbol.iterator === "symbol"
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          /** Detect free variable `global` from Node.js. */
          var freeGlobal =
            (typeof global === "undefined" ? "undefined" : _typeof(global)) ==
              "object" &&
            global &&
            global.Object === Object &&
            global;
          module.exports = freeGlobal;
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
          )
        ));

        /***/
      },

    /***/ "./node_modules/lodash/_getAllKeys.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetAllKeys = __webpack_require__(
            /*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"
          ),
          getSymbols = __webpack_require__(
            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
          ),
          keys = __webpack_require__(
            /*! ./keys */ "./node_modules/lodash/keys.js"
          );
        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */

        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        module.exports = getAllKeys;

        /***/
      },

    /***/ "./node_modules/lodash/_getAllKeysIn.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetAllKeys = __webpack_require__(
            /*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"
          ),
          getSymbolsIn = __webpack_require__(
            /*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"
          ),
          keysIn = __webpack_require__(
            /*! ./keysIn */ "./node_modules/lodash/keysIn.js"
          );
        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */

        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        module.exports = getAllKeysIn;

        /***/
      },

    /***/ "./node_modules/lodash/_getMapData.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isKeyable = __webpack_require__(
          /*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js"
        );
        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */

        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == "string" ? "string" : "hash"]
            : data.map;
        }

        module.exports = getMapData;

        /***/
      },

    /***/ "./node_modules/lodash/_getMatchData.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isStrictComparable = __webpack_require__(
            /*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"
          ),
          keys = __webpack_require__(
            /*! ./keys */ "./node_modules/lodash/keys.js"
          );
        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */

        function getMatchData(object) {
          var result = keys(object),
            length = result.length;

          while (length--) {
            var key = result[length],
              value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }

          return result;
        }

        module.exports = getMatchData;

        /***/
      },

    /***/ "./node_modules/lodash/_getNative.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsNative = __webpack_require__(
            /*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"
          ),
          getValue = __webpack_require__(
            /*! ./_getValue */ "./node_modules/lodash/_getValue.js"
          );
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */

        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        module.exports = getNative;

        /***/
      },

    /***/ "./node_modules/lodash/_getPrototype.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var overArg = __webpack_require__(
          /*! ./_overArg */ "./node_modules/lodash/_overArg.js"
        );
        /** Built-in value references. */

        var getPrototype = overArg(Object.getPrototypeOf, Object);
        module.exports = getPrototype;

        /***/
      },

    /***/ "./node_modules/lodash/_getRawTag.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
          /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
        );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /** Built-in value references. */

        var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */

        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);

          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }

          return result;
        }

        module.exports = getRawTag;

        /***/
      },

    /***/ "./node_modules/lodash/_getSymbols.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayFilter = __webpack_require__(
            /*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"
          ),
          stubArray = __webpack_require__(
            /*! ./stubArray */ "./node_modules/lodash/stubArray.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Built-in value references. */

        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeGetSymbols = Object.getOwnPropertySymbols;
        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */

        var getSymbols = !nativeGetSymbols
          ? stubArray
          : function(object) {
              if (object == null) {
                return [];
              }

              object = Object(object);
              return arrayFilter(nativeGetSymbols(object), function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
              });
            };
        module.exports = getSymbols;

        /***/
      },

    /***/ "./node_modules/lodash/_getSymbolsIn.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(
            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
          ),
          getPrototype = __webpack_require__(
            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
          ),
          getSymbols = __webpack_require__(
            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
          ),
          stubArray = __webpack_require__(
            /*! ./stubArray */ "./node_modules/lodash/stubArray.js"
          );
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeGetSymbols = Object.getOwnPropertySymbols;
        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */

        var getSymbolsIn = !nativeGetSymbols
          ? stubArray
          : function(object) {
              var result = [];

              while (object) {
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
              }

              return result;
            };
        module.exports = getSymbolsIn;

        /***/
      },

    /***/ "./node_modules/lodash/_getTag.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var DataView = __webpack_require__(
            /*! ./_DataView */ "./node_modules/lodash/_DataView.js"
          ),
          Map = __webpack_require__(
            /*! ./_Map */ "./node_modules/lodash/_Map.js"
          ),
          Promise = __webpack_require__(
            /*! ./_Promise */ "./node_modules/lodash/_Promise.js"
          ),
          Set = __webpack_require__(
            /*! ./_Set */ "./node_modules/lodash/_Set.js"
          ),
          WeakMap = __webpack_require__(
            /*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"
          ),
          baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          toSource = __webpack_require__(
            /*! ./_toSource */ "./node_modules/lodash/_toSource.js"
          );
        /** `Object#toString` result references. */

        var mapTag = "[object Map]",
          objectTag = "[object Object]",
          promiseTag = "[object Promise]",
          setTag = "[object Set]",
          weakMapTag = "[object WeakMap]";
        var dataViewTag = "[object DataView]";
        /** Used to detect maps, sets, and weakmaps. */

        var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);
        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */

        var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

        if (
          (DataView &&
            getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
          (Map && getTag(new Map()) != mapTag) ||
          (Promise && getTag(Promise.resolve()) != promiseTag) ||
          (Set && getTag(new Set()) != setTag) ||
          (WeakMap && getTag(new WeakMap()) != weakMapTag)
        ) {
          getTag = function getTag(value) {
            var result = baseGetTag(value),
              Ctor = result == objectTag ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : "";

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;

                case mapCtorString:
                  return mapTag;

                case promiseCtorString:
                  return promiseTag;

                case setCtorString:
                  return setTag;

                case weakMapCtorString:
                  return weakMapTag;
              }
            }

            return result;
          };
        }

        module.exports = getTag;

        /***/
      },

    /***/ "./node_modules/lodash/_getValue.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        module.exports = getValue;

        /***/
      },

    /***/ "./node_modules/lodash/_hasPath.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var castPath = __webpack_require__(
            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
          ),
          isArguments = __webpack_require__(
            /*! ./isArguments */ "./node_modules/lodash/isArguments.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isIndex = __webpack_require__(
            /*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"
          ),
          isLength = __webpack_require__(
            /*! ./isLength */ "./node_modules/lodash/isLength.js"
          ),
          toKey = __webpack_require__(
            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
          );
        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */

        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result = false;

          while (++index < length) {
            var key = toKey(path[index]);

            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }

            object = object[key];
          }

          if (result || ++index != length) {
            return result;
          }

          length = object == null ? 0 : object.length;
          return (
            !!length &&
            isLength(length) &&
            isIndex(key, length) &&
            (isArray(object) || isArguments(object))
          );
        }

        module.exports = hasPath;

        /***/
      },

    /***/ "./node_modules/lodash/_hashClear.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(
          /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
        );
        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */

        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        module.exports = hashClear;

        /***/
      },

    /***/ "./node_modules/lodash/_hashDelete.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = hashDelete;

        /***/
      },

    /***/ "./node_modules/lodash/_hashGet.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(
          /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
        );
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function hashGet(key) {
          var data = this.__data__;

          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }

          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }

        module.exports = hashGet;

        /***/
      },

    /***/ "./node_modules/lodash/_hashHas.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(
          /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
        );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate
            ? data[key] !== undefined
            : hasOwnProperty.call(data, key);
        }

        module.exports = hashHas;

        /***/
      },

    /***/ "./node_modules/lodash/_hashSet.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(
          /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
        );
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */

        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] =
            nativeCreate && value === undefined ? HASH_UNDEFINED : value;
          return this;
        }

        module.exports = hashSet;

        /***/
      },

    /***/ "./node_modules/lodash/_initCloneArray.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */

        function initCloneArray(array) {
          var length = array.length,
            result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

          if (
            length &&
            typeof array[0] == "string" &&
            hasOwnProperty.call(array, "index")
          ) {
            result.index = array.index;
            result.input = array.input;
          }

          return result;
        }

        module.exports = initCloneArray;

        /***/
      },

    /***/ "./node_modules/lodash/_initCloneByTag.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(
            /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
          ),
          cloneDataView = __webpack_require__(
            /*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"
          ),
          cloneRegExp = __webpack_require__(
            /*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"
          ),
          cloneSymbol = __webpack_require__(
            /*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"
          ),
          cloneTypedArray = __webpack_require__(
            /*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"
          );
        /** `Object#toString` result references. */

        var boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          symbolTag = "[object Symbol]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]";
        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */

        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;

          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor();

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor();

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        module.exports = initCloneByTag;

        /***/
      },

    /***/ "./node_modules/lodash/_initCloneObject.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseCreate = __webpack_require__(
            /*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"
          ),
          getPrototype = __webpack_require__(
            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
          ),
          isPrototype = __webpack_require__(
            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
          );
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */

        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {};
        }

        module.exports = initCloneObject;

        /***/
      },

    /***/ "./node_modules/lodash/_isFlattenable.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var _Symbol = __webpack_require__(
            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
          ),
          isArguments = __webpack_require__(
            /*! ./isArguments */ "./node_modules/lodash/isArguments.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          );
        /** Built-in value references. */

        var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */

        function isFlattenable(value) {
          return (
            isArray(value) ||
            isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol])
          );
        }

        module.exports = isFlattenable;

        /***/
      },

    /***/ "./node_modules/lodash/_isIndex.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /** Used to detect unsigned integer values. */

        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */

        function isIndex(value, length) {
          var type = _typeof(value);

          length = length == null ? MAX_SAFE_INTEGER : length;
          return (
            !!length &&
            (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          );
        }

        module.exports = isIndex;

        /***/
      },

    /***/ "./node_modules/lodash/_isIterateeCall.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
          isArrayLike = __webpack_require__(
            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
          ),
          isIndex = __webpack_require__(
            /*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"
          ),
          isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          );
        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */

        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }

          var type = _typeof(index);

          if (
            type == "number"
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == "string" && index in object
          ) {
            return eq(object[index], value);
          }

          return false;
        }

        module.exports = isIterateeCall;

        /***/
      },

    /***/ "./node_modules/lodash/_isKey.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isSymbol = __webpack_require__(
            /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
          );
        /** Used to match property names within property paths. */

        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/;
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */

        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }

          var type = _typeof(value);

          if (
            type == "number" ||
            type == "symbol" ||
            type == "boolean" ||
            value == null ||
            isSymbol(value)
          ) {
            return true;
          }

          return (
            reIsPlainProp.test(value) ||
            !reIsDeepProp.test(value) ||
            (object != null && value in Object(object))
          );
        }

        module.exports = isKey;

        /***/
      },

    /***/ "./node_modules/lodash/_isKeyable.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = _typeof(value);

          return type == "string" ||
            type == "number" ||
            type == "symbol" ||
            type == "boolean"
            ? value !== "__proto__"
            : value === null;
        }

        module.exports = isKeyable;

        /***/
      },

    /***/ "./node_modules/lodash/_isMasked.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var coreJsData = __webpack_require__(
          /*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js"
        );
        /** Used to detect methods masquerading as native. */

        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(
            (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
          );
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */

        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        module.exports = isMasked;

        /***/
      },

    /***/ "./node_modules/lodash/_isPrototype.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */

        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto =
              (typeof Ctor == "function" && Ctor.prototype) || objectProto;
          return value === proto;
        }

        module.exports = isPrototype;

        /***/
      },

    /***/ "./node_modules/lodash/_isStrictComparable.js":
      /*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(
          /*! ./isObject */ "./node_modules/lodash/isObject.js"
        );
        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */

        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        module.exports = isStrictComparable;

        /***/
      },

    /***/ "./node_modules/lodash/_listCacheClear.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        module.exports = listCacheClear;

        /***/
      },

    /***/ "./node_modules/lodash/_listCacheDelete.js":
      /*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(
          /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
        );
        /** Used for built-in method references. */

        var arrayProto = Array.prototype;
        /** Built-in value references. */

        var splice = arrayProto.splice;
        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }

          var lastIndex = data.length - 1;

          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }

          --this.size;
          return true;
        }

        module.exports = listCacheDelete;

        /***/
      },

    /***/ "./node_modules/lodash/_listCacheGet.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(
          /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
        );
        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }

        module.exports = listCacheGet;

        /***/
      },

    /***/ "./node_modules/lodash/_listCacheHas.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(
          /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
        );
        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        module.exports = listCacheHas;

        /***/
      },

    /***/ "./node_modules/lodash/_listCacheSet.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(
          /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
        );
        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */

        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }

          return this;
        }

        module.exports = listCacheSet;

        /***/
      },

    /***/ "./node_modules/lodash/_mapCacheClear.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var Hash = __webpack_require__(
            /*! ./_Hash */ "./node_modules/lodash/_Hash.js"
          ),
          ListCache = __webpack_require__(
            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
          ),
          Map = __webpack_require__(
            /*! ./_Map */ "./node_modules/lodash/_Map.js"
          );
        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */

        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash(),
          };
        }

        module.exports = mapCacheClear;

        /***/
      },

    /***/ "./node_modules/lodash/_mapCacheDelete.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(
          /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
        );
        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function mapCacheDelete(key) {
          var result = getMapData(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = mapCacheDelete;

        /***/
      },

    /***/ "./node_modules/lodash/_mapCacheGet.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(
          /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
        );
        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        module.exports = mapCacheGet;

        /***/
      },

    /***/ "./node_modules/lodash/_mapCacheHas.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(
          /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
        );
        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        module.exports = mapCacheHas;

        /***/
      },

    /***/ "./node_modules/lodash/_mapCacheSet.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(
          /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
        );
        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */

        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        module.exports = mapCacheSet;

        /***/
      },

    /***/ "./node_modules/lodash/_mapToArray.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */
        function mapToArray(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }

        module.exports = mapToArray;

        /***/
      },

    /***/ "./node_modules/lodash/_matchesStrictComparable.js":
      /*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }

            return (
              object[key] === srcValue &&
              (srcValue !== undefined || key in Object(object))
            );
          };
        }

        module.exports = matchesStrictComparable;

        /***/
      },

    /***/ "./node_modules/lodash/_memoizeCapped.js":
      /*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var memoize = __webpack_require__(
          /*! ./memoize */ "./node_modules/lodash/memoize.js"
        );
        /** Used as the maximum memoize cache size. */

        var MAX_MEMOIZE_SIZE = 500;
        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */

        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }

            return key;
          });
          var cache = result.cache;
          return result;
        }

        module.exports = memoizeCapped;

        /***/
      },

    /***/ "./node_modules/lodash/_nativeCreate.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var getNative = __webpack_require__(
          /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
        );
        /* Built-in method references that are verified to be native. */

        var nativeCreate = getNative(Object, "create");
        module.exports = nativeCreate;

        /***/
      },

    /***/ "./node_modules/lodash/_nativeKeys.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var overArg = __webpack_require__(
          /*! ./_overArg */ "./node_modules/lodash/_overArg.js"
        );
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeKeys = overArg(Object.keys, Object);
        module.exports = nativeKeys;

        /***/
      },

    /***/ "./node_modules/lodash/_nativeKeysIn.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];

          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = nativeKeysIn;

        /***/
      },

    /***/ "./node_modules/lodash/_nodeUtil.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(module) {
          function _typeof(obj) {
            if (
              typeof Symbol === "function" &&
              typeof Symbol.iterator === "symbol"
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          var freeGlobal = __webpack_require__(
            /*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js"
          );
          /** Detect free variable `exports`. */

          var freeExports =
            (false ? undefined : _typeof(exports)) == "object" &&
            exports &&
            !exports.nodeType &&
            exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            (false ? undefined : _typeof(module)) == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Detect free variable `process` from Node.js. */

          var freeProcess = moduleExports && freeGlobal.process;
          /** Used to access faster Node.js helpers. */

          var nodeUtil = (function() {
            try {
              // Use `util.types` for Node.js 10+.
              var types =
                freeModule &&
                freeModule.require &&
                freeModule.require("util").types;

              if (types) {
                return types;
              } // Legacy `process.binding('util')` for Node.js < 10.

              return (
                freeProcess &&
                freeProcess.binding &&
                freeProcess.binding("util")
              );
            } catch (e) {}
          })();

          module.exports = nodeUtil;
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
          )(module)
        ));

        /***/
      },

    /***/ "./node_modules/lodash/_objectToString.js":
      /*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */

        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        module.exports = objectToString;

        /***/
      },

    /***/ "./node_modules/lodash/_overArg.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }

        module.exports = overArg;

        /***/
      },

    /***/ "./node_modules/lodash/_overRest.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var apply = __webpack_require__(
          /*! ./_apply */ "./node_modules/lodash/_apply.js"
        );
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeMax = Math.max;
        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */

        function overRest(func, start, transform) {
          start = nativeMax(start === undefined ? func.length - 1 : start, 0);
          return function() {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }

            index = -1;
            var otherArgs = Array(start + 1);

            while (++index < start) {
              otherArgs[index] = args[index];
            }

            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        module.exports = overRest;

        /***/
      },

    /***/ "./node_modules/lodash/_parent.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/_parent.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(
            /*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"
          ),
          baseSlice = __webpack_require__(
            /*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js"
          );
        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */

        function parent(object, path) {
          return path.length < 2
            ? object
            : baseGet(object, baseSlice(path, 0, -1));
        }

        module.exports = parent;

        /***/
      },

    /***/ "./node_modules/lodash/_root.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var freeGlobal = __webpack_require__(
          /*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js"
        );
        /** Detect free variable `self`. */

        var freeSelf =
          (typeof self === "undefined" ? "undefined" : _typeof(self)) ==
            "object" &&
          self &&
          self.Object === Object &&
          self;
        /** Used as a reference to the global object. */

        var root = freeGlobal || freeSelf || Function("return this")();
        module.exports = root;

        /***/
      },

    /***/ "./node_modules/lodash/_setCacheAdd.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */

        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);

          return this;
        }

        module.exports = setCacheAdd;

        /***/
      },

    /***/ "./node_modules/lodash/_setCacheHas.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        module.exports = setCacheHas;

        /***/
      },

    /***/ "./node_modules/lodash/_setToArray.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */
        function setToArray(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }

        module.exports = setToArray;

        /***/
      },

    /***/ "./node_modules/lodash/_setToString.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseSetToString = __webpack_require__(
            /*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"
          ),
          shortOut = __webpack_require__(
            /*! ./_shortOut */ "./node_modules/lodash/_shortOut.js"
          );
        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var setToString = shortOut(baseSetToString);
        module.exports = setToString;

        /***/
      },

    /***/ "./node_modules/lodash/_shortOut.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeNow = Date.now;
        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */

        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function() {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;

            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }

            return func.apply(undefined, arguments);
          };
        }

        module.exports = shortOut;

        /***/
      },

    /***/ "./node_modules/lodash/_stackClear.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(
          /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
        );
        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */

        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        module.exports = stackClear;

        /***/
      },

    /***/ "./node_modules/lodash/_stackDelete.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
            result = data["delete"](key);
          this.size = data.size;
          return result;
        }

        module.exports = stackDelete;

        /***/
      },

    /***/ "./node_modules/lodash/_stackGet.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        module.exports = stackGet;

        /***/
      },

    /***/ "./node_modules/lodash/_stackHas.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        module.exports = stackHas;

        /***/
      },

    /***/ "./node_modules/lodash/_stackSet.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(
            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
          ),
          Map = __webpack_require__(
            /*! ./_Map */ "./node_modules/lodash/_Map.js"
          ),
          MapCache = __webpack_require__(
            /*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"
          );
        /** Used as the size to enable large array optimizations. */

        var LARGE_ARRAY_SIZE = 200;
        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */

        function stackSet(key, value) {
          var data = this.__data__;

          if (data instanceof ListCache) {
            var pairs = data.__data__;

            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }

            data = this.__data__ = new MapCache(pairs);
          }

          data.set(key, value);
          this.size = data.size;
          return this;
        }

        module.exports = stackSet;

        /***/
      },

    /***/ "./node_modules/lodash/_stringToPath.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var memoizeCapped = __webpack_require__(
          /*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js"
        );
        /** Used to match property names within property paths. */

        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        /** Used to match backslashes in property paths. */

        var reEscapeChar = /\\(\\)?/g;
        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */

        var stringToPath = memoizeCapped(function(string) {
          var result = [];

          if (
            string.charCodeAt(0) === 46
            /* . */
          ) {
            result.push("");
          }

          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(
              quote ? subString.replace(reEscapeChar, "$1") : number || match
            );
          });
          return result;
        });
        module.exports = stringToPath;

        /***/
      },

    /***/ "./node_modules/lodash/_toKey.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(
          /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
        );
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */

        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = toKey;

        /***/
      },

    /***/ "./node_modules/lodash/_toSource.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used for built-in method references. */
        var funcProto = Function.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */

        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}

            try {
              return func + "";
            } catch (e) {}
          }

          return "";
        }

        module.exports = toSource;

        /***/
      },

    /***/ "./node_modules/lodash/chunk.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/chunk.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseSlice = __webpack_require__(
            /*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js"
          ),
          isIterateeCall = __webpack_require__(
            /*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"
          ),
          toInteger = __webpack_require__(
            /*! ./toInteger */ "./node_modules/lodash/toInteger.js"
          );
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeCeil = Math.ceil,
          nativeMax = Math.max;
        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */

        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }

          var length = array == null ? 0 : array.length;

          if (!length || size < 1) {
            return [];
          }

          var index = 0,
            resIndex = 0,
            result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }

          return result;
        }

        module.exports = chunk;

        /***/
      },

    /***/ "./node_modules/lodash/constant.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        module.exports = constant;

        /***/
      },

    /***/ "./node_modules/lodash/defaults.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseRest = __webpack_require__(
            /*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"
          ),
          eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
          isIterateeCall = __webpack_require__(
            /*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"
          ),
          keysIn = __webpack_require__(
            /*! ./keysIn */ "./node_modules/lodash/keysIn.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */

        var defaults = baseRest(function(object, sources) {
          object = Object(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (
                value === undefined ||
                (eq(value, objectProto[key]) &&
                  !hasOwnProperty.call(object, key))
              ) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });
        module.exports = defaults;

        /***/
      },

    /***/ "./node_modules/lodash/eq.js":
      /*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        module.exports = eq;

        /***/
      },

    /***/ "./node_modules/lodash/findIndex.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseFindIndex = __webpack_require__(
            /*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"
          ),
          baseIteratee = __webpack_require__(
            /*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"
          ),
          toInteger = __webpack_require__(
            /*! ./toInteger */ "./node_modules/lodash/toInteger.js"
          );
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeMax = Math.max;
        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */

        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;

          if (!length) {
            return -1;
          }

          var index = fromIndex == null ? 0 : toInteger(fromIndex);

          if (index < 0) {
            index = nativeMax(length + index, 0);
          }

          return baseFindIndex(array, baseIteratee(predicate, 3), index);
        }

        module.exports = findIndex;

        /***/
      },

    /***/ "./node_modules/lodash/flatten.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(
          /*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"
        );
        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */

        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        module.exports = flatten;

        /***/
      },

    /***/ "./node_modules/lodash/get.js":
      /*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(
          /*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"
        );
        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */

        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, path);
          return result === undefined ? defaultValue : result;
        }

        module.exports = get;

        /***/
      },

    /***/ "./node_modules/lodash/hasIn.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseHasIn = __webpack_require__(
            /*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"
          ),
          hasPath = __webpack_require__(
            /*! ./_hasPath */ "./node_modules/lodash/_hasPath.js"
          );
        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */

        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        module.exports = hasIn;

        /***/
      },

    /***/ "./node_modules/lodash/identity.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        module.exports = identity;

        /***/
      },

    /***/ "./node_modules/lodash/isArguments.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsArguments = __webpack_require__(
            /*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Built-in value references. */

        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */

        var isArguments = baseIsArguments(
          (function() {
            return arguments;
          })()
        )
          ? baseIsArguments
          : function(value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, "callee") &&
                !propertyIsEnumerable.call(value, "callee")
              );
            };
        module.exports = isArguments;

        /***/
      },

    /***/ "./node_modules/lodash/isArray.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
        module.exports = isArray;

        /***/
      },

    /***/ "./node_modules/lodash/isArrayLike.js":
      /*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(
            /*! ./isFunction */ "./node_modules/lodash/isFunction.js"
          ),
          isLength = __webpack_require__(
            /*! ./isLength */ "./node_modules/lodash/isLength.js"
          );
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */

        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        module.exports = isArrayLike;

        /***/
      },

    /***/ "./node_modules/lodash/isBuffer.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(module) {
          function _typeof(obj) {
            if (
              typeof Symbol === "function" &&
              typeof Symbol.iterator === "symbol"
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          var root = __webpack_require__(
              /*! ./_root */ "./node_modules/lodash/_root.js"
            ),
            stubFalse = __webpack_require__(
              /*! ./stubFalse */ "./node_modules/lodash/stubFalse.js"
            );
          /** Detect free variable `exports`. */

          var freeExports =
            (false ? undefined : _typeof(exports)) == "object" &&
            exports &&
            !exports.nodeType &&
            exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            (false ? undefined : _typeof(module)) == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined;
          /* Built-in method references for those with the same name as other `lodash` methods. */

          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */

          var isBuffer = nativeIsBuffer || stubFalse;
          module.exports = isBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
          )(module)
        ));

        /***/
      },

    /***/ "./node_modules/lodash/isFunction.js":
      /*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          );
        /** `Object#toString` result references. */

        var asyncTag = "[object AsyncFunction]",
          funcTag = "[object Function]",
          genTag = "[object GeneratorFunction]",
          proxyTag = "[object Proxy]";
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */

        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          } // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.

          var tag = baseGetTag(value);
          return (
            tag == funcTag ||
            tag == genTag ||
            tag == asyncTag ||
            tag == proxyTag
          );
        }

        module.exports = isFunction;

        /***/
      },

    /***/ "./node_modules/lodash/isLength.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */

        function isLength(value) {
          return (
            typeof value == "number" &&
            value > -1 &&
            value % 1 == 0 &&
            value <= MAX_SAFE_INTEGER
          );
        }

        module.exports = isLength;

        /***/
      },

    /***/ "./node_modules/lodash/isMap.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsMap = __webpack_require__(
            /*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"
          ),
          baseUnary = __webpack_require__(
            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
          ),
          nodeUtil = __webpack_require__(
            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
          );
        /* Node.js helper references. */

        var nodeIsMap = nodeUtil && nodeUtil.isMap;
        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */

        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        module.exports = isMap;

        /***/
      },

    /***/ "./node_modules/lodash/isObject.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = _typeof(value);

          return value != null && (type == "object" || type == "function");
        }

        module.exports = isObject;

        /***/
      },

    /***/ "./node_modules/lodash/isObjectLike.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && _typeof(value) == "object";
        }

        module.exports = isObjectLike;

        /***/
      },

    /***/ "./node_modules/lodash/isPlainObject.js":
      /*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          getPrototype = __webpack_require__(
            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var objectTag = "[object Object]";
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to infer the `Object` constructor. */

        var objectCtorString = funcToString.call(Object);
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */

        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }

          var proto = getPrototype(value);

          if (proto === null) {
            return true;
          }

          var Ctor =
            hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return (
            typeof Ctor == "function" &&
            Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString
          );
        }

        module.exports = isPlainObject;

        /***/
      },

    /***/ "./node_modules/lodash/isSet.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsSet = __webpack_require__(
            /*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"
          ),
          baseUnary = __webpack_require__(
            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
          ),
          nodeUtil = __webpack_require__(
            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
          );
        /* Node.js helper references. */

        var nodeIsSet = nodeUtil && nodeUtil.isSet;
        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */

        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        module.exports = isSet;

        /***/
      },

    /***/ "./node_modules/lodash/isSymbol.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var baseGetTag = __webpack_require__(
            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
          ),
          isObjectLike = __webpack_require__(
            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
          );
        /** `Object#toString` result references. */

        var symbolTag = "[object Symbol]";
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */

        function isSymbol(value) {
          return (
            _typeof(value) == "symbol" ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag)
          );
        }

        module.exports = isSymbol;

        /***/
      },

    /***/ "./node_modules/lodash/isTypedArray.js":
      /*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseIsTypedArray = __webpack_require__(
            /*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"
          ),
          baseUnary = __webpack_require__(
            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
          ),
          nodeUtil = __webpack_require__(
            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
          );
        /* Node.js helper references. */

        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */

        var isTypedArray = nodeIsTypedArray
          ? baseUnary(nodeIsTypedArray)
          : baseIsTypedArray;
        module.exports = isTypedArray;

        /***/
      },

    /***/ "./node_modules/lodash/keys.js":
      /*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(
            /*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"
          ),
          baseKeys = __webpack_require__(
            /*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"
          ),
          isArrayLike = __webpack_require__(
            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
          );
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */

        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        module.exports = keys;

        /***/
      },

    /***/ "./node_modules/lodash/keysIn.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(
            /*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"
          ),
          baseKeysIn = __webpack_require__(
            /*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"
          ),
          isArrayLike = __webpack_require__(
            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
          );
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */

        function keysIn(object) {
          return isArrayLike(object)
            ? arrayLikeKeys(object, true)
            : baseKeysIn(object);
        }

        module.exports = keysIn;

        /***/
      },

    /***/ "./node_modules/lodash/last.js":
      /*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }

        module.exports = last;

        /***/
      },

    /***/ "./node_modules/lodash/mapValues.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/mapValues.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(
            /*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"
          ),
          baseForOwn = __webpack_require__(
            /*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"
          ),
          baseIteratee = __webpack_require__(
            /*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"
          );
        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */

        function mapValues(object, iteratee) {
          var result = {};
          iteratee = baseIteratee(iteratee, 3);
          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        module.exports = mapValues;

        /***/
      },

    /***/ "./node_modules/lodash/memoize.js":
      /*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(
          /*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"
        );
        /** Error message constants. */

        var FUNC_ERROR_TEXT = "Expected a function";
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */

        function memoize(func, resolver) {
          if (
            typeof func != "function" ||
            (resolver != null && typeof resolver != "function")
          ) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }

          var memoized = function memoized() {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }

            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };

          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        } // Expose `MapCache`.

        memoize.Cache = MapCache;
        module.exports = memoize;

        /***/
      },

    /***/ "./node_modules/lodash/omit.js":
      /*!*************************************!*\
  !*** ./node_modules/lodash/omit.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayMap = __webpack_require__(
            /*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"
          ),
          baseClone = __webpack_require__(
            /*! ./_baseClone */ "./node_modules/lodash/_baseClone.js"
          ),
          baseUnset = __webpack_require__(
            /*! ./_baseUnset */ "./node_modules/lodash/_baseUnset.js"
          ),
          castPath = __webpack_require__(
            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
          ),
          copyObject = __webpack_require__(
            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
          ),
          customOmitClone = __webpack_require__(
            /*! ./_customOmitClone */ "./node_modules/lodash/_customOmitClone.js"
          ),
          flatRest = __webpack_require__(
            /*! ./_flatRest */ "./node_modules/lodash/_flatRest.js"
          ),
          getAllKeysIn = __webpack_require__(
            /*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"
          );
        /** Used to compose bitmasks for cloning. */

        var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */

        var omit = flatRest(function(object, paths) {
          var result = {};

          if (object == null) {
            return result;
          }

          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);

          if (isDeep) {
            result = baseClone(
              result,
              CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
              customOmitClone
            );
          }

          var length = paths.length;

          while (length--) {
            baseUnset(result, paths[length]);
          }

          return result;
        });
        module.exports = omit;

        /***/
      },

    /***/ "./node_modules/lodash/property.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseProperty = __webpack_require__(
            /*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"
          ),
          basePropertyDeep = __webpack_require__(
            /*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"
          ),
          isKey = __webpack_require__(
            /*! ./_isKey */ "./node_modules/lodash/_isKey.js"
          ),
          toKey = __webpack_require__(
            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
          );
        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */

        function property(path) {
          return isKey(path)
            ? baseProperty(toKey(path))
            : basePropertyDeep(path);
        }

        module.exports = property;

        /***/
      },

    /***/ "./node_modules/lodash/range.js":
      /*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var createRange = __webpack_require__(
          /*! ./_createRange */ "./node_modules/lodash/_createRange.js"
        );
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */

        var range = createRange();
        module.exports = range;

        /***/
      },

    /***/ "./node_modules/lodash/sortBy.js":
      /*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(
            /*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"
          ),
          baseOrderBy = __webpack_require__(
            /*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"
          ),
          baseRest = __webpack_require__(
            /*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"
          ),
          isIterateeCall = __webpack_require__(
            /*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"
          );
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
         */

        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }

          var length = iteratees.length;

          if (
            length > 1 &&
            isIterateeCall(collection, iteratees[0], iteratees[1])
          ) {
            iteratees = [];
          } else if (
            length > 2 &&
            isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
          ) {
            iteratees = [iteratees[0]];
          }

          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        module.exports = sortBy;

        /***/
      },

    /***/ "./node_modules/lodash/stubArray.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        module.exports = stubArray;

        /***/
      },

    /***/ "./node_modules/lodash/stubFalse.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        module.exports = stubFalse;

        /***/
      },

    /***/ "./node_modules/lodash/toFinite.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var toNumber = __webpack_require__(
          /*! ./toNumber */ "./node_modules/lodash/toNumber.js"
        );
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0,
          MAX_INTEGER = 1.7976931348623157e308;
        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */

        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }

          value = toNumber(value);

          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }

          return value === value ? value : 0;
        }

        module.exports = toFinite;

        /***/
      },

    /***/ "./node_modules/lodash/toInteger.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var toFinite = __webpack_require__(
          /*! ./toFinite */ "./node_modules/lodash/toFinite.js"
        );
        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */

        function toInteger(value) {
          var result = toFinite(value),
            remainder = result % 1;
          return result === result
            ? remainder
              ? result - remainder
              : result
            : 0;
        }

        module.exports = toInteger;

        /***/
      },

    /***/ "./node_modules/lodash/toNumber.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          ),
          isSymbol = __webpack_require__(
            /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
          );
        /** Used as references for various `Number` constants. */

        var NAN = 0 / 0;
        /** Used to match leading and trailing whitespace. */

        var reTrim = /^\s+|\s+$/g;
        /** Used to detect bad signed hexadecimal string values. */

        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        /** Used to detect binary string values. */

        var reIsBinary = /^0b[01]+$/i;
        /** Used to detect octal string values. */

        var reIsOctal = /^0o[0-7]+$/i;
        /** Built-in method references without a dependency on `root`. */

        var freeParseInt = parseInt;
        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */

        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }

          if (isSymbol(value)) {
            return NAN;
          }

          if (isObject(value)) {
            var other =
              typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }

          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }

          value = value.replace(reTrim, "");
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value)
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : reIsBadHex.test(value)
            ? NAN
            : +value;
        }

        module.exports = toNumber;

        /***/
      },

    /***/ "./node_modules/lodash/toString.js":
      /*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var baseToString = __webpack_require__(
          /*! ./_baseToString */ "./node_modules/lodash/_baseToString.js"
        );
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */

        function toString(value) {
          return value == null ? "" : baseToString(value);
        }

        module.exports = toString;

        /***/
      },

    /***/ "./node_modules/lodash/transform.js":
      /*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var arrayEach = __webpack_require__(
            /*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"
          ),
          baseCreate = __webpack_require__(
            /*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"
          ),
          baseForOwn = __webpack_require__(
            /*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"
          ),
          baseIteratee = __webpack_require__(
            /*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"
          ),
          getPrototype = __webpack_require__(
            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
          ),
          isArray = __webpack_require__(
            /*! ./isArray */ "./node_modules/lodash/isArray.js"
          ),
          isBuffer = __webpack_require__(
            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
          ),
          isFunction = __webpack_require__(
            /*! ./isFunction */ "./node_modules/lodash/isFunction.js"
          ),
          isObject = __webpack_require__(
            /*! ./isObject */ "./node_modules/lodash/isObject.js"
          ),
          isTypedArray = __webpack_require__(
            /*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"
          );
        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */

        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee = baseIteratee(iteratee, 4);

          if (accumulator == null) {
            var Ctor = object && object.constructor;

            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor)
                ? baseCreate(getPrototype(object))
                : {};
            } else {
              accumulator = {};
            }
          }

          (isArrLike ? arrayEach : baseForOwn)(object, function(
            value,
            index,
            object
          ) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        module.exports = transform;

        /***/
      },

    /***/ "./node_modules/object-assign/index.js":
      /*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/

        /* eslint-disable no-unused-vars */

        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;

        function toObject(val) {
          if (val === null || val === undefined) {
            throw new TypeError(
              "Object.assign cannot be called with null or undefined"
            );
          }

          return Object(val);
        }

        function shouldUseNative() {
          try {
            if (!Object.assign) {
              return false;
            } // Detect buggy property enumeration order in older V8 versions.
            // https://bugs.chromium.org/p/v8/issues/detail?id=4118

            var test1 = new String("abc"); // eslint-disable-line no-new-wrappers

            test1[5] = "de";

            if (Object.getOwnPropertyNames(test1)[0] === "5") {
              return false;
            } // https://bugs.chromium.org/p/v8/issues/detail?id=3056

            var test2 = {};

            for (var i = 0; i < 10; i++) {
              test2["_" + String.fromCharCode(i)] = i;
            }

            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
              return test2[n];
            });

            if (order2.join("") !== "0123456789") {
              return false;
            } // https://bugs.chromium.org/p/v8/issues/detail?id=3056

            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
              test3[letter] = letter;
            });

            if (
              Object.keys(Object.assign({}, test3)).join("") !==
              "abcdefghijklmnopqrst"
            ) {
              return false;
            }

            return true;
          } catch (err) {
            // We don't expect any of the above to throw, but better to be safe.
            return false;
          }
        }

        module.exports = shouldUseNative()
          ? Object.assign
          : function(target, source) {
              var from;
              var to = toObject(target);
              var symbols;

              for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);

                for (var key in from) {
                  if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                  }
                }

                if (getOwnPropertySymbols) {
                  symbols = getOwnPropertySymbols(from);

                  for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                      to[symbols[i]] = from[symbols[i]];
                    }
                  }
                }
              }

              return to;
            };

        /***/
      },

    /***/ "./node_modules/preact-compat/dist/preact-compat.es.js":
      /*!*************************************************************!*\
  !*** ./node_modules/preact-compat/dist/preact-compat.es.js ***!
  \*************************************************************/
      /*! exports provided: PropTypes, default, version, DOM, Children, render, createClass, createPortal, createFactory, createElement, cloneElement, isValidElement, findDOMNode, unmountComponentAtNode, Component, PureComponent, unstable_renderSubtreeIntoContainer, unstable_batchedUpdates, __spread */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "version",
          function() {
            return version;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "DOM",
          function() {
            return DOM;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "Children",
          function() {
            return Children;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "render",
          function() {
            return render$1;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "createClass",
          function() {
            return createClass;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "createPortal",
          function() {
            return createPortal;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "createFactory",
          function() {
            return createFactory;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "createElement",
          function() {
            return createElement;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "cloneElement",
          function() {
            return cloneElement$1;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "isValidElement",
          function() {
            return isValidElement;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "findDOMNode",
          function() {
            return findDOMNode;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "unmountComponentAtNode",
          function() {
            return unmountComponentAtNode;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "Component",
          function() {
            return Component$1;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "PureComponent",
          function() {
            return PureComponent;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "unstable_renderSubtreeIntoContainer",
          function() {
            return renderSubtreeIntoContainer;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "unstable_batchedUpdates",
          function() {
            return unstable_batchedUpdates;
          }
        );
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "__spread",
          function() {
            return extend;
          }
        );
        /* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );
        /* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          prop_types__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony reexport (default from non-harmony) */ __webpack_require__.d(
          __webpack_exports__,
          "PropTypes",
          function() {
            return prop_types__WEBPACK_IMPORTED_MODULE_0___default.a;
          }
        );
        /* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! preact */ "./node_modules/preact/dist/preact.mjs"
        );
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var version = "15.1.0"; // trick libraries to think we are react

        var ELEMENTS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(
          " "
        );
        var REACT_ELEMENT_TYPE =
          (typeof Symbol !== "undefined" &&
            Symbol.for &&
            Symbol.for("react.element")) ||
          0xeac7;
        var COMPONENT_WRAPPER_KEY =
          typeof Symbol !== "undefined" && Symbol.for
            ? Symbol.for("__preactCompatWrapper")
            : "__preactCompatWrapper"; // don't autobind these methods since they already have guaranteed context.

        var AUTOBIND_BLACKLIST = {
          constructor: 1,
          render: 1,
          shouldComponentUpdate: 1,
          componentWillReceiveProps: 1,
          componentWillUpdate: 1,
          componentDidUpdate: 1,
          componentWillMount: 1,
          componentDidMount: 1,
          componentWillUnmount: 1,
          componentDidUnmount: 1,
        };
        var CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;
        var BYPASS_HOOK = {};
        /*global process*/

        var DEV = false;

        try {
          DEV = "development" !== "production";
        } catch (e) {} // a component that renders nothing. Used to replace components for unmountComponentAtNode.

        function EmptyComponent() {
          return null;
        } // make react think we're react.

        var VNode = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])("a", null)
          .constructor;
        VNode.prototype.$$typeof = REACT_ELEMENT_TYPE;
        VNode.prototype.preactCompatUpgraded = false;
        VNode.prototype.preactCompatNormalized = false;
        Object.defineProperty(VNode.prototype, "type", {
          get: function get() {
            return this.nodeName;
          },
          set: function set(v) {
            this.nodeName = v;
          },
          configurable: true,
        });
        Object.defineProperty(VNode.prototype, "props", {
          get: function get() {
            return this.attributes;
          },
          set: function set(v) {
            this.attributes = v;
          },
          configurable: true,
        });
        var oldEventHook = preact__WEBPACK_IMPORTED_MODULE_1__["options"].event;

        preact__WEBPACK_IMPORTED_MODULE_1__["options"].event = function(e) {
          if (oldEventHook) {
            e = oldEventHook(e);
          }

          e.persist = Object;
          e.nativeEvent = e;
          return e;
        };

        var oldVnodeHook = preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode;

        preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode = function(vnode) {
          if (!vnode.preactCompatUpgraded) {
            vnode.preactCompatUpgraded = true;
            var tag = vnode.nodeName,
              attrs = (vnode.attributes =
                vnode.attributes == null ? {} : extend({}, vnode.attributes));

            if (typeof tag === "function") {
              if (
                tag[COMPONENT_WRAPPER_KEY] === true ||
                (tag.prototype && "isReactComponent" in tag.prototype)
              ) {
                if (vnode.children && String(vnode.children) === "") {
                  vnode.children = undefined;
                }

                if (vnode.children) {
                  attrs.children = vnode.children;
                }

                if (!vnode.preactCompatNormalized) {
                  normalizeVNode(vnode);
                }

                handleComponentVNode(vnode);
              }
            } else {
              if (vnode.children && String(vnode.children) === "") {
                vnode.children = undefined;
              }

              if (vnode.children) {
                attrs.children = vnode.children;
              }

              if (attrs.defaultValue) {
                if (!attrs.value && attrs.value !== 0) {
                  attrs.value = attrs.defaultValue;
                }

                delete attrs.defaultValue;
              }

              handleElementVNode(vnode, attrs);
            }
          }

          if (oldVnodeHook) {
            oldVnodeHook(vnode);
          }
        };

        function handleComponentVNode(vnode) {
          var tag = vnode.nodeName,
            a = vnode.attributes;
          vnode.attributes = {};

          if (tag.defaultProps) {
            extend(vnode.attributes, tag.defaultProps);
          }

          if (a) {
            extend(vnode.attributes, a);
          }
        }

        function handleElementVNode(vnode, a) {
          var shouldSanitize, attrs, i;

          if (a) {
            for (i in a) {
              if ((shouldSanitize = CAMEL_PROPS.test(i))) {
                break;
              }
            }

            if (shouldSanitize) {
              attrs = vnode.attributes = {};

              for (i in a) {
                if (a.hasOwnProperty(i)) {
                  attrs[
                    CAMEL_PROPS.test(i)
                      ? i.replace(/([A-Z0-9])/, "-$1").toLowerCase()
                      : i
                  ] = a[i];
                }
              }
            }
          }
        } // proxy render() since React returns a Component reference.

        function render$1(vnode, parent, callback) {
          var prev =
            parent &&
            parent._preactCompatRendered &&
            parent._preactCompatRendered.base; // ignore impossible previous renders

          if (prev && prev.parentNode !== parent) {
            prev = null;
          } // default to first Element child

          if (!prev && parent) {
            prev = parent.firstElementChild;
          } // remove unaffected siblings

          for (var i = parent.childNodes.length; i--; ) {
            if (parent.childNodes[i] !== prev) {
              parent.removeChild(parent.childNodes[i]);
            }
          }

          var out = Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(
            vnode,
            parent,
            prev
          );

          if (parent) {
            parent._preactCompatRendered =
              out &&
              (out._component || {
                base: out,
              });
          }

          if (typeof callback === "function") {
            callback();
          }

          return (out && out._component) || out;
        }

        var ContextProvider = function ContextProvider() {};

        ContextProvider.prototype.getChildContext = function() {
          return this.props.context;
        };

        ContextProvider.prototype.render = function(props) {
          return props.children[0];
        };

        function renderSubtreeIntoContainer(
          parentComponent,
          vnode,
          container,
          callback
        ) {
          var wrap = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(
            ContextProvider,
            {
              context: parentComponent.context,
            },
            vnode
          );
          var renderContainer = render$1(wrap, container);
          var component = renderContainer._component || renderContainer.base;

          if (callback) {
            callback.call(component, renderContainer);
          }

          return component;
        }

        function Portal(props) {
          renderSubtreeIntoContainer(this, props.vnode, props.container);
        }

        function createPortal(vnode, container) {
          return Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(Portal, {
            vnode: vnode,
            container: container,
          });
        }

        function unmountComponentAtNode(container) {
          var existing =
            container._preactCompatRendered &&
            container._preactCompatRendered.base;

          if (existing && existing.parentNode === container) {
            Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(
              Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(EmptyComponent),
              container,
              existing
            );
            return true;
          }

          return false;
        }

        var ARR = []; // This API is completely unnecessary for Preact, so it's basically passthrough.

        var Children = {
          map: function map(children, fn, ctx) {
            if (children == null) {
              return null;
            }

            children = Children.toArray(children);

            if (ctx && ctx !== children) {
              fn = fn.bind(ctx);
            }

            return children.map(fn);
          },
          forEach: function forEach(children, fn, ctx) {
            if (children == null) {
              return null;
            }

            children = Children.toArray(children);

            if (ctx && ctx !== children) {
              fn = fn.bind(ctx);
            }

            children.forEach(fn);
          },
          count: function count(children) {
            return (children && children.length) || 0;
          },
          only: function only(children) {
            children = Children.toArray(children);

            if (children.length !== 1) {
              throw new Error("Children.only() expects only one child.");
            }

            return children[0];
          },
          toArray: function toArray(children) {
            if (children == null) {
              return [];
            }

            return ARR.concat(children);
          },
        };
        /** Track current render() component for ref assignment */

        var currentComponent;

        function createFactory(type) {
          return createElement.bind(null, type);
        }

        var DOM = {};

        for (var i = ELEMENTS.length; i--; ) {
          DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
        }

        function upgradeToVNodes(arr, offset) {
          for (var i = offset || 0; i < arr.length; i++) {
            var obj = arr[i];

            if (Array.isArray(obj)) {
              upgradeToVNodes(obj);
            } else if (
              obj &&
              _typeof(obj) === "object" &&
              !isValidElement(obj) &&
              ((obj.props && obj.type) ||
                (obj.attributes && obj.nodeName) ||
                obj.children)
            ) {
              arr[i] = createElement(
                obj.type || obj.nodeName,
                obj.props || obj.attributes,
                obj.children
              );
            }
          }
        }

        function isStatelessComponent(c) {
          return (
            typeof c === "function" && !(c.prototype && c.prototype.render)
          );
        } // wraps stateless functional components in a PropTypes validator

        function wrapStatelessComponent(WrappedComponent) {
          return createClass({
            displayName: WrappedComponent.displayName || WrappedComponent.name,
            render: function render() {
              return WrappedComponent(this.props, this.context);
            },
          });
        }

        function statelessComponentHook(Ctor) {
          var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];

          if (Wrapped) {
            return Wrapped === true ? Ctor : Wrapped;
          }

          Wrapped = wrapStatelessComponent(Ctor);
          Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, {
            configurable: true,
            value: true,
          });
          Wrapped.displayName = Ctor.displayName;
          Wrapped.propTypes = Ctor.propTypes;
          Wrapped.defaultProps = Ctor.defaultProps;
          Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, {
            configurable: true,
            value: Wrapped,
          });
          return Wrapped;
        }

        function createElement() {
          var args = [],
            len = arguments.length;

          while (len--) {
            args[len] = arguments[len];
          }

          upgradeToVNodes(args, 2);
          return normalizeVNode(
            preact__WEBPACK_IMPORTED_MODULE_1__["h"].apply(void 0, args)
          );
        }

        function normalizeVNode(vnode) {
          vnode.preactCompatNormalized = true;
          applyClassName(vnode);

          if (isStatelessComponent(vnode.nodeName)) {
            vnode.nodeName = statelessComponentHook(vnode.nodeName);
          }

          var ref = vnode.attributes.ref,
            type = ref && _typeof(ref);

          if (currentComponent && (type === "string" || type === "number")) {
            vnode.attributes.ref = createStringRefProxy(ref, currentComponent);
          }

          applyEventNormalization(vnode);
          return vnode;
        }

        function cloneElement$1(element, props) {
          var children = [],
            len = arguments.length - 2;

          while (len-- > 0) {
            children[len] = arguments[len + 2];
          }

          if (!isValidElement(element)) {
            return element;
          }

          var elementProps = element.attributes || element.props;
          var node = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(
            element.nodeName || element.type,
            extend({}, elementProps),
            element.children || (elementProps && elementProps.children)
          ); // Only provide the 3rd argument if needed.
          // Arguments 3+ overwrite element.children in preactCloneElement

          var cloneArgs = [node, props];

          if (children && children.length) {
            cloneArgs.push(children);
          } else if (props && props.children) {
            cloneArgs.push(props.children);
          }

          return normalizeVNode(
            preact__WEBPACK_IMPORTED_MODULE_1__["cloneElement"].apply(
              void 0,
              cloneArgs
            )
          );
        }

        function isValidElement(element) {
          return (
            element &&
            (element instanceof VNode ||
              element.$$typeof === REACT_ELEMENT_TYPE)
          );
        }

        function createStringRefProxy(name, component) {
          return (
            component._refProxies[name] ||
            (component._refProxies[name] = function(resolved) {
              if (component && component.refs) {
                component.refs[name] = resolved;

                if (resolved === null) {
                  delete component._refProxies[name];
                  component = null;
                }
              }
            })
          );
        }

        function applyEventNormalization(ref) {
          var nodeName = ref.nodeName;
          var attributes = ref.attributes;

          if (!attributes || typeof nodeName !== "string") {
            return;
          }

          var props = {};

          for (var i in attributes) {
            props[i.toLowerCase()] = i;
          }

          if (props.ondoubleclick) {
            attributes.ondblclick = attributes[props.ondoubleclick];
            delete attributes[props.ondoubleclick];
          } // for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:

          if (
            props.onchange &&
            (nodeName === "textarea" ||
              (nodeName.toLowerCase() === "input" &&
                !/^fil|che|rad/i.test(attributes.type)))
          ) {
            var normalized = props.oninput || "oninput";

            if (!attributes[normalized]) {
              attributes[normalized] = multihook([
                attributes[normalized],
                attributes[props.onchange],
              ]);
              delete attributes[props.onchange];
            }
          }
        }

        function applyClassName(vnode) {
          var a = vnode.attributes || (vnode.attributes = {});
          classNameDescriptor.enumerable = "className" in a;

          if (a.className) {
            a.class = a.className;
          }

          Object.defineProperty(a, "className", classNameDescriptor);
        }

        var classNameDescriptor = {
          configurable: true,
          get: function get() {
            return this.class;
          },
          set: function set(v) {
            this.class = v;
          },
        };

        function extend(base, props) {
          var arguments$1 = arguments;

          for (var i = 1, obj = void 0; i < arguments.length; i++) {
            if ((obj = arguments$1[i])) {
              for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                  base[key] = obj[key];
                }
              }
            }
          }

          return base;
        }

        function shallowDiffers(a, b) {
          for (var i in a) {
            if (!(i in b)) {
              return true;
            }
          }

          for (var i$1 in b) {
            if (a[i$1] !== b[i$1]) {
              return true;
            }
          }

          return false;
        }

        function findDOMNode(component) {
          return (
            (component &&
              (component.base || (component.nodeType === 1 && component))) ||
            null
          );
        }

        function F() {}

        function createClass(obj) {
          function cl(props, context) {
            bindAll(this);
            Component$1.call(this, props, context, BYPASS_HOOK);
            newComponentHook.call(this, props, context);
          }

          obj = extend(
            {
              constructor: cl,
            },
            obj
          ); // We need to apply mixins here so that getDefaultProps is correctly mixed

          if (obj.mixins) {
            applyMixins(obj, collateMixins(obj.mixins));
          }

          if (obj.statics) {
            extend(cl, obj.statics);
          }

          if (obj.propTypes) {
            cl.propTypes = obj.propTypes;
          }

          if (obj.defaultProps) {
            cl.defaultProps = obj.defaultProps;
          }

          if (obj.getDefaultProps) {
            cl.defaultProps = obj.getDefaultProps.call(cl);
          }

          F.prototype = Component$1.prototype;
          cl.prototype = extend(new F(), obj);
          cl.displayName = obj.displayName || "Component";
          return cl;
        } // Flatten an Array of mixins to a map of method name to mixin implementations

        function collateMixins(mixins) {
          var keyed = {};

          for (var i = 0; i < mixins.length; i++) {
            var mixin = mixins[i];

            for (var key in mixin) {
              if (
                mixin.hasOwnProperty(key) &&
                typeof mixin[key] === "function"
              ) {
                (keyed[key] || (keyed[key] = [])).push(mixin[key]);
              }
            }
          }

          return keyed;
        } // apply a mapping of Arrays of mixin methods to a component prototype

        function applyMixins(proto, mixins) {
          for (var key in mixins) {
            if (mixins.hasOwnProperty(key)) {
              proto[key] = multihook(
                mixins[key].concat(proto[key] || ARR),
                key === "getDefaultProps" ||
                  key === "getInitialState" ||
                  key === "getChildContext"
              );
            }
          }
        }

        function bindAll(ctx) {
          for (var i in ctx) {
            var v = ctx[i];

            if (
              typeof v === "function" &&
              !v.__bound &&
              !AUTOBIND_BLACKLIST.hasOwnProperty(i)
            ) {
              (ctx[i] = v.bind(ctx)).__bound = true;
            }
          }
        }

        function callMethod(ctx, m, args) {
          if (typeof m === "string") {
            m = ctx.constructor.prototype[m];
          }

          if (typeof m === "function") {
            return m.apply(ctx, args);
          }
        }

        function multihook(hooks, skipDuplicates) {
          return function() {
            var arguments$1 = arguments;
            var this$1 = this;
            var ret;

            for (var i = 0; i < hooks.length; i++) {
              var r = callMethod(this$1, hooks[i], arguments$1);

              if (skipDuplicates && r != null) {
                if (!ret) {
                  ret = {};
                }

                for (var key in r) {
                  if (r.hasOwnProperty(key)) {
                    ret[key] = r[key];
                  }
                }
              } else if (typeof r !== "undefined") {
                ret = r;
              }
            }

            return ret;
          };
        }

        function newComponentHook(props, context) {
          propsHook.call(this, props, context);
          this.componentWillReceiveProps = multihook([
            propsHook,
            this.componentWillReceiveProps || "componentWillReceiveProps",
          ]);
          this.render = multihook([
            propsHook,
            beforeRender,
            this.render || "render",
            afterRender,
          ]);
        }

        function propsHook(props, context) {
          if (!props) {
            return;
          } // React annoyingly special-cases single children, and some react components are ridiculously strict about this.

          var c = props.children;

          if (
            c &&
            Array.isArray(c) &&
            c.length === 1 &&
            (typeof c[0] === "string" ||
              typeof c[0] === "function" ||
              c[0] instanceof VNode)
          ) {
            props.children = c[0]; // but its totally still going to be an Array.

            if (props.children && _typeof(props.children) === "object") {
              props.children.length = 1;
              props.children[0] = props.children;
            }
          } // add proptype checking

          if (DEV) {
            var ctor = typeof this === "function" ? this : this.constructor,
              propTypes = this.propTypes || ctor.propTypes;
            var displayName = this.displayName || ctor.name;

            if (propTypes) {
              prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.checkPropTypes(
                propTypes,
                props,
                "prop",
                displayName
              );
            }
          }
        }

        function beforeRender(props) {
          currentComponent = this;
        }

        function afterRender() {
          if (currentComponent === this) {
            currentComponent = null;
          }
        }

        function Component$1(props, context, opts) {
          preact__WEBPACK_IMPORTED_MODULE_1__["Component"].call(
            this,
            props,
            context
          );
          this.state = this.getInitialState ? this.getInitialState() : {};
          this.refs = {};
          this._refProxies = {};

          if (opts !== BYPASS_HOOK) {
            newComponentHook.call(this, props, context);
          }
        }

        extend(
          (Component$1.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__[
            "Component"
          ]()),
          {
            constructor: Component$1,
            isReactComponent: {},
            replaceState: function replaceState(state, callback) {
              var this$1 = this;
              this.setState(state, callback);

              for (var i in this$1.state) {
                if (!(i in state)) {
                  delete this$1.state[i];
                }
              }
            },
            getDOMNode: function getDOMNode() {
              return this.base;
            },
            isMounted: function isMounted() {
              return !!this.base;
            },
          }
        );

        function PureComponent(props, context) {
          Component$1.call(this, props, context);
        }

        F.prototype = Component$1.prototype;
        PureComponent.prototype = new F();
        PureComponent.prototype.isPureReactComponent = true;

        PureComponent.prototype.shouldComponentUpdate = function(props, state) {
          return (
            shallowDiffers(this.props, props) ||
            shallowDiffers(this.state, state)
          );
        };

        function unstable_batchedUpdates(callback) {
          callback();
        }

        var index = {
          version: version,
          DOM: DOM,
          PropTypes: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a,
          Children: Children,
          render: render$1,
          createClass: createClass,
          createPortal: createPortal,
          createFactory: createFactory,
          createElement: createElement,
          cloneElement: cloneElement$1,
          isValidElement: isValidElement,
          findDOMNode: findDOMNode,
          unmountComponentAtNode: unmountComponentAtNode,
          Component: Component$1,
          PureComponent: PureComponent,
          unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,
          unstable_batchedUpdates: unstable_batchedUpdates,
          __spread: extend,
        };
        /* harmony default export */ __webpack_exports__["default"] = index;

        /***/
      },

    /***/ "./node_modules/prop-types-extra/lib/all.js":
      /*!**************************************************!*\
  !*** ./node_modules/prop-types-extra/lib/all.js ***!
  \**************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true,
        });
        exports.default = all;

        var _createChainableTypeChecker = __webpack_require__(
          /*! ./utils/createChainableTypeChecker */ "./node_modules/prop-types-extra/lib/utils/createChainableTypeChecker.js"
        );

        var _createChainableTypeChecker2 = _interopRequireDefault(
          _createChainableTypeChecker
        );

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function all() {
          for (
            var _len = arguments.length, validators = Array(_len), _key = 0;
            _key < _len;
            _key++
          ) {
            validators[_key] = arguments[_key];
          }

          function allPropTypes() {
            for (
              var _len2 = arguments.length, args = Array(_len2), _key2 = 0;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2] = arguments[_key2];
            }

            var error = null;
            validators.forEach(function(validator) {
              if (error != null) {
                return;
              }

              var result = validator.apply(undefined, args);

              if (result != null) {
                error = result;
              }
            });
            return error;
          }

          return (0, _createChainableTypeChecker2.default)(allPropTypes);
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/prop-types-extra/lib/componentOrElement.js":
      /*!*****************************************************************!*\
  !*** ./node_modules/prop-types-extra/lib/componentOrElement.js ***!
  \*****************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof2(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof2 = function _typeof2(obj) {
              return typeof obj;
            };
          } else {
            _typeof2 = function _typeof2(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof2(obj);
        }

        Object.defineProperty(exports, "__esModule", {
          value: true,
        });

        var _typeof =
          typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol"
            ? function(obj) {
                return _typeof2(obj);
              }
            : function(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : _typeof2(obj);
              };

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _createChainableTypeChecker = __webpack_require__(
          /*! ./utils/createChainableTypeChecker */ "./node_modules/prop-types-extra/lib/utils/createChainableTypeChecker.js"
        );

        var _createChainableTypeChecker2 = _interopRequireDefault(
          _createChainableTypeChecker
        );

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function validate(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];
          var propType =
            typeof propValue === "undefined" ? "undefined" : _typeof(propValue);

          if (_react2.default.isValidElement(propValue)) {
            return new Error(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type ReactElement " +
                ("supplied to `" +
                  componentName +
                  "`, expected a ReactComponent or a ") +
                "DOMElement. You can usually obtain a ReactComponent or DOMElement " +
                "from a ReactElement by attaching a ref to it."
            );
          }

          if (
            (propType !== "object" || typeof propValue.render !== "function") &&
            propValue.nodeType !== 1
          ) {
            return new Error(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of value `" +
                propValue +
                "` " +
                ("supplied to `" +
                  componentName +
                  "`, expected a ReactComponent or a ") +
                "DOMElement."
            );
          }

          return null;
        }

        exports.default = (0, _createChainableTypeChecker2.default)(validate);
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/prop-types-extra/lib/elementType.js":
      /*!**********************************************************!*\
  !*** ./node_modules/prop-types-extra/lib/elementType.js ***!
  \**********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true,
        });

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _reactIs = __webpack_require__(
          /*! react-is */ "./node_modules/react-is/index.js"
        );

        var _createChainableTypeChecker = __webpack_require__(
          /*! ./utils/createChainableTypeChecker */ "./node_modules/prop-types-extra/lib/utils/createChainableTypeChecker.js"
        );

        var _createChainableTypeChecker2 = _interopRequireDefault(
          _createChainableTypeChecker
        );

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function elementType(
          props,
          propName,
          componentName,
          location,
          propFullName
        ) {
          var propValue = props[propName];

          if (_react2.default.isValidElement(propValue)) {
            return new Error(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of type ReactElement " +
                ("supplied to `" +
                  componentName +
                  "`,expected an element type (a string ") +
                ", component class, or function component)."
            );
          }

          if (!(0, _reactIs.isValidElementType)(propValue)) {
            return new Error(
              "Invalid " +
                location +
                " `" +
                propFullName +
                "` of value `" +
                propValue +
                "` " +
                ("supplied to `" +
                  componentName +
                  "`, expected an element type (a string ") +
                ", component class, or function component)."
            );
          }

          return null;
        }

        exports.default = (0, _createChainableTypeChecker2.default)(
          elementType
        );
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/prop-types-extra/lib/utils/createChainableTypeChecker.js":
      /*!*******************************************************************************!*\
  !*** ./node_modules/prop-types-extra/lib/utils/createChainableTypeChecker.js ***!
  \*******************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true,
        });
        exports.default = createChainableTypeChecker;
        /**
         * Copyright 2013-present, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         */
        // Mostly taken from ReactPropTypes.

        function createChainableTypeChecker(validate) {
          function checkType(
            isRequired,
            props,
            propName,
            componentName,
            location,
            propFullName
          ) {
            var componentNameSafe = componentName || "<<anonymous>>";
            var propFullNameSafe = propFullName || propName;

            if (props[propName] == null) {
              if (isRequired) {
                return new Error(
                  "Required " +
                    location +
                    " `" +
                    propFullNameSafe +
                    "` was not specified " +
                    ("in `" + componentNameSafe + "`.")
                );
              }

              return null;
            }

            for (
              var _len = arguments.length,
                args = Array(_len > 6 ? _len - 6 : 0),
                _key = 6;
              _key < _len;
              _key++
            ) {
              args[_key - 6] = arguments[_key];
            }

            return validate.apply(
              undefined,
              [
                props,
                propName,
                componentNameSafe,
                location,
                propFullNameSafe,
              ].concat(args)
            );
          }

          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/prop-types/checkPropTypes.js":
      /*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var printWarning = function printWarning() {};

        if (true) {
          var ReactPropTypesSecret = __webpack_require__(
            /*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js"
          );

          var loggedTypeFailures = {};
          var has = Function.call.bind(Object.prototype.hasOwnProperty);

          printWarning = function printWarning(text) {
            var message = "Warning: " + text;

            if (typeof console !== "undefined") {
              console.error(message);
            }

            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };
        }
        /**
         * Assert that the values match with the type specs.
         * Error messages are memorized and will only be shown once.
         *
         * @param {object} typeSpecs Map of name to a ReactPropType
         * @param {object} values Runtime values that need to be type-checked
         * @param {string} location e.g. "prop", "context", "child context"
         * @param {string} componentName Name of the component for error messages.
         * @param {?Function} getStack Returns the component stack.
         * @private
         */

        function checkPropTypes(
          typeSpecs,
          values,
          location,
          componentName,
          getStack
        ) {
          if (true) {
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error; // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.

                try {
                  // This is intentionally an invariant that gets caught. It's the same
                  // behavior as without this statement except with a better message.
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error(
                      (componentName || "React class") +
                        ": " +
                        location +
                        " type `" +
                        typeSpecName +
                        "` is invalid; " +
                        "it must be a function, usually from the `prop-types` package, but received `" +
                        _typeof(typeSpecs[typeSpecName]) +
                        "`."
                    );
                    err.name = "Invariant Violation";
                    throw err;
                  }

                  error = typeSpecs[typeSpecName](
                    values,
                    typeSpecName,
                    componentName,
                    location,
                    null,
                    ReactPropTypesSecret
                  );
                } catch (ex) {
                  error = ex;
                }

                if (error && !(error instanceof Error)) {
                  printWarning(
                    (componentName || "React class") +
                      ": type specification of " +
                      location +
                      " `" +
                      typeSpecName +
                      "` is invalid; the type checker " +
                      "function must return `null` or an `Error` but returned a " +
                      _typeof(error) +
                      ". " +
                      "You may have forgotten to pass an argument to the type checker " +
                      "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
                      "shape all require an argument)."
                  );
                }

                if (
                  error instanceof Error &&
                  !(error.message in loggedTypeFailures)
                ) {
                  // Only monitor this failure once because there tends to be a lot of the
                  // same error.
                  loggedTypeFailures[error.message] = true;
                  var stack = getStack ? getStack() : "";
                  printWarning(
                    "Failed " +
                      location +
                      " type: " +
                      error.message +
                      (stack != null ? stack : "")
                  );
                }
              }
            }
          }
        }
        /**
         * Resets warning cache when testing.
         *
         * @private
         */

        checkPropTypes.resetWarningCache = function() {
          if (true) {
            loggedTypeFailures = {};
          }
        };

        module.exports = checkPropTypes;

        /***/
      },

    /***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
      /*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var ReactIs = __webpack_require__(
          /*! react-is */ "./node_modules/react-is/index.js"
        );

        var assign = __webpack_require__(
          /*! object-assign */ "./node_modules/object-assign/index.js"
        );

        var ReactPropTypesSecret = __webpack_require__(
          /*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js"
        );

        var checkPropTypes = __webpack_require__(
          /*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js"
        );

        var has = Function.call.bind(Object.prototype.hasOwnProperty);

        var printWarning = function printWarning() {};

        if (true) {
          printWarning = function printWarning(text) {
            var message = "Warning: " + text;

            if (typeof console !== "undefined") {
              console.error(message);
            }

            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };
        }

        function emptyFunctionThatReturnsNull() {
          return null;
        }

        module.exports = function(isValidElement, throwOnDirectAccess) {
          /* global Symbol */
          var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator"; // Before Symbol spec.

          /**
           * Returns the iterator method function contained on the iterable object.
           *
           * Be sure to invoke the function with the iterable as context:
           *
           *     var iteratorFn = getIteratorFn(myIterable);
           *     if (iteratorFn) {
           *       var iterator = iteratorFn.call(myIterable);
           *       ...
           *     }
           *
           * @param {?object} maybeIterable
           * @return {?function}
           */

          function getIteratorFn(maybeIterable) {
            var iteratorFn =
              maybeIterable &&
              ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
                maybeIterable[FAUX_ITERATOR_SYMBOL]);

            if (typeof iteratorFn === "function") {
              return iteratorFn;
            }
          }
          /**
           * Collection of methods that allow declaration and validation of props that are
           * supplied to React components. Example usage:
           *
           *   var Props = require('ReactPropTypes');
           *   var MyArticle = React.createClass({
           *     propTypes: {
           *       // An optional string prop named "description".
           *       description: Props.string,
           *
           *       // A required enum prop named "category".
           *       category: Props.oneOf(['News','Photos']).isRequired,
           *
           *       // A prop named "dialog" that requires an instance of Dialog.
           *       dialog: Props.instanceOf(Dialog).isRequired
           *     },
           *     render: function() { ... }
           *   });
           *
           * A more formal specification of how these methods are used:
           *
           *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
           *   decl := ReactPropTypes.{type}(.isRequired)?
           *
           * Each and every declaration produces a function with the same signature. This
           * allows the creation of custom validation functions. For example:
           *
           *  var MyLink = React.createClass({
           *    propTypes: {
           *      // An optional string or URI prop named "href".
           *      href: function(props, propName, componentName) {
           *        var propValue = props[propName];
           *        if (propValue != null && typeof propValue !== 'string' &&
           *            !(propValue instanceof URI)) {
           *          return new Error(
           *            'Expected a string or an URI for ' + propName + ' in ' +
           *            componentName
           *          );
           *        }
           *      }
           *    },
           *    render: function() {...}
           *  });
           *
           * @internal
           */

          var ANONYMOUS = "<<anonymous>>"; // Important!
          // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

          var ReactPropTypes = {
            array: createPrimitiveTypeChecker("array"),
            bool: createPrimitiveTypeChecker("boolean"),
            func: createPrimitiveTypeChecker("function"),
            number: createPrimitiveTypeChecker("number"),
            object: createPrimitiveTypeChecker("object"),
            string: createPrimitiveTypeChecker("string"),
            symbol: createPrimitiveTypeChecker("symbol"),
            any: createAnyTypeChecker(),
            arrayOf: createArrayOfTypeChecker,
            element: createElementTypeChecker(),
            elementType: createElementTypeTypeChecker(),
            instanceOf: createInstanceTypeChecker,
            node: createNodeChecker(),
            objectOf: createObjectOfTypeChecker,
            oneOf: createEnumTypeChecker,
            oneOfType: createUnionTypeChecker,
            shape: createShapeTypeChecker,
            exact: createStrictShapeTypeChecker,
          };
          /**
           * inlined Object.is polyfill to avoid requiring consumers ship their own
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
           */

          /*eslint-disable no-self-compare*/

          function is(x, y) {
            // SameValue algorithm
            if (x === y) {
              // Steps 1-5, 7-10
              // Steps 6.b-6.e: +0 != -0
              return x !== 0 || 1 / x === 1 / y;
            } else {
              // Step 6.a: NaN == NaN
              return x !== x && y !== y;
            }
          }
          /*eslint-enable no-self-compare*/

          /**
           * We use an Error-like object for backward compatibility as people may call
           * PropTypes directly and inspect their output. However, we don't use real
           * Errors anymore. We don't inspect their stack anyway, and creating them
           * is prohibitively expensive if they are created too often, such as what
           * happens in oneOfType() for any type before the one that matched.
           */

          function PropTypeError(message) {
            this.message = message;
            this.stack = "";
          } // Make `instanceof Error` still work for returned errors.

          PropTypeError.prototype = Error.prototype;

          function createChainableTypeChecker(validate) {
            if (true) {
              var manualPropTypeCallCache = {};
              var manualPropTypeWarningCount = 0;
            }

            function checkType(
              isRequired,
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              componentName = componentName || ANONYMOUS;
              propFullName = propFullName || propName;

              if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                  // New behavior only for users of `prop-types` package
                  var err = new Error(
                    "Calling PropTypes validators directly is not supported by the `prop-types` package. " +
                      "Use `PropTypes.checkPropTypes()` to call them. " +
                      "Read more at http://fb.me/use-check-prop-types"
                  );
                  err.name = "Invariant Violation";
                  throw err;
                } else if (true && typeof console !== "undefined") {
                  // Old behavior for people using React.PropTypes
                  var cacheKey = componentName + ":" + propName;

                  if (
                    !manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3
                  ) {
                    printWarning(
                      "You are manually calling a React.PropTypes validation " +
                        "function for the `" +
                        propFullName +
                        "` prop on `" +
                        componentName +
                        "`. This is deprecated " +
                        "and will throw in the standalone `prop-types` package. " +
                        "You may be seeing this warning due to a third-party PropTypes " +
                        "library. See https://fb.me/react-warning-dont-call-proptypes " +
                        "for details."
                    );
                    manualPropTypeCallCache[cacheKey] = true;
                    manualPropTypeWarningCount++;
                  }
                }
              }

              if (props[propName] == null) {
                if (isRequired) {
                  if (props[propName] === null) {
                    return new PropTypeError(
                      "The " +
                        location +
                        " `" +
                        propFullName +
                        "` is marked as required " +
                        ("in `" + componentName + "`, but its value is `null`.")
                    );
                  }

                  return new PropTypeError(
                    "The " +
                      location +
                      " `" +
                      propFullName +
                      "` is marked as required in " +
                      ("`" + componentName + "`, but its value is `undefined`.")
                  );
                }

                return null;
              } else {
                return validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                );
              }
            }

            var chainedCheckType = checkType.bind(null, false);
            chainedCheckType.isRequired = checkType.bind(null, true);
            return chainedCheckType;
          }

          function createPrimitiveTypeChecker(expectedType) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      preciseType +
                      "` supplied to `" +
                      componentName +
                      "`, expected ") +
                    ("`" + expectedType + "`.")
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createAnyTypeChecker() {
            return createChainableTypeChecker(emptyFunctionThatReturnsNull);
          }

          function createArrayOfTypeChecker(typeChecker) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (typeof typeChecker !== "function") {
                return new PropTypeError(
                  "Property `" +
                    propFullName +
                    "` of component `" +
                    componentName +
                    "` has invalid PropType notation inside arrayOf."
                );
              }

              var propValue = props[propName];

              if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      propType +
                      "` supplied to `" +
                      componentName +
                      "`, expected an array.")
                );
              }

              for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(
                  propValue,
                  i,
                  componentName,
                  location,
                  propFullName + "[" + i + "]",
                  ReactPropTypesSecret
                );

                if (error instanceof Error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createElementTypeChecker() {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];

              if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      propType +
                      "` supplied to `" +
                      componentName +
                      "`, expected a single ReactElement.")
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createElementTypeTypeChecker() {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];

              if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      propType +
                      "` supplied to `" +
                      componentName +
                      "`, expected a single ReactElement type.")
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createInstanceTypeChecker(expectedClass) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      actualClassName +
                      "` supplied to `" +
                      componentName +
                      "`, expected ") +
                    ("instance of `" + expectedClassName + "`.")
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createEnumTypeChecker(expectedValues) {
            if (!Array.isArray(expectedValues)) {
              if (true) {
                if (arguments.length > 1) {
                  printWarning(
                    "Invalid arguments supplied to oneOf, expected an array, got " +
                      arguments.length +
                      " arguments. " +
                      "A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                  );
                } else {
                  printWarning(
                    "Invalid argument supplied to oneOf, expected an array."
                  );
                }
              }

              return emptyFunctionThatReturnsNull;
            }

            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];

              for (var i = 0; i < expectedValues.length; i++) {
                if (is(propValue, expectedValues[i])) {
                  return null;
                }
              }

              var valuesString = JSON.stringify(
                expectedValues,
                function replacer(key, value) {
                  var type = getPreciseType(value);

                  if (type === "symbol") {
                    return String(value);
                  }

                  return value;
                }
              );
              return new PropTypeError(
                "Invalid " +
                  location +
                  " `" +
                  propFullName +
                  "` of value `" +
                  String(propValue) +
                  "` " +
                  ("supplied to `" +
                    componentName +
                    "`, expected one of " +
                    valuesString +
                    ".")
              );
            }

            return createChainableTypeChecker(validate);
          }

          function createObjectOfTypeChecker(typeChecker) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (typeof typeChecker !== "function") {
                return new PropTypeError(
                  "Property `" +
                    propFullName +
                    "` of component `" +
                    componentName +
                    "` has invalid PropType notation inside objectOf."
                );
              }

              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== "object") {
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type " +
                    ("`" +
                      propType +
                      "` supplied to `" +
                      componentName +
                      "`, expected an object.")
                );
              }

              for (var key in propValue) {
                if (has(propValue, key)) {
                  var error = typeChecker(
                    propValue,
                    key,
                    componentName,
                    location,
                    propFullName + "." + key,
                    ReactPropTypesSecret
                  );

                  if (error instanceof Error) {
                    return error;
                  }
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createUnionTypeChecker(arrayOfTypeCheckers) {
            if (!Array.isArray(arrayOfTypeCheckers)) {
              true
                ? printWarning(
                    "Invalid argument supplied to oneOfType, expected an instance of array."
                  )
                : undefined;
              return emptyFunctionThatReturnsNull;
            }

            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
              var checker = arrayOfTypeCheckers[i];

              if (typeof checker !== "function") {
                printWarning(
                  "Invalid argument supplied to oneOfType. Expected an array of check functions, but " +
                    "received " +
                    getPostfixForTypeWarning(checker) +
                    " at index " +
                    i +
                    "."
                );
                return emptyFunctionThatReturnsNull;
              }
            }

            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];

                if (
                  checker(
                    props,
                    propName,
                    componentName,
                    location,
                    propFullName,
                    ReactPropTypesSecret
                  ) == null
                ) {
                  return null;
                }
              }

              return new PropTypeError(
                "Invalid " +
                  location +
                  " `" +
                  propFullName +
                  "` supplied to " +
                  ("`" + componentName + "`.")
              );
            }

            return createChainableTypeChecker(validate);
          }

          function createNodeChecker() {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (!isNode(props[propName])) {
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` supplied to " +
                    ("`" + componentName + "`, expected a ReactNode.")
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createShapeTypeChecker(shapeTypes) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== "object") {
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type `" +
                    propType +
                    "` " +
                    ("supplied to `" + componentName + "`, expected `object`.")
                );
              }

              for (var key in shapeTypes) {
                var checker = shapeTypes[key];

                if (!checker) {
                  continue;
                }

                var error = checker(
                  propValue,
                  key,
                  componentName,
                  location,
                  propFullName + "." + key,
                  ReactPropTypesSecret
                );

                if (error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createStrictShapeTypeChecker(shapeTypes) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== "object") {
                return new PropTypeError(
                  "Invalid " +
                    location +
                    " `" +
                    propFullName +
                    "` of type `" +
                    propType +
                    "` " +
                    ("supplied to `" + componentName + "`, expected `object`.")
                );
              } // We need to check all keys in case some are required but missing from
              // props.

              var allKeys = assign({}, props[propName], shapeTypes);

              for (var key in allKeys) {
                var checker = shapeTypes[key];

                if (!checker) {
                  return new PropTypeError(
                    "Invalid " +
                      location +
                      " `" +
                      propFullName +
                      "` key `" +
                      key +
                      "` supplied to `" +
                      componentName +
                      "`." +
                      "\nBad object: " +
                      JSON.stringify(props[propName], null, "  ") +
                      "\nValid keys: " +
                      JSON.stringify(Object.keys(shapeTypes), null, "  ")
                  );
                }

                var error = checker(
                  propValue,
                  key,
                  componentName,
                  location,
                  propFullName + "." + key,
                  ReactPropTypesSecret
                );

                if (error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function isNode(propValue) {
            switch (_typeof(propValue)) {
              case "number":
              case "string":
              case "undefined":
                return true;

              case "boolean":
                return !propValue;

              case "object":
                if (Array.isArray(propValue)) {
                  return propValue.every(isNode);
                }

                if (propValue === null || isValidElement(propValue)) {
                  return true;
                }

                var iteratorFn = getIteratorFn(propValue);

                if (iteratorFn) {
                  var iterator = iteratorFn.call(propValue);
                  var step;

                  if (iteratorFn !== propValue.entries) {
                    while (!(step = iterator.next()).done) {
                      if (!isNode(step.value)) {
                        return false;
                      }
                    }
                  } else {
                    // Iterator will provide entry [k,v] tuples rather than values.
                    while (!(step = iterator.next()).done) {
                      var entry = step.value;

                      if (entry) {
                        if (!isNode(entry[1])) {
                          return false;
                        }
                      }
                    }
                  }
                } else {
                  return false;
                }

                return true;

              default:
                return false;
            }
          }

          function isSymbol(propType, propValue) {
            // Native Symbol.
            if (propType === "symbol") {
              return true;
            } // falsy value can't be a Symbol

            if (!propValue) {
              return false;
            } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'

            if (propValue["@@toStringTag"] === "Symbol") {
              return true;
            } // Fallback for non-spec compliant Symbols which are polyfilled.

            if (typeof Symbol === "function" && propValue instanceof Symbol) {
              return true;
            }

            return false;
          } // Equivalent of `typeof` but with special handling for array and regexp.

          function getPropType(propValue) {
            var propType = _typeof(propValue);

            if (Array.isArray(propValue)) {
              return "array";
            }

            if (propValue instanceof RegExp) {
              // Old webkits (at least until Android 4.0) return 'function' rather than
              // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
              // passes PropTypes.object.
              return "object";
            }

            if (isSymbol(propType, propValue)) {
              return "symbol";
            }

            return propType;
          } // This handles more types than `getPropType`. Only used for error messages.
          // See `createPrimitiveTypeChecker`.

          function getPreciseType(propValue) {
            if (typeof propValue === "undefined" || propValue === null) {
              return "" + propValue;
            }

            var propType = getPropType(propValue);

            if (propType === "object") {
              if (propValue instanceof Date) {
                return "date";
              } else if (propValue instanceof RegExp) {
                return "regexp";
              }
            }

            return propType;
          } // Returns a string that is postfixed to a warning about an invalid type.
          // For example, "undefined" or "of type array"

          function getPostfixForTypeWarning(value) {
            var type = getPreciseType(value);

            switch (type) {
              case "array":
              case "object":
                return "an " + type;

              case "boolean":
              case "date":
              case "regexp":
                return "a " + type;

              default:
                return type;
            }
          } // Returns class name of the object, if any.

          function getClassName(propValue) {
            if (!propValue.constructor || !propValue.constructor.name) {
              return ANONYMOUS;
            }

            return propValue.constructor.name;
          }

          ReactPropTypes.checkPropTypes = checkPropTypes;
          ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
          ReactPropTypes.PropTypes = ReactPropTypes;
          return ReactPropTypes;
        };

        /***/
      },

    /***/ "./node_modules/prop-types/index.js":
      /*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        if (true) {
          var ReactIs = __webpack_require__(
            /*! react-is */ "./node_modules/react-is/index.js"
          ); // By explicitly using `prop-types` you are opting into new development behavior.
          // http://fb.me/prop-types-in-prod

          var throwOnDirectAccess = true;
          module.exports = __webpack_require__(
            /*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js"
          )(ReactIs.isElement, throwOnDirectAccess);
        } else {
        }

        /***/
      },

    /***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
      /*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var ReactPropTypesSecret =
          "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module.exports = ReactPropTypesSecret;

        /***/
      },

    /***/ "./node_modules/react-big-calendar/dist/react-big-calendar.esm.js":
      /*!************************************************************************!*\
  !*** ./node_modules/react-big-calendar/dist/react-big-calendar.esm.js ***!
  \************************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js"
        );
        /* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );
        /* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(
          prop_types__WEBPACK_IMPORTED_MODULE_3__
        );
        /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );
        /* harmony import */ var uncontrollable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          /*! uncontrollable */ "./node_modules/uncontrollable/index.js"
        );
        /* harmony import */ var uncontrollable__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __webpack_require__.n(
          uncontrollable__WEBPACK_IMPORTED_MODULE_5__
        );
        /* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          /*! classnames */ "./node_modules/classnames/index.js"
        );
        /* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __webpack_require__.n(
          classnames__WEBPACK_IMPORTED_MODULE_6__
        );
        /* harmony import */ var prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          /*! prop-types-extra/lib/elementType */ "./node_modules/prop-types-extra/lib/elementType.js"
        );
        /* harmony import */ var prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __webpack_require__.n(
          prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7__
        );
        /* harmony import */ var prop_types_extra_lib_all__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          /*! prop-types-extra/lib/all */ "./node_modules/prop-types-extra/lib/all.js"
        );
        /* harmony import */ var prop_types_extra_lib_all__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/ __webpack_require__.n(
          prop_types_extra_lib_all__WEBPACK_IMPORTED_MODULE_8__
        );
        /* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          /*! warning */ "./node_modules/react-big-calendar/node_modules/warning/warning.js"
        );
        /* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/ __webpack_require__.n(
          warning__WEBPACK_IMPORTED_MODULE_9__
        );
        /* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          /*! invariant */ "./node_modules/invariant/browser.js"
        );
        /* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/ __webpack_require__.n(
          invariant__WEBPACK_IMPORTED_MODULE_10__
        );
        /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"
        );
        /* harmony import */ var date_arithmetic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
          /*! date-arithmetic */ "./node_modules/date-arithmetic/index.js"
        );
        /* harmony import */ var date_arithmetic__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/ __webpack_require__.n(
          date_arithmetic__WEBPACK_IMPORTED_MODULE_12__
        );
        /* harmony import */ var lodash_chunk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
          /*! lodash/chunk */ "./node_modules/lodash/chunk.js"
        );
        /* harmony import */ var lodash_chunk__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_chunk__WEBPACK_IMPORTED_MODULE_13__
        );
        /* harmony import */ var dom_helpers_query_position__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
          /*! dom-helpers/query/position */ "./node_modules/dom-helpers/query/position.js"
        );
        /* harmony import */ var dom_helpers_query_position__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_position__WEBPACK_IMPORTED_MODULE_14__
        );
        /* harmony import */ var dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
          /*! dom-helpers/util/requestAnimationFrame */ "./node_modules/dom-helpers/util/requestAnimationFrame.js"
        );
        /* harmony import */ var dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15__
        );
        /* harmony import */ var dom_helpers_query_offset__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
          /*! dom-helpers/query/offset */ "./node_modules/dom-helpers/query/offset.js"
        );
        /* harmony import */ var dom_helpers_query_offset__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_offset__WEBPACK_IMPORTED_MODULE_16__
        );
        /* harmony import */ var dom_helpers_query_scrollTop__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
          /*! dom-helpers/query/scrollTop */ "./node_modules/dom-helpers/query/scrollTop.js"
        );
        /* harmony import */ var dom_helpers_query_scrollTop__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_scrollTop__WEBPACK_IMPORTED_MODULE_17__
        );
        /* harmony import */ var dom_helpers_query_scrollLeft__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
          /*! dom-helpers/query/scrollLeft */ "./node_modules/dom-helpers/query/scrollLeft.js"
        );
        /* harmony import */ var dom_helpers_query_scrollLeft__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_scrollLeft__WEBPACK_IMPORTED_MODULE_18__
        );
        /* harmony import */ var react_overlays_lib_Overlay__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
          /*! react-overlays/lib/Overlay */ "./node_modules/react-overlays/lib/Overlay.js"
        );
        /* harmony import */ var react_overlays_lib_Overlay__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/ __webpack_require__.n(
          react_overlays_lib_Overlay__WEBPACK_IMPORTED_MODULE_19__
        );
        /* harmony import */ var dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
          /*! dom-helpers/query/height */ "./node_modules/dom-helpers/query/height.js"
        );
        /* harmony import */ var dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20__
        );
        /* harmony import */ var dom_helpers_query_querySelectorAll__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
          /*! dom-helpers/query/querySelectorAll */ "./node_modules/dom-helpers/query/querySelectorAll.js"
        );
        /* harmony import */ var dom_helpers_query_querySelectorAll__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_querySelectorAll__WEBPACK_IMPORTED_MODULE_21__
        );
        /* harmony import */ var dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
          /*! dom-helpers/query/contains */ "./node_modules/dom-helpers/query/contains.js"
        );
        /* harmony import */ var dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22__
        );
        /* harmony import */ var dom_helpers_query_closest__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
          /*! dom-helpers/query/closest */ "./node_modules/dom-helpers/query/closest.js"
        );
        /* harmony import */ var dom_helpers_query_closest__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_closest__WEBPACK_IMPORTED_MODULE_23__
        );
        /* harmony import */ var dom_helpers_events__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
          /*! dom-helpers/events */ "./node_modules/dom-helpers/events/index.js"
        );
        /* harmony import */ var dom_helpers_events__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_events__WEBPACK_IMPORTED_MODULE_24__
        );
        /* harmony import */ var lodash_findIndex__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
          /*! lodash/findIndex */ "./node_modules/lodash/findIndex.js"
        );
        /* harmony import */ var lodash_findIndex__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_findIndex__WEBPACK_IMPORTED_MODULE_25__
        );
        /* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
          /*! lodash/range */ "./node_modules/lodash/range.js"
        );
        /* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_range__WEBPACK_IMPORTED_MODULE_26__
        );
        /* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
          /*! memoize-one */ "./node_modules/react-big-calendar/node_modules/memoize-one/dist/memoize-one.esm.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js"
        );
        /* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
          /*! lodash/sortBy */ "./node_modules/lodash/sortBy.js"
        );
        /* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_sortBy__WEBPACK_IMPORTED_MODULE_29__
        );
        /* harmony import */ var dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
          /*! dom-helpers/query/width */ "./node_modules/dom-helpers/query/width.js"
        );
        /* harmony import */ var dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30__
        );
        /* harmony import */ var dom_helpers_util_scrollbarSize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
          /*! dom-helpers/util/scrollbarSize */ "./node_modules/dom-helpers/util/scrollbarSize.js"
        );
        /* harmony import */ var dom_helpers_util_scrollbarSize__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_util_scrollbarSize__WEBPACK_IMPORTED_MODULE_31__
        );
        /* harmony import */ var dom_helpers_class__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
          /*! dom-helpers/class */ "./node_modules/dom-helpers/class/index.js"
        );
        /* harmony import */ var dom_helpers_class__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/ __webpack_require__.n(
          dom_helpers_class__WEBPACK_IMPORTED_MODULE_32__
        );
        /* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
          /*! lodash/omit */ "./node_modules/lodash/omit.js"
        );
        /* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_omit__WEBPACK_IMPORTED_MODULE_33__
        );
        /* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
          /*! lodash/defaults */ "./node_modules/lodash/defaults.js"
        );
        /* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_defaults__WEBPACK_IMPORTED_MODULE_34__
        );
        /* harmony import */ var lodash_transform__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
          /*! lodash/transform */ "./node_modules/lodash/transform.js"
        );
        /* harmony import */ var lodash_transform__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_transform__WEBPACK_IMPORTED_MODULE_35__
        );
        /* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
          /*! lodash/mapValues */ "./node_modules/lodash/mapValues.js"
        );
        /* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/ __webpack_require__.n(
          lodash_mapValues__WEBPACK_IMPORTED_MODULE_36__
        );
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var navigate = {
          PREVIOUS: "PREV",
          NEXT: "NEXT",
          TODAY: "TODAY",
          DATE: "DATE",
        };
        var views = {
          MONTH: "month",
          WEEK: "week",
          WORK_WEEK: "work_week",
          DAY: "day",
          AGENDA: "agenda",
        };
        var eventComponent = prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
          [
            prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
              month:
                prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
              week:
                prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
              day:
                prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
              agenda:
                prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
            }),
          ]
        );
        var viewNames = Object.keys(views).map(function(k) {
          return views[k];
        });
        var accessor = prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
          [
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
          ]
        );
        var dateFormat = prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any;
        var dateRangeFormat =
          prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func;
        /**
         * accepts either an array of builtin view names:
         *
         * ```
         * views={['month', 'day', 'agenda']}
         * ```
         *
         * or an object hash of the view name and the component (or boolean for builtin)
         *
         * ```
         * views={{
         *   month: true,
         *   week: false,
         *   workweek: WorkWeekViewComponent,
         * }}
         * ```
         */

        var views$1 = prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
          [
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(viewNames)
            ),
            prop_types_extra_lib_all__WEBPACK_IMPORTED_MODULE_8___default()(
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              function(props, name) {
                for (
                  var _len = arguments.length,
                    args = new Array(_len > 2 ? _len - 2 : 0),
                    _key = 2;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 2] = arguments[_key];
                }

                var prop = props[name],
                  err;
                Object.keys(prop).every(function(key) {
                  var isBuiltinView =
                    viewNames.indexOf(key) !== -1 &&
                    typeof prop[key] === "boolean";
                  return (
                    isBuiltinView ||
                    !(err = prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a.apply(
                      void 0,
                      [prop, key].concat(args)
                    ))
                  );
                });
                return err || null;
              }
            ),
          ]
        );

        function notify(handler, args) {
          handler && handler.apply(null, [].concat(args));
        }

        var localePropType = prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
          [
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
            prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
          ]
        );

        function _format(localizer, formatter, value, format, culture) {
          var result =
            typeof format === "function"
              ? format(value, culture, localizer)
              : formatter.call(localizer, value, format, culture);
          !(result == null || typeof result === "string")
            ? true
              ? invariant__WEBPACK_IMPORTED_MODULE_10___default()(
                  false,
                  "`localizer format(..)` must return a string, null, or undefined"
                )
              : undefined
            : void 0;
          return result;
        }

        var DateLocalizer = function DateLocalizer(spec) {
          var _this = this;

          !(typeof spec.format === "function")
            ? true
              ? invariant__WEBPACK_IMPORTED_MODULE_10___default()(
                  false,
                  "date localizer `format(..)` must be a function"
                )
              : undefined
            : void 0;
          !(typeof spec.firstOfWeek === "function")
            ? true
              ? invariant__WEBPACK_IMPORTED_MODULE_10___default()(
                  false,
                  "date localizer `firstOfWeek(..)` must be a function"
                )
              : undefined
            : void 0;
          this.propType = spec.propType || localePropType;
          this.startOfWeek = spec.firstOfWeek;
          this.formats = spec.formats;

          this.format = function() {
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            return _format.apply(void 0, [_this, spec.format].concat(args));
          };
        };

        function mergeWithDefaults(
          localizer,
          culture,
          formatOverrides,
          messages
        ) {
          var formats = Object(
            _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
              "default"
            ]
          )({}, localizer.formats, formatOverrides);

          return Object(
            _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
              "default"
            ]
          )({}, localizer, {
            messages: messages,
            startOfWeek: function startOfWeek() {
              return localizer.startOfWeek(culture);
            },
            format: function format(value, _format2) {
              return localizer.format(
                value,
                formats[_format2] || _format2,
                culture
              );
            },
          });
        }

        var defaultMessages = {
          date: "Date",
          time: "Time",
          event: "Event",
          allDay: "All Day",
          week: "Week",
          work_week: "Work Week",
          day: "Day",
          month: "Month",
          previous: "Back",
          next: "Next",
          yesterday: "Yesterday",
          tomorrow: "Tomorrow",
          today: "Today",
          agenda: "Agenda",
          noEventsInRange: "There are no events in this range.",
          showMore: function showMore(total) {
            return "+" + total + " more";
          },
        };

        function messages(msgs) {
          return Object(
            _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
              "default"
            ]
          )({}, defaultMessages, msgs);
        }

        var MILLI = {
          seconds: 1000,
          minutes: 1000 * 60,
          hours: 1000 * 60 * 60,
          day: 1000 * 60 * 60 * 24,
        };
        var MONTHS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

        var dates = Object(
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
            "default"
          ]
        )({}, date_arithmetic__WEBPACK_IMPORTED_MODULE_12___default.a, {
          monthsInYear: function monthsInYear(year) {
            var date = new Date(year, 0, 1);
            return MONTHS.map(function(i) {
              return dates.month(date, i);
            });
          },
          firstVisibleDay: function firstVisibleDay(date, localizer) {
            var firstOfMonth = dates.startOf(date, "month");
            return dates.startOf(firstOfMonth, "week", localizer.startOfWeek());
          },
          lastVisibleDay: function lastVisibleDay(date, localizer) {
            var endOfMonth = dates.endOf(date, "month");
            return dates.endOf(endOfMonth, "week", localizer.startOfWeek());
          },
          visibleDays: function visibleDays(date, localizer) {
            var current = dates.firstVisibleDay(date, localizer),
              last = dates.lastVisibleDay(date, localizer),
              days = [];

            while (dates.lte(current, last, "day")) {
              days.push(current);
              current = dates.add(current, 1, "day");
            }

            return days;
          },
          ceil: function ceil(date, unit) {
            var floor = dates.startOf(date, unit);
            return dates.eq(floor, date) ? floor : dates.add(floor, 1, unit);
          },
          range: function range$$1(start, end, unit) {
            if (unit === void 0) {
              unit = "day";
            }

            var current = start,
              days = [];

            while (dates.lte(current, end, unit)) {
              days.push(current);
              current = dates.add(current, 1, unit);
            }

            return days;
          },
          merge: function merge(date, time) {
            if (time == null && date == null) return null;
            if (time == null) time = new Date();
            if (date == null) date = new Date();
            date = dates.startOf(date, "day");
            date = dates.hours(date, dates.hours(time));
            date = dates.minutes(date, dates.minutes(time));
            date = dates.seconds(date, dates.seconds(time));
            return dates.milliseconds(date, dates.milliseconds(time));
          },
          eqTime: function eqTime(dateA, dateB) {
            return (
              dates.hours(dateA) === dates.hours(dateB) &&
              dates.minutes(dateA) === dates.minutes(dateB) &&
              dates.seconds(dateA) === dates.seconds(dateB)
            );
          },
          isJustDate: function isJustDate(date) {
            return (
              dates.hours(date) === 0 &&
              dates.minutes(date) === 0 &&
              dates.seconds(date) === 0 &&
              dates.milliseconds(date) === 0
            );
          },
          duration: function duration(start, end, unit, firstOfWeek) {
            if (unit === "day") unit = "date";
            return Math.abs(
              dates[unit](start, undefined, firstOfWeek) -
                dates[unit](end, undefined, firstOfWeek)
            );
          },
          diff: function diff(dateA, dateB, unit) {
            if (!unit || unit === "milliseconds")
              return Math.abs(+dateA - +dateB); // the .round() handles an edge case
            // with DST where the total won't be exact
            // since one day in the range may be shorter/longer by an hour

            return Math.round(
              Math.abs(
                +dates.startOf(dateA, unit) / MILLI[unit] -
                  +dates.startOf(dateB, unit) / MILLI[unit]
              )
            );
          },
          total: function total(date, unit) {
            var ms = date.getTime(),
              div = 1;

            switch (unit) {
              case "week":
                div *= 7;

              case "day":
                div *= 24;

              case "hours":
                div *= 60;

              case "minutes":
                div *= 60;

              case "seconds":
                div *= 1000;
            }

            return ms / div;
          },
          week: function week(date) {
            var d = new Date(date);
            d.setHours(0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            return Math.ceil(
              ((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7
            );
          },
          today: function today() {
            return dates.startOf(new Date(), "day");
          },
          yesterday: function yesterday() {
            return dates.add(dates.startOf(new Date(), "day"), -1, "day");
          },
          tomorrow: function tomorrow() {
            return dates.add(dates.startOf(new Date(), "day"), 1, "day");
          },
        });

        var EventCell =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(EventCell, _React$Component);

            function EventCell() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = EventCell.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                style = _this$props.style,
                className = _this$props.className,
                event = _this$props.event,
                selected = _this$props.selected,
                isAllDay = _this$props.isAllDay,
                onSelect = _this$props.onSelect,
                _onDoubleClick = _this$props.onDoubleClick,
                localizer = _this$props.localizer,
                continuesPrior = _this$props.continuesPrior,
                continuesAfter = _this$props.continuesAfter,
                accessors = _this$props.accessors,
                getters = _this$props.getters,
                children = _this$props.children,
                _this$props$component = _this$props.components,
                Event = _this$props$component.event,
                EventWrapper = _this$props$component.eventWrapper,
                props = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props, [
                  "style",
                  "className",
                  "event",
                  "selected",
                  "isAllDay",
                  "onSelect",
                  "onDoubleClick",
                  "localizer",
                  "continuesPrior",
                  "continuesAfter",
                  "accessors",
                  "getters",
                  "children",
                  "components",
                ]);

              var title = accessors.title(event);
              var tooltip = accessors.tooltip(event);
              var end = accessors.end(event);
              var start = accessors.start(event);
              var allDay = accessors.allDay(event);
              var showAsAllDay =
                isAllDay ||
                allDay ||
                dates.diff(start, dates.ceil(end, "day"), "day") > 1;
              var userProps = getters.eventProp(event, start, end, selected);
              var content = react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-event-content",
                  title: tooltip || undefined,
                },
                Event
                  ? react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      Event,
                      {
                        event: event,
                        title: title,
                        isAllDay: allDay,
                        localizer: localizer,
                      }
                    )
                  : title
              );
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                EventWrapper,
                Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )({}, this.props, {
                  type: "date",
                }),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )({}, props, {
                    tabIndex: 0,
                    style: Object(
                      _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                        "default"
                      ]
                    )({}, userProps.style, style),
                    className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                      "rbc-event",
                      className,
                      userProps.className,
                      {
                        "rbc-selected": selected,
                        "rbc-event-allday": showAsAllDay,
                        "rbc-event-continues-prior": continuesPrior,
                        "rbc-event-continues-after": continuesAfter,
                      }
                    ),
                    onClick: function onClick(e) {
                      return onSelect && onSelect(event, e);
                    },
                    onDoubleClick: function onDoubleClick(e) {
                      return _onDoubleClick && _onDoubleClick(event, e);
                    },
                  }),
                  typeof children === "function" ? children(content) : content
                )
              );
            };

            return EventCell;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        EventCell.propTypes = true
          ? {
              event:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              slotStart: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              slotEnd: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              selected: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              isAllDay: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              continuesPrior:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              continuesAfter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              onSelect: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClick:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
            }
          : undefined;

        function isSelected(event, selected) {
          if (!event || selected == null) return false;
          return [].concat(selected).indexOf(event) !== -1;
        }

        function slotWidth(rowBox, slots) {
          var rowWidth = rowBox.right - rowBox.left;
          var cellWidth = rowWidth / slots;
          return cellWidth;
        }

        function getSlotAtX(rowBox, x, rtl, slots) {
          var cellWidth = slotWidth(rowBox, slots);
          return rtl
            ? slots - 1 - Math.floor((x - rowBox.left) / cellWidth)
            : Math.floor((x - rowBox.left) / cellWidth);
        }

        function pointInBox(box, _ref) {
          var x = _ref.x,
            y = _ref.y;
          return (
            y >= box.top && y <= box.bottom && x >= box.left && x <= box.right
          );
        }

        function dateCellSelection(start, rowBox, box, slots, rtl) {
          var startIdx = -1;
          var endIdx = -1;
          var lastSlotIdx = slots - 1;
          var cellWidth = slotWidth(rowBox, slots); // cell under the mouse

          var currentSlot = getSlotAtX(rowBox, box.x, rtl, slots); // Identify row as either the initial row
          // or the row under the current mouse point

          var isCurrentRow = rowBox.top < box.y && rowBox.bottom > box.y;
          var isStartRow = rowBox.top < start.y && rowBox.bottom > start.y; // this row's position relative to the start point

          var isAboveStart = start.y > rowBox.bottom;
          var isBelowStart = rowBox.top > start.y;
          var isBetween = box.top < rowBox.top && box.bottom > rowBox.bottom; // this row is between the current and start rows, so entirely selected

          if (isBetween) {
            startIdx = 0;
            endIdx = lastSlotIdx;
          }

          if (isCurrentRow) {
            if (isBelowStart) {
              startIdx = 0;
              endIdx = currentSlot;
            } else if (isAboveStart) {
              startIdx = currentSlot;
              endIdx = lastSlotIdx;
            }
          }

          if (isStartRow) {
            // select the cell under the initial point
            startIdx = endIdx = rtl
              ? lastSlotIdx - Math.floor((start.x - rowBox.left) / cellWidth)
              : Math.floor((start.x - rowBox.left) / cellWidth);

            if (isCurrentRow) {
              if (currentSlot < startIdx) startIdx = currentSlot;
              else endIdx = currentSlot; //select current range
            } else if (start.y < box.y) {
              // the current row is below start row
              // select cells to the right of the start cell
              endIdx = lastSlotIdx;
            } else {
              // select cells to the left of the start cell
              startIdx = 0;
            }
          }

          return {
            startIdx: startIdx,
            endIdx: endIdx,
          };
        }

        var Popup =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Popup, _React$Component);

            function Popup() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = Popup.prototype;

            _proto.componentDidMount = function componentDidMount() {
              var _this$props$popupOffs = this.props.popupOffset,
                popupOffset =
                  _this$props$popupOffs === void 0 ? 5 : _this$props$popupOffs,
                _getOffset = dom_helpers_query_offset__WEBPACK_IMPORTED_MODULE_16___default()(
                  this.refs.root
                ),
                top = _getOffset.top,
                left = _getOffset.left,
                width = _getOffset.width,
                height = _getOffset.height,
                viewBottom =
                  window.innerHeight +
                  dom_helpers_query_scrollTop__WEBPACK_IMPORTED_MODULE_17___default()(
                    window
                  ),
                viewRight =
                  window.innerWidth +
                  dom_helpers_query_scrollLeft__WEBPACK_IMPORTED_MODULE_18___default()(
                    window
                  ),
                bottom = top + height,
                right = left + width;

              if (bottom > viewBottom || right > viewRight) {
                var topOffset, leftOffset;
                if (bottom > viewBottom)
                  topOffset =
                    bottom - viewBottom + (popupOffset.y || +popupOffset || 0);
                if (right > viewRight)
                  leftOffset =
                    right - viewRight + (popupOffset.x || +popupOffset || 0);
                this.setState({
                  topOffset: topOffset,
                  leftOffset: leftOffset,
                }); //eslint-disable-line
              }
            };

            _proto.render = function render() {
              var _this$props = this.props,
                events$$1 = _this$props.events,
                selected = _this$props.selected,
                getters = _this$props.getters,
                accessors = _this$props.accessors,
                components = _this$props.components,
                onSelect = _this$props.onSelect,
                onDoubleClick = _this$props.onDoubleClick,
                slotStart = _this$props.slotStart,
                slotEnd = _this$props.slotEnd,
                localizer = _this$props.localizer;
              var _this$props$position = this.props.position,
                left = _this$props$position.left,
                width = _this$props$position.width,
                top = _this$props$position.top,
                topOffset = (this.state || {}).topOffset || 0,
                leftOffset = (this.state || {}).leftOffset || 0;
              var style = {
                top: Math.max(0, top - topOffset),
                left: left - leftOffset,
                minWidth: width + width / 2,
              };
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  ref: "root",
                  style: style,
                  className: "rbc-overlay",
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  {
                    className: "rbc-overlay-header",
                  },
                  localizer.format(slotStart, "dayHeaderFormat")
                ),
                events$$1.map(function(event, idx) {
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(EventCell, {
                    key: idx,
                    type: "popup",
                    event: event,
                    getters: getters,
                    onSelect: onSelect,
                    accessors: accessors,
                    components: components,
                    onDoubleClick: onDoubleClick,
                    continuesPrior: dates.lt(
                      accessors.end(event),
                      slotStart,
                      "day"
                    ),
                    continuesAfter: dates.gte(
                      accessors.start(event),
                      slotEnd,
                      "day"
                    ),
                    selected: isSelected(event, selected),
                  });
                })
              );
            };

            return Popup;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Popup.propTypes = true
          ? {
              position:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              popupOffset: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
                [
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
                    x: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                    y: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  }),
                ]
              ),
              events: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              onSelect: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClick:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              slotStart: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              slotEnd: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
            }
          : undefined;

        function addEventListener(type, handler, target) {
          if (target === void 0) {
            target = document;
          }

          dom_helpers_events__WEBPACK_IMPORTED_MODULE_24___default.a.on(
            target,
            type,
            handler,
            {
              passive: false,
            }
          );
          return {
            remove: function remove() {
              dom_helpers_events__WEBPACK_IMPORTED_MODULE_24___default.a.off(
                target,
                type,
                handler
              );
            },
          };
        }

        function isOverContainer(container, x, y) {
          return (
            !container ||
            dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22___default()(
              container,
              document.elementFromPoint(x, y)
            )
          );
        }

        function getEventNodeFromPoint(node, _ref) {
          var clientX = _ref.clientX,
            clientY = _ref.clientY;
          var target = document.elementFromPoint(clientX, clientY);
          return dom_helpers_query_closest__WEBPACK_IMPORTED_MODULE_23___default()(
            target,
            ".rbc-event",
            node
          );
        }

        function isEvent(node, bounds) {
          return !!getEventNodeFromPoint(node, bounds);
        }

        function getEventCoordinates(e) {
          var target = e;

          if (e.touches && e.touches.length) {
            target = e.touches[0];
          }

          return {
            clientX: target.clientX,
            clientY: target.clientY,
            pageX: target.pageX,
            pageY: target.pageY,
          };
        }

        var clickTolerance = 5;
        var clickInterval = 250;

        var Selection =
          /*#__PURE__*/
          (function() {
            function Selection(node, _temp) {
              var _ref2 = _temp === void 0 ? {} : _temp,
                _ref2$global = _ref2.global,
                global = _ref2$global === void 0 ? false : _ref2$global,
                _ref2$longPressThresh = _ref2.longPressThreshold,
                longPressThreshold =
                  _ref2$longPressThresh === void 0
                    ? 250
                    : _ref2$longPressThresh;

              this.container = node;
              this.globalMouse = !node || global;
              this.longPressThreshold = longPressThreshold;
              this._listeners = Object.create(null);
              this._handleInitialEvent = this._handleInitialEvent.bind(this);
              this._handleMoveEvent = this._handleMoveEvent.bind(this);
              this._handleTerminatingEvent = this._handleTerminatingEvent.bind(
                this
              );
              this._keyListener = this._keyListener.bind(this); // Fixes an iOS 10 bug where scrolling could not be prevented on the window.
              // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356

              this._onTouchMoveWindowListener = addEventListener(
                "touchmove",
                function() {},
                window
              );
              this._onKeyDownListener = addEventListener(
                "keydown",
                this._keyListener
              );
              this._onKeyUpListener = addEventListener(
                "keyup",
                this._keyListener
              );

              this._addInitialEventListener();
            }

            var _proto = Selection.prototype;

            _proto.on = function on(type, handler) {
              var handlers =
                this._listeners[type] || (this._listeners[type] = []);
              handlers.push(handler);
              return {
                remove: function remove() {
                  var idx = handlers.indexOf(handler);
                  if (idx !== -1) handlers.splice(idx, 1);
                },
              };
            };

            _proto.emit = function emit(type) {
              for (
                var _len = arguments.length,
                  args = new Array(_len > 1 ? _len - 1 : 0),
                  _key = 1;
                _key < _len;
                _key++
              ) {
                args[_key - 1] = arguments[_key];
              }

              var result;
              var handlers = this._listeners[type] || [];
              handlers.forEach(function(fn) {
                if (result === undefined) result = fn.apply(void 0, args);
              });
              return result;
            };

            _proto.teardown = function teardown() {
              this.listeners = Object.create(null);
              this._onTouchMoveWindowListener &&
                this._onTouchMoveWindowListener.remove();
              this._onInitialEventListener &&
                this._onInitialEventListener.remove();
              this._onEndListener && this._onEndListener.remove();
              this._onEscListener && this._onEscListener.remove();
              this._onMoveListener && this._onMoveListener.remove();
              this._onKeyUpListener && this._onKeyUpListener.remove();
              this._onKeyDownListener && this._onKeyDownListener.remove();
            };

            _proto.isSelected = function isSelected(node) {
              var box = this._selectRect;
              if (!box || !this.selecting) return false;
              return objectsCollide(box, getBoundsForNode(node));
            };

            _proto.filter = function filter(items) {
              var box = this._selectRect; //not selecting

              if (!box || !this.selecting) return [];
              return items.filter(this.isSelected, this);
            }; // Adds a listener that will call the handler only after the user has pressed on the screen
            // without moving their finger for 250ms.

            _proto._addLongPressListener = function _addLongPressListener(
              handler,
              initialEvent
            ) {
              var _this = this;

              var timer = null;
              var touchMoveListener = null;
              var touchEndListener = null;

              var handleTouchStart = function handleTouchStart(initialEvent) {
                timer = setTimeout(function() {
                  cleanup();
                  handler(initialEvent);
                }, _this.longPressThreshold);
                touchMoveListener = addEventListener("touchmove", function() {
                  return cleanup();
                });
                touchEndListener = addEventListener("touchend", function() {
                  return cleanup();
                });
              };

              var touchStartListener = addEventListener(
                "touchstart",
                handleTouchStart
              );

              var cleanup = function cleanup() {
                if (timer) {
                  clearTimeout(timer);
                }

                if (touchMoveListener) {
                  touchMoveListener.remove();
                }

                if (touchEndListener) {
                  touchEndListener.remove();
                }

                timer = null;
                touchMoveListener = null;
                touchEndListener = null;
              };

              if (initialEvent) {
                handleTouchStart(initialEvent);
              }

              return {
                remove: function remove() {
                  cleanup();
                  touchStartListener.remove();
                },
              };
            }; // Listen for mousedown and touchstart events. When one is received, disable the other and setup
            // future event handling based on the type of event.

            _proto._addInitialEventListener = function _addInitialEventListener() {
              var _this2 = this;

              var mouseDownListener = addEventListener("mousedown", function(
                e
              ) {
                _this2._onInitialEventListener.remove();

                _this2._handleInitialEvent(e);

                _this2._onInitialEventListener = addEventListener(
                  "mousedown",
                  _this2._handleInitialEvent
                );
              });
              var touchStartListener = addEventListener("touchstart", function(
                e
              ) {
                _this2._onInitialEventListener.remove();

                _this2._onInitialEventListener = _this2._addLongPressListener(
                  _this2._handleInitialEvent,
                  e
                );
              });
              this._onInitialEventListener = {
                remove: function remove() {
                  mouseDownListener.remove();
                  touchStartListener.remove();
                },
              };
            };

            _proto._handleInitialEvent = function _handleInitialEvent(e) {
              var _getEventCoordinates = getEventCoordinates(e),
                clientX = _getEventCoordinates.clientX,
                clientY = _getEventCoordinates.clientY,
                pageX = _getEventCoordinates.pageX,
                pageY = _getEventCoordinates.pageY;

              var node = this.container(),
                collides,
                offsetData; // Right clicks

              if (
                e.which === 3 ||
                e.button === 2 ||
                !isOverContainer(node, clientX, clientY)
              )
                return;

              if (
                !this.globalMouse &&
                node &&
                !dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22___default()(
                  node,
                  e.target
                )
              ) {
                var _normalizeDistance = normalizeDistance(0),
                  top = _normalizeDistance.top,
                  left = _normalizeDistance.left,
                  bottom = _normalizeDistance.bottom,
                  right = _normalizeDistance.right;

                offsetData = getBoundsForNode(node);
                collides = objectsCollide(
                  {
                    top: offsetData.top - top,
                    left: offsetData.left - left,
                    bottom: offsetData.bottom + bottom,
                    right: offsetData.right + right,
                  },
                  {
                    top: pageY,
                    left: pageX,
                  }
                );
                if (!collides) return;
              }

              var result = this.emit(
                "beforeSelect",
                (this._initialEventData = {
                  isTouch: /^touch/.test(e.type),
                  x: pageX,
                  y: pageY,
                  clientX: clientX,
                  clientY: clientY,
                })
              );
              if (result === false) return;

              switch (e.type) {
                case "mousedown":
                  this._onEndListener = addEventListener(
                    "mouseup",
                    this._handleTerminatingEvent
                  );
                  this._onEscListener = addEventListener(
                    "keydown",
                    this._handleTerminatingEvent
                  );
                  this._onMoveListener = addEventListener(
                    "mousemove",
                    this._handleMoveEvent
                  );
                  break;

                case "touchstart":
                  this._handleMoveEvent(e);

                  this._onEndListener = addEventListener(
                    "touchend",
                    this._handleTerminatingEvent
                  );
                  this._onMoveListener = addEventListener(
                    "touchmove",
                    this._handleMoveEvent
                  );
                  break;

                default:
                  break;
              }
            };

            _proto._handleTerminatingEvent = function _handleTerminatingEvent(
              e
            ) {
              var _getEventCoordinates2 = getEventCoordinates(e),
                pageX = _getEventCoordinates2.pageX,
                pageY = _getEventCoordinates2.pageY;

              this.selecting = false;
              this._onEndListener && this._onEndListener.remove();
              this._onMoveListener && this._onMoveListener.remove();
              if (!this._initialEventData) return;
              var inRoot =
                !this.container ||
                dom_helpers_query_contains__WEBPACK_IMPORTED_MODULE_22___default()(
                  this.container(),
                  e.target
                );
              var bounds = this._selectRect;
              var click = this.isClick(pageX, pageY);
              this._initialEventData = null;

              if (e.key === "Escape") {
                return this.emit("reset");
              }

              if (!inRoot) {
                return this.emit("reset");
              }

              if (click && inRoot) {
                return this._handleClickEvent(e);
              } // User drag-clicked in the Selectable area

              if (!click) return this.emit("select", bounds);
            };

            _proto._handleClickEvent = function _handleClickEvent(e) {
              var _getEventCoordinates3 = getEventCoordinates(e),
                pageX = _getEventCoordinates3.pageX,
                pageY = _getEventCoordinates3.pageY,
                clientX = _getEventCoordinates3.clientX,
                clientY = _getEventCoordinates3.clientY;

              var now = new Date().getTime();

              if (
                this._lastClickData &&
                now - this._lastClickData.timestamp < clickInterval
              ) {
                // Double click event
                this._lastClickData = null;
                return this.emit("doubleClick", {
                  x: pageX,
                  y: pageY,
                  clientX: clientX,
                  clientY: clientY,
                });
              } // Click event

              this._lastClickData = {
                timestamp: now,
              };
              return this.emit("click", {
                x: pageX,
                y: pageY,
                clientX: clientX,
                clientY: clientY,
              });
            };

            _proto._handleMoveEvent = function _handleMoveEvent(e) {
              if (this._initialEventData === null) {
                return;
              }

              var _this$_initialEventDa = this._initialEventData,
                x = _this$_initialEventDa.x,
                y = _this$_initialEventDa.y;

              var _getEventCoordinates4 = getEventCoordinates(e),
                pageX = _getEventCoordinates4.pageX,
                pageY = _getEventCoordinates4.pageY;

              var w = Math.abs(x - pageX);
              var h = Math.abs(y - pageY);
              var left = Math.min(pageX, x),
                top = Math.min(pageY, y),
                old = this.selecting; // Prevent emitting selectStart event until mouse is moved.
              // in Chrome on Windows, mouseMove event may be fired just after mouseDown event.

              if (this.isClick(pageX, pageY) && !old && !(w || h)) {
                return;
              }

              this.selecting = true;
              this._selectRect = {
                top: top,
                left: left,
                x: pageX,
                y: pageY,
                right: left + w,
                bottom: top + h,
              };

              if (!old) {
                this.emit("selectStart", this._initialEventData);
              }

              if (!this.isClick(pageX, pageY))
                this.emit("selecting", this._selectRect);
              e.preventDefault();
            };

            _proto._keyListener = function _keyListener(e) {
              this.ctrl = e.metaKey || e.ctrlKey;
            };

            _proto.isClick = function isClick(pageX, pageY) {
              var _this$_initialEventDa2 = this._initialEventData,
                x = _this$_initialEventDa2.x,
                y = _this$_initialEventDa2.y,
                isTouch = _this$_initialEventDa2.isTouch;
              return (
                !isTouch &&
                Math.abs(pageX - x) <= clickTolerance &&
                Math.abs(pageY - y) <= clickTolerance
              );
            };

            return Selection;
          })();
        /**
         * Resolve the disance prop from either an Int or an Object
         * @return {Object}
         */

        function normalizeDistance(distance) {
          if (distance === void 0) {
            distance = 0;
          }

          if (_typeof(distance) !== "object")
            distance = {
              top: distance,
              left: distance,
              right: distance,
              bottom: distance,
            };
          return distance;
        }
        /**
         * Given two objects containing "top", "left", "offsetWidth" and "offsetHeight"
         * properties, determine if they collide.
         * @param  {Object|HTMLElement} a
         * @param  {Object|HTMLElement} b
         * @return {bool}
         */

        function objectsCollide(nodeA, nodeB, tolerance) {
          if (tolerance === void 0) {
            tolerance = 0;
          }

          var _getBoundsForNode = getBoundsForNode(nodeA),
            aTop = _getBoundsForNode.top,
            aLeft = _getBoundsForNode.left,
            _getBoundsForNode$rig = _getBoundsForNode.right,
            aRight =
              _getBoundsForNode$rig === void 0 ? aLeft : _getBoundsForNode$rig,
            _getBoundsForNode$bot = _getBoundsForNode.bottom,
            aBottom =
              _getBoundsForNode$bot === void 0 ? aTop : _getBoundsForNode$bot;

          var _getBoundsForNode2 = getBoundsForNode(nodeB),
            bTop = _getBoundsForNode2.top,
            bLeft = _getBoundsForNode2.left,
            _getBoundsForNode2$ri = _getBoundsForNode2.right,
            bRight =
              _getBoundsForNode2$ri === void 0 ? bLeft : _getBoundsForNode2$ri,
            _getBoundsForNode2$bo = _getBoundsForNode2.bottom,
            bBottom =
              _getBoundsForNode2$bo === void 0 ? bTop : _getBoundsForNode2$bo;

          return !// 'a' bottom doesn't touch 'b' top
          (
            aBottom - tolerance < bTop || // 'a' top doesn't touch 'b' bottom
            aTop + tolerance > bBottom || // 'a' right doesn't touch 'b' left
            aRight - tolerance < bLeft || // 'a' left doesn't touch 'b' right
            aLeft + tolerance > bRight
          );
        }
        /**
         * Given a node, get everything needed to calculate its boundaries
         * @param  {HTMLElement} node
         * @return {Object}
         */

        function getBoundsForNode(node) {
          if (!node.getBoundingClientRect) return node;
          var rect = node.getBoundingClientRect(),
            left = rect.left + pageOffset("left"),
            top = rect.top + pageOffset("top");
          return {
            top: top,
            left: left,
            right: (node.offsetWidth || 0) + left,
            bottom: (node.offsetHeight || 0) + top,
          };
        }

        function pageOffset(dir) {
          if (dir === "left")
            return window.pageXOffset || document.body.scrollLeft || 0;
          if (dir === "top")
            return window.pageYOffset || document.body.scrollTop || 0;
        }

        var BackgroundCells =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(BackgroundCells, _React$Component);

            function BackgroundCells(props, context) {
              var _this;

              _this = _React$Component.call(this, props, context) || this;
              _this.state = {
                selecting: false,
              };
              return _this;
            }

            var _proto = BackgroundCells.prototype;

            _proto.componentDidMount = function componentDidMount() {
              this.props.selectable && this._selectable();
            };

            _proto.componentWillUnmount = function componentWillUnmount() {
              this._teardownSelectable();
            };

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              if (nextProps.selectable && !this.props.selectable)
                this._selectable();
              if (!nextProps.selectable && this.props.selectable)
                this._teardownSelectable();
            };

            _proto.render = function render() {
              var _this$props = this.props,
                range$$1 = _this$props.range,
                getNow = _this$props.getNow,
                getters = _this$props.getters,
                currentDate = _this$props.date,
                Wrapper = _this$props.components.dateCellWrapper;
              var _this$state = this.state,
                selecting = _this$state.selecting,
                startIdx = _this$state.startIdx,
                endIdx = _this$state.endIdx;
              var current = getNow();
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-row-bg",
                },
                range$$1.map(function(date, index) {
                  var selected =
                    selecting && index >= startIdx && index <= endIdx;

                  var _getters$dayProp = getters.dayProp(date),
                    className = _getters$dayProp.className,
                    style = _getters$dayProp.style;

                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    Wrapper,
                    {
                      key: index,
                      value: date,
                      range: range$$1,
                    },
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "div",
                      {
                        style: style,
                        className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                          "rbc-day-bg",
                          className,
                          selected && "rbc-selected-cell",
                          dates.eq(date, current, "day") && "rbc-today",
                          currentDate &&
                            dates.month(currentDate) !== dates.month(date) &&
                            "rbc-off-range-bg"
                        ),
                      }
                    )
                  );
                })
              );
            };

            _proto._selectable = function _selectable() {
              var _this2 = this;

              var node = Object(
                react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"]
              )(this);
              var selector = (this._selector = new Selection(
                this.props.container,
                {
                  longPressThreshold: this.props.longPressThreshold,
                }
              ));

              var selectorClicksHandler = function selectorClicksHandler(
                point,
                actionType
              ) {
                if (
                  !isEvent(
                    Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                      _this2
                    ),
                    point
                  )
                ) {
                  var rowBox = getBoundsForNode(node);
                  var _this2$props = _this2.props,
                    range$$1 = _this2$props.range,
                    rtl = _this2$props.rtl;

                  if (pointInBox(rowBox, point)) {
                    var currentCell = getSlotAtX(
                      rowBox,
                      point.x,
                      rtl,
                      range$$1.length
                    );

                    _this2._selectSlot({
                      startIdx: currentCell,
                      endIdx: currentCell,
                      action: actionType,
                      box: point,
                    });
                  }
                }

                _this2._initial = {};

                _this2.setState({
                  selecting: false,
                });
              };

              selector.on("selecting", function(box) {
                var _this2$props2 = _this2.props,
                  range$$1 = _this2$props2.range,
                  rtl = _this2$props2.rtl;
                var startIdx = -1;
                var endIdx = -1;

                if (!_this2.state.selecting) {
                  notify(_this2.props.onSelectStart, [box]);
                  _this2._initial = {
                    x: box.x,
                    y: box.y,
                  };
                }

                if (selector.isSelected(node)) {
                  var nodeBox = getBoundsForNode(node);

                  var _dateCellSelection = dateCellSelection(
                    _this2._initial,
                    nodeBox,
                    box,
                    range$$1.length,
                    rtl
                  );

                  startIdx = _dateCellSelection.startIdx;
                  endIdx = _dateCellSelection.endIdx;
                }

                _this2.setState({
                  selecting: true,
                  startIdx: startIdx,
                  endIdx: endIdx,
                });
              });
              selector.on("beforeSelect", function(box) {
                if (_this2.props.selectable !== "ignoreEvents") return;
                return !isEvent(
                  Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                    _this2
                  ),
                  box
                );
              });
              selector.on("click", function(point) {
                return selectorClicksHandler(point, "click");
              });
              selector.on("doubleClick", function(point) {
                return selectorClicksHandler(point, "doubleClick");
              });
              selector.on("select", function(bounds) {
                _this2._selectSlot(
                  Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )({}, _this2.state, {
                    action: "select",
                    bounds: bounds,
                  })
                );

                _this2._initial = {};

                _this2.setState({
                  selecting: false,
                });

                notify(_this2.props.onSelectEnd, [_this2.state]);
              });
            };

            _proto._teardownSelectable = function _teardownSelectable() {
              if (!this._selector) return;

              this._selector.teardown();

              this._selector = null;
            };

            _proto._selectSlot = function _selectSlot(_ref) {
              var endIdx = _ref.endIdx,
                startIdx = _ref.startIdx,
                action = _ref.action,
                bounds = _ref.bounds,
                box = _ref.box;
              if (endIdx !== -1 && startIdx !== -1)
                this.props.onSelectSlot &&
                  this.props.onSelectSlot({
                    start: startIdx,
                    end: endIdx,
                    action: action,
                    bounds: bounds,
                    box: box,
                  });
            };

            return BackgroundCells;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        BackgroundCells.propTypes = true
          ? {
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              container: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              dayPropGetter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              onSelectEnd:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectStart:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              range: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                  Date
                )
              ),
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              type: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
            }
          : undefined;
        /* eslint-disable react/prop-types */

        var EventRowMixin = {
          propTypes: {
            slotMetrics:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                .isRequired,
            selected: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
            isAllDay: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
            accessors:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                .isRequired,
            localizer:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                .isRequired,
            components:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                .isRequired,
            getters:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                .isRequired,
            onSelect: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
            onDoubleClick:
              prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
          },
          defaultProps: {
            segments: [],
            selected: {},
          },
          renderEvent: function renderEvent(props, event) {
            var selected = props.selected,
              _ = props.isAllDay,
              accessors = props.accessors,
              getters = props.getters,
              onSelect = props.onSelect,
              onDoubleClick = props.onDoubleClick,
              localizer = props.localizer,
              slotMetrics = props.slotMetrics,
              components = props.components;
            var continuesPrior = slotMetrics.continuesPrior(event);
            var continuesAfter = slotMetrics.continuesAfter(event);
            return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              EventCell,
              {
                event: event,
                getters: getters,
                localizer: localizer,
                accessors: accessors,
                components: components,
                onSelect: onSelect,
                onDoubleClick: onDoubleClick,
                continuesPrior: continuesPrior,
                continuesAfter: continuesAfter,
                selected: isSelected(event, selected),
              }
            );
          },
          renderSpan: function renderSpan(slots, len, key, content) {
            if (content === void 0) {
              content = " ";
            }

            var per = (Math.abs(len) / slots) * 100 + "%";
            return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              "div",
              {
                key: key,
                className: "rbc-row-segment", // IE10/11 need max-width. flex-basis doesn't respect box-sizing
                style: {
                  WebkitFlexBasis: per,
                  flexBasis: per,
                  maxWidth: per,
                },
              },
              content
            );
          },
        };

        var EventRow =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(EventRow, _React$Component);

            function EventRow() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = EventRow.prototype;

            _proto.render = function render() {
              var _this = this;

              var _this$props = this.props,
                segments = _this$props.segments,
                slots = _this$props.slotMetrics.slots,
                className = _this$props.className;
              var lastEnd = 1;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    className,
                    "rbc-row"
                  ),
                },
                segments.reduce(function(row, _ref, li) {
                  var event = _ref.event,
                    left = _ref.left,
                    right = _ref.right,
                    span = _ref.span;
                  var key = "_lvl_" + li;
                  var gap = left - lastEnd;
                  var content = EventRowMixin.renderEvent(_this.props, event);
                  if (gap)
                    row.push(
                      EventRowMixin.renderSpan(slots, gap, key + "_gap")
                    );
                  row.push(EventRowMixin.renderSpan(slots, span, key, content));
                  lastEnd = right + 1;
                  return row;
                }, [])
              );
            };

            return EventRow;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        EventRow.propTypes = true
          ? Object(
              _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                "default"
              ]
            )(
              {
                segments:
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array,
              },
              EventRowMixin.propTypes
            )
          : undefined;
        EventRow.defaultProps = Object(
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
            "default"
          ]
        )({}, EventRowMixin.defaultProps);

        function endOfRange(dateRange, unit) {
          if (unit === void 0) {
            unit = "day";
          }

          return {
            first: dateRange[0],
            last: dates.add(dateRange[dateRange.length - 1], 1, unit),
          };
        }

        function eventSegments(event, range$$1, accessors) {
          var _endOfRange = endOfRange(range$$1),
            first = _endOfRange.first,
            last = _endOfRange.last;

          var slots = dates.diff(first, last, "day");
          var start = dates.max(
            dates.startOf(accessors.start(event), "day"),
            first
          );
          var end = dates.min(dates.ceil(accessors.end(event), "day"), last);
          var padding = lodash_findIndex__WEBPACK_IMPORTED_MODULE_25___default()(
            range$$1,
            function(x) {
              return dates.eq(x, start, "day");
            }
          );
          var span = dates.diff(start, end, "day");
          span = Math.min(span, slots);
          span = Math.max(span, 1);
          return {
            event: event,
            span: span,
            left: padding + 1,
            right: Math.max(padding + span, 1),
          };
        }

        function eventLevels(rowSegments, limit) {
          if (limit === void 0) {
            limit = Infinity;
          }

          var i,
            j,
            seg,
            levels = [],
            extra = [];

          for (i = 0; i < rowSegments.length; i++) {
            seg = rowSegments[i];

            for (j = 0; j < levels.length; j++) {
              if (!segsOverlap(seg, levels[j])) break;
            }

            if (j >= limit) {
              extra.push(seg);
            } else {
              (levels[j] || (levels[j] = [])).push(seg);
            }
          }

          for (i = 0; i < levels.length; i++) {
            levels[i].sort(function(a, b) {
              return a.left - b.left;
            }); //eslint-disable-line
          }

          return {
            levels: levels,
            extra: extra,
          };
        }

        function inRange(e, start, end, accessors) {
          var eStart = dates.startOf(accessors.start(e), "day");
          var eEnd = accessors.end(e);
          var startsBeforeEnd = dates.lte(eStart, end, "day"); // when the event is zero duration we need to handle a bit differently

          var endsAfterStart = !dates.eq(eStart, eEnd, "minutes")
            ? dates.gt(eEnd, start, "minutes")
            : dates.gte(eEnd, start, "minutes");
          return startsBeforeEnd && endsAfterStart;
        }

        function segsOverlap(seg, otherSegs) {
          return otherSegs.some(function(otherSeg) {
            return otherSeg.left <= seg.right && otherSeg.right >= seg.left;
          });
        }

        function sortEvents(evtA, evtB, accessors) {
          var startSort =
            +dates.startOf(accessors.start(evtA), "day") -
            +dates.startOf(accessors.start(evtB), "day");
          var durA = dates.diff(
            accessors.start(evtA),
            dates.ceil(accessors.end(evtA), "day"),
            "day"
          );
          var durB = dates.diff(
            accessors.start(evtB),
            dates.ceil(accessors.end(evtB), "day"),
            "day"
          );
          return (
            startSort || // sort by start Day first
            Math.max(durB, 1) - Math.max(durA, 1) || // events spanning multiple days go first
            !!accessors.allDay(evtB) - !!accessors.allDay(evtA) || // then allDay single day events
            +accessors.start(evtA) - +accessors.start(evtB)
          ); // then sort by start time
        }

        var isSegmentInSlot = function isSegmentInSlot(seg, slot) {
          return seg.left <= slot && seg.right >= slot;
        };

        var eventsInSlot = function eventsInSlot(segments, slot) {
          return segments.filter(function(seg) {
            return isSegmentInSlot(seg, slot);
          }).length;
        };

        var EventEndingRow =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(EventEndingRow, _React$Component);

            function EventEndingRow() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = EventEndingRow.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                segments = _this$props.segments,
                slots = _this$props.slotMetrics.slots;
              var rowSegments = eventLevels(segments).levels[0];
              var current = 1,
                lastEnd = 1,
                row = [];

              while (current <= slots) {
                var key = "_lvl_" + current;

                var _ref =
                    rowSegments.filter(function(seg) {
                      return isSegmentInSlot(seg, current);
                    })[0] || {},
                  event = _ref.event,
                  left = _ref.left,
                  right = _ref.right,
                  span = _ref.span; //eslint-disable-line

                if (!event) {
                  current++;
                  continue;
                }

                var gap = Math.max(0, left - lastEnd);

                if (this.canRenderSlotEvent(left, span)) {
                  var content = EventRowMixin.renderEvent(this.props, event);

                  if (gap) {
                    row.push(
                      EventRowMixin.renderSpan(slots, gap, key + "_gap")
                    );
                  }

                  row.push(EventRowMixin.renderSpan(slots, span, key, content));
                  lastEnd = current = right + 1;
                } else {
                  if (gap) {
                    row.push(
                      EventRowMixin.renderSpan(slots, gap, key + "_gap")
                    );
                  }

                  row.push(
                    EventRowMixin.renderSpan(
                      slots,
                      1,
                      key,
                      this.renderShowMore(segments, current)
                    )
                  );
                  lastEnd = current = current + 1;
                }
              }

              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-row",
                },
                row
              );
            };

            _proto.canRenderSlotEvent = function canRenderSlotEvent(
              slot,
              span
            ) {
              var segments = this.props.segments;
              return lodash_range__WEBPACK_IMPORTED_MODULE_26___default()(
                slot,
                slot + span
              ).every(function(s) {
                var count = eventsInSlot(segments, s);
                return count === 1;
              });
            };

            _proto.renderShowMore = function renderShowMore(segments, slot) {
              var _this = this;

              var localizer = this.props.localizer;
              var count = eventsInSlot(segments, slot);
              return count
                ? react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "a",
                    {
                      key: "sm_" + slot,
                      href: "#",
                      className: "rbc-show-more",
                      onClick: function onClick(e) {
                        return _this.showMore(slot, e);
                      },
                    },
                    localizer.messages.showMore(count)
                  )
                : false;
            };

            _proto.showMore = function showMore(slot, e) {
              e.preventDefault();
              this.props.onShowMore(slot);
            };

            return EventEndingRow;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        EventEndingRow.propTypes = true
          ? Object(
              _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                "default"
              ]
            )(
              {
                segments:
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array,
                slots: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                onShowMore:
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              },
              EventRowMixin.propTypes
            )
          : undefined;
        EventEndingRow.defaultProps = Object(
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
            "default"
          ]
        )({}, EventRowMixin.defaultProps);

        var isSegmentInSlot$1 = function isSegmentInSlot(seg, slot) {
          return seg.left <= slot && seg.right >= slot;
        };

        var isEqual = function isEqual(a, b) {
          return a.range === b.range && a.events === b.events;
        };

        function getSlotMetrics() {
          return Object(memoize_one__WEBPACK_IMPORTED_MODULE_27__["default"])(
            function(options) {
              var range$$1 = options.range,
                events$$1 = options.events,
                maxRows = options.maxRows,
                minRows = options.minRows,
                accessors = options.accessors;

              var _endOfRange = endOfRange(range$$1),
                first = _endOfRange.first,
                last = _endOfRange.last;

              var segments = events$$1.map(function(evt) {
                return eventSegments(evt, range$$1, accessors);
              });

              var _eventLevels = eventLevels(
                  segments,
                  Math.max(maxRows - 1, 1)
                ),
                levels = _eventLevels.levels,
                extra = _eventLevels.extra;

              while (levels.length < minRows) {
                levels.push([]);
              }

              return {
                first: first,
                last: last,
                levels: levels,
                extra: extra,
                range: range$$1,
                slots: range$$1.length,
                clone: function clone(args) {
                  var metrics = getSlotMetrics();
                  return metrics(
                    Object(
                      _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                        "default"
                      ]
                    )({}, options, args)
                  );
                },
                getDateForSlot: function getDateForSlot(slotNumber) {
                  return range$$1[slotNumber];
                },
                getSlotForDate: function getSlotForDate(date) {
                  return range$$1.find(function(r) {
                    return dates.eq(r, date, "day");
                  });
                },
                getEventsForSlot: function getEventsForSlot(slot) {
                  return segments
                    .filter(function(seg) {
                      return isSegmentInSlot$1(seg, slot);
                    })
                    .map(function(seg) {
                      return seg.event;
                    });
                },
                continuesPrior: function continuesPrior(event) {
                  return dates.lt(accessors.start(event), first, "day");
                },
                continuesAfter: function continuesAfter(event) {
                  var eventEnd = accessors.end(event);
                  var singleDayDuration = dates.eq(
                    accessors.start(event),
                    eventEnd,
                    "minutes"
                  );
                  return singleDayDuration
                    ? dates.gte(eventEnd, last, "minutes")
                    : dates.gt(eventEnd, last, "minutes");
                },
              };
            },
            isEqual
          );
        }

        var DateContentRow =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(DateContentRow, _React$Component);

            function DateContentRow() {
              var _this;

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                ) || this;

              _this.handleSelectSlot = function(slot) {
                var _this$props = _this.props,
                  range$$1 = _this$props.range,
                  onSelectSlot = _this$props.onSelectSlot;
                onSelectSlot(range$$1.slice(slot.start, slot.end + 1), slot);
              };

              _this.handleShowMore = function(slot) {
                var _this$props2 = _this.props,
                  range$$1 = _this$props2.range,
                  onShowMore = _this$props2.onShowMore;

                var metrics = _this.slotMetrics(_this.props);

                var row = dom_helpers_query_querySelectorAll__WEBPACK_IMPORTED_MODULE_21___default()(
                  Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                    Object(
                      _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                        "default"
                      ]
                    )(
                      Object(
                        _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                          "default"
                        ]
                      )(_this)
                    )
                  ),
                  ".rbc-row-bg"
                )[0];
                var cell;
                if (row) cell = row.children[slot - 1];
                var events$$1 = metrics.getEventsForSlot(slot);
                onShowMore(events$$1, range$$1[slot - 1], cell, slot);
              };

              _this.createHeadingRef = function(r) {
                _this.headingRow = r;
              };

              _this.createEventRef = function(r) {
                _this.eventRow = r;
              };

              _this.getContainer = function() {
                var container = _this.props.container;
                return container
                  ? container()
                  : Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                      Object(
                        _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                          "default"
                        ]
                      )(
                        Object(
                          _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                            "default"
                          ]
                        )(_this)
                      )
                    );
              };

              _this.renderHeadingCell = function(date, index) {
                var _this$props3 = _this.props,
                  renderHeader = _this$props3.renderHeader,
                  getNow = _this$props3.getNow;
                return renderHeader({
                  date: date,
                  key: "header_" + index,
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    "rbc-date-cell",
                    dates.eq(date, getNow(), "day") && "rbc-now"
                  ),
                });
              };

              _this.renderDummy = function() {
                var _this$props4 = _this.props,
                  className = _this$props4.className,
                  range$$1 = _this$props4.range,
                  renderHeader = _this$props4.renderHeader;
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "div",
                  {
                    className: className,
                  },
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "div",
                    {
                      className: "rbc-row-content",
                    },
                    renderHeader &&
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "div",
                        {
                          className: "rbc-row",
                          ref: _this.createHeadingRef,
                        },
                        range$$1.map(_this.renderHeadingCell)
                      ),
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "div",
                      {
                        className: "rbc-row",
                        ref: _this.createEventRef,
                      },
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "div",
                        {
                          className: "rbc-row-segment",
                        },
                        react__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ].createElement(
                          "div",
                          {
                            className: "rbc-event",
                          },
                          react__WEBPACK_IMPORTED_MODULE_4__[
                            "default"
                          ].createElement(
                            "div",
                            {
                              className: "rbc-event-content",
                            },
                            "\xA0"
                          )
                        )
                      )
                    )
                  )
                );
              };

              _this.slotMetrics = getSlotMetrics();
              return _this;
            }

            var _proto = DateContentRow.prototype;

            _proto.getRowLimit = function getRowLimit() {
              var eventHeight = dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20___default()(
                this.eventRow
              );
              var headingHeight = this.headingRow
                ? dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20___default()(
                    this.headingRow
                  )
                : 0;
              var eventSpace =
                dom_helpers_query_height__WEBPACK_IMPORTED_MODULE_20___default()(
                  Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                    this
                  )
                ) - headingHeight;
              return Math.max(Math.floor(eventSpace / eventHeight), 1);
            };

            _proto.render = function render() {
              var _this$props5 = this.props,
                date = _this$props5.date,
                rtl = _this$props5.rtl,
                range$$1 = _this$props5.range,
                className = _this$props5.className,
                selected = _this$props5.selected,
                selectable = _this$props5.selectable,
                renderForMeasure = _this$props5.renderForMeasure,
                accessors = _this$props5.accessors,
                getters = _this$props5.getters,
                components = _this$props5.components,
                getNow = _this$props5.getNow,
                renderHeader = _this$props5.renderHeader,
                onSelect = _this$props5.onSelect,
                localizer = _this$props5.localizer,
                onSelectStart = _this$props5.onSelectStart,
                onSelectEnd = _this$props5.onSelectEnd,
                onDoubleClick = _this$props5.onDoubleClick,
                resourceId = _this$props5.resourceId,
                longPressThreshold = _this$props5.longPressThreshold,
                isAllDay = _this$props5.isAllDay;
              if (renderForMeasure) return this.renderDummy();
              var metrics = this.slotMetrics(this.props);
              var levels = metrics.levels,
                extra = metrics.extra;
              var WeekWrapper = components.weekWrapper;
              var eventRowProps = {
                selected: selected,
                accessors: accessors,
                getters: getters,
                localizer: localizer,
                components: components,
                onSelect: onSelect,
                onDoubleClick: onDoubleClick,
                resourceId: resourceId,
                slotMetrics: metrics,
              };
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: className,
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  BackgroundCells,
                  {
                    date: date,
                    getNow: getNow,
                    rtl: rtl,
                    range: range$$1,
                    selectable: selectable,
                    container: this.getContainer,
                    getters: getters,
                    onSelectStart: onSelectStart,
                    onSelectEnd: onSelectEnd,
                    onSelectSlot: this.handleSelectSlot,
                    components: components,
                    longPressThreshold: longPressThreshold,
                  }
                ),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  {
                    className: "rbc-row-content",
                  },
                  renderHeader &&
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "div",
                      {
                        className: "rbc-row ",
                        ref: this.createHeadingRef,
                      },
                      range$$1.map(this.renderHeadingCell)
                    ),
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    WeekWrapper,
                    Object(
                      _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                        "default"
                      ]
                    )(
                      {
                        isAllDay: isAllDay,
                      },
                      eventRowProps
                    ),
                    levels.map(function(segs, idx) {
                      return react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        EventRow,
                        Object(
                          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                            "default"
                          ]
                        )(
                          {
                            key: idx,
                            segments: segs,
                          },
                          eventRowProps
                        )
                      );
                    }),
                    !!extra.length &&
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        EventEndingRow,
                        Object(
                          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                            "default"
                          ]
                        )(
                          {
                            segments: extra,
                            onShowMore: this.handleShowMore,
                          },
                          eventRowProps
                        )
                      )
                  )
                )
              );
            };

            return DateContentRow;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        DateContentRow.propTypes = true
          ? {
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              events:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              range:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              resourceId: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any,
              renderForMeasure:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              renderHeader:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              container: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onShowMore:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelect: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectEnd:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectStart:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClick:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              dayPropGetter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              isAllDay: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              minRows:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
              maxRows:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
            }
          : undefined;
        DateContentRow.defaultProps = {
          minRows: 0,
          maxRows: Infinity,
        };

        var Header = function Header(_ref) {
          var label = _ref.label;
          return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
            "span",
            null,
            label
          );
        };

        Header.propTypes = true
          ? {
              label: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
            }
          : undefined;

        var DateHeader = function DateHeader(_ref) {
          var label = _ref.label,
            drilldownView = _ref.drilldownView,
            onDrillDown = _ref.onDrillDown;

          if (!drilldownView) {
            return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              "span",
              null,
              label
            );
          }

          return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
            "a",
            {
              href: "#",
              onClick: onDrillDown,
            },
            label
          );
        };

        DateHeader.propTypes = true
          ? {
              label: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              drilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
              onDrillDown:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              isOffRange:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
            }
          : undefined;

        var eventsForWeek = function eventsForWeek(
          evts,
          start,
          end,
          accessors
        ) {
          return evts.filter(function(e) {
            return inRange(e, start, end, accessors);
          });
        };

        var MonthView =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(MonthView, _React$Component);

            function MonthView() {
              var _this;

              for (
                var _len = arguments.length, _args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                _args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(_args)
                ) || this;

              _this.getContainer = function() {
                return Object(
                  react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"]
                )(
                  Object(
                    _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                      "default"
                    ]
                  )(
                    Object(
                      _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                        "default"
                      ]
                    )(_this)
                  )
                );
              };

              _this.renderWeek = function(week, weekIdx) {
                var _this$props = _this.props,
                  events$$1 = _this$props.events,
                  components = _this$props.components,
                  selectable = _this$props.selectable,
                  getNow = _this$props.getNow,
                  selected = _this$props.selected,
                  date = _this$props.date,
                  localizer = _this$props.localizer,
                  longPressThreshold = _this$props.longPressThreshold,
                  accessors = _this$props.accessors,
                  getters = _this$props.getters;
                var _this$state = _this.state,
                  needLimitMeasure = _this$state.needLimitMeasure,
                  rowLimit = _this$state.rowLimit;
                events$$1 = eventsForWeek(
                  events$$1,
                  week[0],
                  week[week.length - 1],
                  accessors
                );
                events$$1.sort(function(a, b) {
                  return sortEvents(a, b, accessors);
                });
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(DateContentRow, {
                  key: weekIdx,
                  ref: weekIdx === 0 ? "slotRow" : undefined,
                  container: _this.getContainer,
                  className: "rbc-month-row",
                  getNow: getNow,
                  date: date,
                  range: week,
                  events: events$$1,
                  maxRows: rowLimit,
                  selected: selected,
                  selectable: selectable,
                  components: components,
                  accessors: accessors,
                  getters: getters,
                  localizer: localizer,
                  renderHeader: _this.readerDateHeading,
                  renderForMeasure: needLimitMeasure,
                  onShowMore: _this.handleShowMore,
                  onSelect: _this.handleSelectEvent,
                  onDoubleClick: _this.handleDoubleClickEvent,
                  onSelectSlot: _this.handleSelectSlot,
                  longPressThreshold: longPressThreshold,
                  rtl: _this.props.rtl,
                });
              };

              _this.readerDateHeading = function(_ref) {
                var date = _ref.date,
                  className = _ref.className,
                  props = Object(
                    _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                      "default"
                    ]
                  )(_ref, ["date", "className"]);

                var _this$props2 = _this.props,
                  currentDate = _this$props2.date,
                  getDrilldownView = _this$props2.getDrilldownView,
                  localizer = _this$props2.localizer;
                var isOffRange = dates.month(date) !== dates.month(currentDate);
                var isCurrent = dates.eq(date, currentDate, "day");
                var drilldownView = getDrilldownView(date);
                var label = localizer.format(date, "dateFormat");
                var DateHeaderComponent =
                  _this.props.components.dateHeader || DateHeader;
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "div",
                  Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )({}, props, {
                    className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                      className,
                      isOffRange && "rbc-off-range",
                      isCurrent && "rbc-current"
                    ),
                  }),
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    DateHeaderComponent,
                    {
                      label: label,
                      date: date,
                      drilldownView: drilldownView,
                      isOffRange: isOffRange,
                      onDrillDown: function onDrillDown(e) {
                        return _this.handleHeadingClick(date, drilldownView, e);
                      },
                    }
                  )
                );
              };

              _this.handleSelectSlot = function(range$$1, slotInfo) {
                _this._pendingSelection = _this._pendingSelection.concat(
                  range$$1
                );
                clearTimeout(_this._selectTimer);
                _this._selectTimer = setTimeout(function() {
                  return _this.selectDates(slotInfo);
                });
              };

              _this.handleHeadingClick = function(date, view, e) {
                e.preventDefault();

                _this.clearSelection();

                notify(_this.props.onDrillDown, [date, view]);
              };

              _this.handleSelectEvent = function() {
                _this.clearSelection();

                for (
                  var _len2 = arguments.length,
                    args = new Array(_len2),
                    _key2 = 0;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2] = arguments[_key2];
                }

                notify(_this.props.onSelectEvent, args);
              };

              _this.handleDoubleClickEvent = function() {
                _this.clearSelection();

                for (
                  var _len3 = arguments.length,
                    args = new Array(_len3),
                    _key3 = 0;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3] = arguments[_key3];
                }

                notify(_this.props.onDoubleClickEvent, args);
              };

              _this.handleShowMore = function(events$$1, date, cell, slot) {
                var _this$props3 = _this.props,
                  popup = _this$props3.popup,
                  onDrillDown = _this$props3.onDrillDown,
                  onShowMore = _this$props3.onShowMore,
                  getDrilldownView = _this$props3.getDrilldownView; //cancel any pending selections so only the event click goes through.

                _this.clearSelection();

                if (popup) {
                  var position = dom_helpers_query_position__WEBPACK_IMPORTED_MODULE_14___default()(
                    cell,
                    Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                      Object(
                        _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                          "default"
                        ]
                      )(
                        Object(
                          _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                            "default"
                          ]
                        )(_this)
                      )
                    )
                  );

                  _this.setState({
                    overlay: {
                      date: date,
                      events: events$$1,
                      position: position,
                    },
                  });
                } else {
                  notify(onDrillDown, [
                    date,
                    getDrilldownView(date) || views.DAY,
                  ]);
                }

                notify(onShowMore, [events$$1, date, slot]);
              };

              _this._bgRows = [];
              _this._pendingSelection = [];
              _this.state = {
                rowLimit: 5,
                needLimitMeasure: true,
              };
              return _this;
            }

            var _proto = MonthView.prototype;

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              _ref2
            ) {
              var date = _ref2.date;
              this.setState({
                needLimitMeasure: !dates.eq(date, this.props.date),
              });
            };

            _proto.componentDidMount = function componentDidMount() {
              var _this2 = this;

              var running;
              if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
              window.addEventListener(
                "resize",
                (this._resizeListener = function() {
                  if (!running) {
                    dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15___default()(
                      function() {
                        running = false;

                        _this2.setState({
                          needLimitMeasure: true,
                        }); //eslint-disable-line
                      }
                    );
                  }
                }),
                false
              );
            };

            _proto.componentDidUpdate = function componentDidUpdate() {
              if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
            };

            _proto.componentWillUnmount = function componentWillUnmount() {
              window.removeEventListener("resize", this._resizeListener, false);
            };

            _proto.render = function render() {
              var _this$props4 = this.props,
                date = _this$props4.date,
                localizer = _this$props4.localizer,
                className = _this$props4.className,
                month = dates.visibleDays(date, localizer),
                weeks = lodash_chunk__WEBPACK_IMPORTED_MODULE_13___default()(
                  month,
                  7
                );
              this._weekCount = weeks.length;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    "rbc-month-view",
                    className
                  ),
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  {
                    className: "rbc-row rbc-month-header",
                  },
                  this.renderHeaders(weeks[0])
                ),
                weeks.map(this.renderWeek),
                this.props.popup && this.renderOverlay()
              );
            };

            _proto.renderHeaders = function renderHeaders(row) {
              var _this$props5 = this.props,
                localizer = _this$props5.localizer,
                components = _this$props5.components;
              var first = row[0];
              var last = row[row.length - 1];
              var HeaderComponent = components.header || Header;
              return dates.range(first, last, "day").map(function(day, idx) {
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "div",
                  {
                    key: "header_" + idx,
                    className: "rbc-header",
                  },
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    HeaderComponent,
                    {
                      date: day,
                      localizer: localizer,
                      label: localizer.format(day, "weekdayFormat"),
                    }
                  )
                );
              });
            };

            _proto.renderOverlay = function renderOverlay() {
              var _this3 = this;

              var overlay = (this.state && this.state.overlay) || {};
              var _this$props6 = this.props,
                accessors = _this$props6.accessors,
                localizer = _this$props6.localizer,
                components = _this$props6.components,
                getters = _this$props6.getters,
                selected = _this$props6.selected;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                react_overlays_lib_Overlay__WEBPACK_IMPORTED_MODULE_19___default.a,
                {
                  rootClose: true,
                  placement: "bottom",
                  container: this,
                  show: !!overlay.position,
                  onHide: function onHide() {
                    return _this3.setState({
                      overlay: null,
                    });
                  },
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  Popup,
                  {
                    accessors: accessors,
                    getters: getters,
                    selected: selected,
                    components: components,
                    localizer: localizer,
                    position: overlay.position,
                    events: overlay.events,
                    slotStart: overlay.date,
                    slotEnd: overlay.end,
                    onSelect: this.handleSelectEvent,
                    onDoubleClick: this.handleDoubleClickEvent,
                  }
                )
              );
            };

            _proto.measureRowLimit = function measureRowLimit() {
              this.setState({
                needLimitMeasure: false,
                rowLimit: this.refs.slotRow.getRowLimit(),
              });
            };

            _proto.selectDates = function selectDates(slotInfo) {
              var slots = this._pendingSelection.slice();

              this._pendingSelection = [];
              slots.sort(function(a, b) {
                return +a - +b;
              });
              notify(this.props.onSelectSlot, {
                slots: slots,
                start: slots[0],
                end: slots[slots.length - 1],
                action: slotInfo.action,
                bounds: slotInfo.bounds,
                box: slotInfo.box,
              });
            };

            _proto.clearSelection = function clearSelection() {
              clearTimeout(this._selectTimer);
              this._pendingSelection = [];
            };

            return MonthView;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        MonthView.propTypes = true
          ? {
              events:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              min: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              max: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              step: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              scrollToTime: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              width: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onNavigate:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClickEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onShowMore:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDrillDown:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              getDrilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              popup: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              popupOffset: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
                [
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
                    x: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                    y: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  }),
                ]
              ),
            }
          : undefined;

        MonthView.range = function(date, _ref3) {
          var localizer = _ref3.localizer;
          var start = dates.firstVisibleDay(date, localizer);
          var end = dates.lastVisibleDay(date, localizer);
          return {
            start: start,
            end: end,
          };
        };

        MonthView.navigate = function(date, action) {
          switch (action) {
            case navigate.PREVIOUS:
              return dates.add(date, -1, "month");

            case navigate.NEXT:
              return dates.add(date, 1, "month");

            default:
              return date;
          }
        };

        MonthView.title = function(date, _ref4) {
          var localizer = _ref4.localizer;
          return localizer.format(date, "monthHeaderFormat");
        };

        var getDstOffset = function getDstOffset(start, end) {
          return start.getTimezoneOffset() - end.getTimezoneOffset();
        };

        var getKey = function getKey(min, max, step, slots) {
          return (
            "" +
            +dates.startOf(min, "minutes") +
            ("" + +dates.startOf(max, "minutes")) +
            (step + "-" + slots)
          );
        };

        function getSlotMetrics$1(_ref) {
          var start = _ref.min,
            end = _ref.max,
            step = _ref.step,
            timeslots = _ref.timeslots;
          var key = getKey(start, end, step, timeslots);
          var totalMin =
            1 + dates.diff(start, end, "minutes") + getDstOffset(start, end);
          var minutesFromMidnight = dates.diff(
            dates.startOf(start, "day"),
            start,
            "minutes"
          );
          var numGroups = Math.ceil(totalMin / (step * timeslots));
          var numSlots = numGroups * timeslots;
          var groups = new Array(numGroups);
          var slots = new Array(numSlots); // Each slot date is created from "zero", instead of adding `step` to
          // the previous one, in order to avoid DST oddities

          for (var grp = 0; grp < numGroups; grp++) {
            groups[grp] = new Array(timeslots);

            for (var slot = 0; slot < timeslots; slot++) {
              var slotIdx = grp * timeslots + slot;
              var minFromStart = slotIdx * step; // A date with total minutes calculated from the start of the day

              slots[slotIdx] = groups[grp][slot] = new Date(
                start.getFullYear(),
                start.getMonth(),
                start.getDate(),
                0,
                minutesFromMidnight + minFromStart,
                0,
                0
              );
            }
          } // Necessary to be able to select up until the last timeslot in a day

          var lastSlotMinFromStart = slots.length * step;
          slots.push(
            new Date(
              start.getFullYear(),
              start.getMonth(),
              start.getDate(),
              0,
              minutesFromMidnight + lastSlotMinFromStart,
              0,
              0
            )
          );

          function positionFromDate(date) {
            var diff =
              dates.diff(start, date, "minutes") + getDstOffset(start, date);
            return Math.min(diff, totalMin);
          }

          return {
            groups: groups,
            update: function update(args) {
              if (getKey(args) !== key) return getSlotMetrics$1(args);
              return this;
            },
            dateIsInGroup: function dateIsInGroup(date, groupIndex) {
              var nextGroup = groups[groupIndex + 1];
              return dates.inRange(
                date,
                groups[groupIndex][0],
                nextGroup ? nextGroup[0] : end,
                "minutes"
              );
            },
            nextSlot: function nextSlot(slot) {
              var next =
                slots[Math.min(slots.indexOf(slot) + 1, slots.length - 1)]; // in the case of the last slot we won't a long enough range so manually get it

              if (next === slot) next = dates.add(slot, step, "minutes");
              return next;
            },
            closestSlotToPosition: function closestSlotToPosition(percent) {
              var slot = Math.min(
                slots.length - 1,
                Math.max(0, Math.floor(percent * numSlots))
              );
              return slots[slot];
            },
            closestSlotFromPoint: function closestSlotFromPoint(
              point,
              boundaryRect
            ) {
              var range$$1 = Math.abs(boundaryRect.top - boundaryRect.bottom);
              return this.closestSlotToPosition(
                (point.y - boundaryRect.top) / range$$1
              );
            },
            closestSlotFromDate: function closestSlotFromDate(date, offset) {
              if (offset === void 0) {
                offset = 0;
              }

              if (dates.lt(date, start, "minutes")) return slots[0];
              var diffMins = dates.diff(start, date, "minutes");
              return slots[(diffMins - (diffMins % step)) / step + offset];
            },
            startsBeforeDay: function startsBeforeDay(date) {
              return dates.lt(date, start, "day");
            },
            startsAfterDay: function startsAfterDay(date) {
              return dates.gt(date, end, "day");
            },
            startsBefore: function startsBefore(date) {
              return dates.lt(dates.merge(start, date), start, "minutes");
            },
            startsAfter: function startsAfter(date) {
              return dates.gt(dates.merge(end, date), end, "minutes");
            },
            getRange: function getRange(rangeStart, rangeEnd) {
              rangeStart = dates.min(end, dates.max(start, rangeStart));
              rangeEnd = dates.min(end, dates.max(start, rangeEnd));
              var rangeStartMin = positionFromDate(rangeStart);
              var rangeEndMin = positionFromDate(rangeEnd);
              var top = (rangeStartMin / (step * numSlots)) * 100;
              return {
                top: top,
                height: (rangeEndMin / (step * numSlots)) * 100 - top,
                start: positionFromDate(rangeStart),
                startDate: rangeStart,
                end: positionFromDate(rangeEnd),
                endDate: rangeEnd,
              };
            },
          };
        }

        var Event =
          /*#__PURE__*/
          (function() {
            function Event(data, _ref) {
              var accessors = _ref.accessors,
                slotMetrics = _ref.slotMetrics;

              var _slotMetrics$getRange = slotMetrics.getRange(
                  accessors.start(data),
                  accessors.end(data)
                ),
                start = _slotMetrics$getRange.start,
                startDate = _slotMetrics$getRange.startDate,
                end = _slotMetrics$getRange.end,
                endDate = _slotMetrics$getRange.endDate,
                top = _slotMetrics$getRange.top,
                height = _slotMetrics$getRange.height;

              this.start = start;
              this.end = end;
              this.startMs = +startDate;
              this.endMs = +endDate;
              this.top = top;
              this.height = height;
              this.data = data;
            }
            /**
             * The event's width without any overlap.
             */

            Object(
              _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_28__[
                "default"
              ]
            )(Event, [
              {
                key: "_width",
                get: function get() {
                  // The container event's width is determined by the maximum number of
                  // events in any of its rows.
                  if (this.rows) {
                    var columns =
                      this.rows.reduce(
                        function(max, row) {
                          return Math.max(max, row.leaves.length + 1);
                        }, // add itself
                        0
                      ) + 1; // add the container

                    return 100 / columns;
                  }

                  var availableWidth = 100 - this.container._width; // The row event's width is the space left by the container, divided
                  // among itself and its leaves.

                  if (this.leaves) {
                    return availableWidth / (this.leaves.length + 1);
                  } // The leaf event's width is determined by its row's width

                  return this.row._width;
                },
                /**
                 * The event's calculated width, possibly with extra width added for
                 * overlapping effect.
                 */
              },
              {
                key: "width",
                get: function get() {
                  var noOverlap = this._width;
                  var overlap = Math.min(100, this._width * 1.7); // Containers can always grow.

                  if (this.rows) {
                    return overlap;
                  } // Rows can grow if they have leaves.

                  if (this.leaves) {
                    return this.leaves.length > 0 ? overlap : noOverlap;
                  } // Leaves can grow unless they're the last item in a row.

                  var leaves = this.row.leaves;
                  var index = leaves.indexOf(this);
                  return index === leaves.length - 1 ? noOverlap : overlap;
                },
              },
              {
                key: "xOffset",
                get: function get() {
                  // Containers have no offset.
                  if (this.rows) return 0; // Rows always start where their container ends.

                  if (this.leaves) return this.container._width; // Leaves are spread out evenly on the space left by its row.

                  var _this$row = this.row,
                    leaves = _this$row.leaves,
                    xOffset = _this$row.xOffset,
                    _width = _this$row._width;
                  var index = leaves.indexOf(this) + 1;
                  return xOffset + index * _width;
                },
              },
            ]);

            return Event;
          })();
        /**
         * Return true if event a and b is considered to be on the same row.
         */

        function onSameRow(a, b, minimumStartDifference) {
          return (
            // Occupies the same start slot.
            Math.abs(b.start - a.start) < minimumStartDifference || // A's start slot overlaps with b's end slot.
            (b.start > a.start && b.start < a.end)
          );
        }

        function sortByRender(events$$1) {
          var sortedByTime = lodash_sortBy__WEBPACK_IMPORTED_MODULE_29___default()(
            events$$1,
            [
              "startMs",
              function(e) {
                return -e.endMs;
              },
            ]
          );
          var sorted = [];

          while (sortedByTime.length > 0) {
            var event = sortedByTime.shift();
            sorted.push(event);

            for (var i = 0; i < sortedByTime.length; i++) {
              var test = sortedByTime[i]; // Still inside this event, look for next.

              if (event.endMs > test.startMs) continue; // We've found the first event of the next event group.
              // If that event is not right next to our current event, we have to
              // move it here.

              if (i > 0) {
                var _event = sortedByTime.splice(i, 1)[0];
                sorted.push(_event);
              } // We've already found the next event group, so stop looking.

              break;
            }
          }

          return sorted;
        }

        function getStyledEvents(_ref2) {
          var events$$1 = _ref2.events,
            minimumStartDifference = _ref2.minimumStartDifference,
            slotMetrics = _ref2.slotMetrics,
            accessors = _ref2.accessors; // Create proxy events and order them so that we don't have
          // to fiddle with z-indexes.

          var proxies = events$$1.map(function(event) {
            return new Event(event, {
              slotMetrics: slotMetrics,
              accessors: accessors,
            });
          });
          var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.
          // Every event is always one of: container, row or leaf.
          // Containers can contain rows, and rows can contain leaves.

          var containerEvents = [];

          var _loop = function _loop(i) {
            var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.

            var container = containerEvents.find(function(c) {
              return (
                c.end > event.start ||
                Math.abs(event.start - c.start) < minimumStartDifference
              );
            }); // Couldn't find a container  that means this event is a container.

            if (!container) {
              event.rows = [];
              containerEvents.push(event);
              return "continue";
            } // Found a container for the event.

            event.container = container; // Check if the event can be placed in an existing row.
            // Start looking from behind.

            var row = null;

            for (var j = container.rows.length - 1; !row && j >= 0; j--) {
              if (onSameRow(container.rows[j], event, minimumStartDifference)) {
                row = container.rows[j];
              }
            }

            if (row) {
              // Found a row, so add it.
              row.leaves.push(event);
              event.row = row;
            } else {
              // Couldn't find a row  that means this event is a row.
              event.leaves = [];
              container.rows.push(event);
            }
          };

          for (var i = 0; i < eventsInRenderOrder.length; i++) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          } // Return the original events, along with their styles.

          return eventsInRenderOrder.map(function(event) {
            return {
              event: event.data,
              style: {
                top: event.top,
                height: event.height,
                width: event.width,
                xOffset: event.xOffset,
              },
            };
          });
        }

        function NoopWrapper(props) {
          return props.children;
        }

        var TimeSlotGroup =
          /*#__PURE__*/
          (function(_Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(TimeSlotGroup, _Component);

            function TimeSlotGroup() {
              return _Component.apply(this, arguments) || this;
            }

            var _proto = TimeSlotGroup.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                renderSlot = _this$props.renderSlot,
                resource = _this$props.resource,
                group = _this$props.group,
                getters = _this$props.getters,
                _this$props$component = _this$props.components;
              _this$props$component =
                _this$props$component === void 0 ? {} : _this$props$component;
              var _this$props$component2 =
                  _this$props$component.timeSlotWrapper,
                Wrapper =
                  _this$props$component2 === void 0
                    ? NoopWrapper
                    : _this$props$component2;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-timeslot-group",
                },
                group.map(function(value, idx) {
                  var slotProps = getters
                    ? getters.slotProp(value, resource)
                    : {};
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    Wrapper,
                    {
                      key: idx,
                      value: value,
                      resource: resource,
                    },
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "div",
                      Object(
                        _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                          "default"
                        ]
                      )({}, slotProps, {
                        className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                          "rbc-time-slot",
                          slotProps.className
                        ),
                      }),
                      renderSlot && renderSlot(value, idx)
                    )
                  );
                })
              );
            };

            return TimeSlotGroup;
          })(react__WEBPACK_IMPORTED_MODULE_4__["Component"]);

        TimeSlotGroup.propTypes = true
          ? {
              renderSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              group:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              resource: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              getters: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
            }
          : undefined;
        /* eslint-disable react/prop-types */

        function TimeGridEvent(props) {
          var _extends2;

          var style = props.style,
            className = props.className,
            event = props.event,
            accessors = props.accessors,
            isRtl = props.isRtl,
            selected = props.selected,
            label = props.label,
            continuesEarlier = props.continuesEarlier,
            continuesLater = props.continuesLater,
            getters = props.getters,
            onClick = props.onClick,
            onDoubleClick = props.onDoubleClick,
            _props$components = props.components,
            Event = _props$components.event,
            EventWrapper = _props$components.eventWrapper;
          var title = accessors.title(event);
          var tooltip = accessors.tooltip(event);
          var end = accessors.end(event);
          var start = accessors.start(event);
          var userProps = getters.eventProp(event, start, end, selected);
          var height = style.height,
            top = style.top,
            width = style.width,
            xOffset = style.xOffset;
          var inner = [
            react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              "div",
              {
                key: "1",
                className: "rbc-event-label",
              },
              label
            ),
            react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              "div",
              {
                key: "2",
                className: "rbc-event-content",
              },
              Event
                ? react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    Event,
                    {
                      event: event,
                      title: title,
                    }
                  )
                : title
            ),
          ];
          return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
            EventWrapper,
            Object(
              _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                "default"
              ]
            )(
              {
                type: "time",
              },
              props
            ),
            react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
              "div",
              {
                onClick: onClick,
                onDoubleClick: onDoubleClick,
                style: Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )(
                  {},
                  userProps.style,
                  ((_extends2 = {
                    top: top + "%",
                    height: height + "%",
                  }),
                  (_extends2[isRtl ? "right" : "left"] =
                    Math.max(0, xOffset) + "%"),
                  (_extends2.width = width + "%"),
                  _extends2)
                ),
                title: tooltip
                  ? (typeof label === "string" ? label + ": " : "") + tooltip
                  : undefined,
                className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                  "rbc-event",
                  className,
                  userProps.className,
                  {
                    "rbc-selected": selected,
                    "rbc-event-continues-earlier": continuesEarlier,
                    "rbc-event-continues-later": continuesLater,
                  }
                ),
              },
              inner
            )
          );
        }

        var DayColumn =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(DayColumn, _React$Component);

            function DayColumn() {
              var _this;

              for (
                var _len = arguments.length, _args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                _args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(_args)
                ) || this;
              _this.state = {
                selecting: false,
                timeIndicatorPosition: null,
              };
              _this.intervalTriggered = false;

              _this.renderEvents = function() {
                var _this$props = _this.props,
                  events$$1 = _this$props.events,
                  isRtl = _this$props.rtl,
                  selected = _this$props.selected,
                  accessors = _this$props.accessors,
                  localizer = _this$props.localizer,
                  getters = _this$props.getters,
                  components = _this$props.components,
                  step = _this$props.step,
                  timeslots = _this$props.timeslots;

                var _assertThisInitialize = Object(
                    _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                      "default"
                    ]
                  )(
                    Object(
                      _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                        "default"
                      ]
                    )(_this)
                  ),
                  slotMetrics = _assertThisInitialize.slotMetrics;

                var messages = localizer.messages;
                var styledEvents = getStyledEvents({
                  events: events$$1,
                  accessors: accessors,
                  slotMetrics: slotMetrics,
                  minimumStartDifference: Math.ceil((step * timeslots) / 2),
                });
                return styledEvents.map(function(_ref, idx) {
                  var event = _ref.event,
                    style = _ref.style;
                  var end = accessors.end(event);
                  var start = accessors.start(event);
                  var format = "eventTimeRangeFormat";
                  var label;
                  var startsBeforeDay = slotMetrics.startsBeforeDay(start);
                  var startsAfterDay = slotMetrics.startsAfterDay(end);
                  if (startsBeforeDay) format = "eventTimeRangeEndFormat";
                  else if (startsAfterDay) format = "eventTimeRangeStartFormat";
                  if (startsBeforeDay && startsAfterDay)
                    label = messages.allDay;
                  else
                    label = localizer.format(
                      {
                        start: start,
                        end: end,
                      },
                      format
                    );
                  var continuesEarlier =
                    startsBeforeDay || slotMetrics.startsBefore(start);
                  var continuesLater =
                    startsAfterDay || slotMetrics.startsAfter(end);
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(TimeGridEvent, {
                    style: style,
                    event: event,
                    label: label,
                    key: "evt_" + idx,
                    getters: getters,
                    isRtl: isRtl,
                    components: components,
                    continuesEarlier: continuesEarlier,
                    continuesLater: continuesLater,
                    accessors: accessors,
                    selected: isSelected(event, selected),
                    onClick: function onClick(e) {
                      return _this._select(event, e);
                    },
                    onDoubleClick: function onDoubleClick(e) {
                      return _this._doubleClick(event, e);
                    },
                  });
                });
              };

              _this._selectable = function() {
                var node = Object(
                  react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"]
                )(
                  Object(
                    _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                      "default"
                    ]
                  )(
                    Object(
                      _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                        "default"
                      ]
                    )(_this)
                  )
                );
                var selector = (_this._selector = new Selection(
                  function() {
                    return Object(
                      react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"]
                    )(
                      Object(
                        _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                          "default"
                        ]
                      )(
                        Object(
                          _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                            "default"
                          ]
                        )(_this)
                      )
                    );
                  },
                  {
                    longPressThreshold: _this.props.longPressThreshold,
                  }
                ));

                var maybeSelect = function maybeSelect(box) {
                  var onSelecting = _this.props.onSelecting;
                  var current = _this.state || {};
                  var state = selectionState(box);
                  var start = state.startDate,
                    end = state.endDate;

                  if (onSelecting) {
                    if (
                      (dates.eq(current.startDate, start, "minutes") &&
                        dates.eq(current.endDate, end, "minutes")) ||
                      onSelecting({
                        start: start,
                        end: end,
                      }) === false
                    )
                      return;
                  }

                  if (
                    _this.state.start !== state.start ||
                    _this.state.end !== state.end ||
                    _this.state.selecting !== state.selecting
                  ) {
                    _this.setState(state);
                  }
                };

                var selectionState = function selectionState(point) {
                  var currentSlot = _this.slotMetrics.closestSlotFromPoint(
                    point,
                    getBoundsForNode(node)
                  );

                  if (!_this.state.selecting) _this._initialSlot = currentSlot;
                  var initialSlot = _this._initialSlot;
                  if (initialSlot === currentSlot)
                    currentSlot = _this.slotMetrics.nextSlot(initialSlot);

                  var selectRange = _this.slotMetrics.getRange(
                    dates.min(initialSlot, currentSlot),
                    dates.max(initialSlot, currentSlot)
                  );

                  return Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )({}, selectRange, {
                    selecting: true,
                    top: selectRange.top + "%",
                    height: selectRange.height + "%",
                  });
                };

                var selectorClicksHandler = function selectorClicksHandler(
                  box,
                  actionType
                ) {
                  if (
                    !isEvent(
                      Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                        Object(
                          _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                            "default"
                          ]
                        )(
                          Object(
                            _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                              "default"
                            ]
                          )(_this)
                        )
                      ),
                      box
                    )
                  ) {
                    var _selectionState = selectionState(box),
                      startDate = _selectionState.startDate,
                      endDate = _selectionState.endDate;

                    _this._selectSlot({
                      startDate: startDate,
                      endDate: endDate,
                      action: actionType,
                      box: box,
                    });
                  }

                  _this.setState({
                    selecting: false,
                  });
                };

                selector.on("selecting", maybeSelect);
                selector.on("selectStart", maybeSelect);
                selector.on("beforeSelect", function(box) {
                  if (_this.props.selectable !== "ignoreEvents") return;
                  return !isEvent(
                    Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                      Object(
                        _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                          "default"
                        ]
                      )(
                        Object(
                          _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_11__[
                            "default"
                          ]
                        )(_this)
                      )
                    ),
                    box
                  );
                });
                selector.on("click", function(box) {
                  return selectorClicksHandler(box, "click");
                });
                selector.on("doubleClick", function(box) {
                  return selectorClicksHandler(box, "doubleClick");
                });
                selector.on("select", function(bounds) {
                  if (_this.state.selecting) {
                    _this._selectSlot(
                      Object(
                        _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                          "default"
                        ]
                      )({}, _this.state, {
                        action: "select",
                        bounds: bounds,
                      })
                    );

                    _this.setState({
                      selecting: false,
                    });
                  }
                });
                selector.on("reset", function() {
                  if (_this.state.selecting) {
                    _this.setState({
                      selecting: false,
                    });
                  }
                });
              };

              _this._teardownSelectable = function() {
                if (!_this._selector) return;

                _this._selector.teardown();

                _this._selector = null;
              };

              _this._selectSlot = function(_ref2) {
                var startDate = _ref2.startDate,
                  endDate = _ref2.endDate,
                  action = _ref2.action,
                  bounds = _ref2.bounds,
                  box = _ref2.box;
                var current = startDate,
                  slots = [];

                while (dates.lte(current, endDate)) {
                  slots.push(current);
                  current = dates.add(current, _this.props.step, "minutes");
                }

                notify(_this.props.onSelectSlot, {
                  slots: slots,
                  start: startDate,
                  end: endDate,
                  resourceId: _this.props.resource,
                  action: action,
                  bounds: bounds,
                  box: box,
                });
              };

              _this._select = function() {
                for (
                  var _len2 = arguments.length,
                    args = new Array(_len2),
                    _key2 = 0;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2] = arguments[_key2];
                }

                notify(_this.props.onSelectEvent, args);
              };

              _this._doubleClick = function() {
                for (
                  var _len3 = arguments.length,
                    args = new Array(_len3),
                    _key3 = 0;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3] = arguments[_key3];
                }

                notify(_this.props.onDoubleClickEvent, args);
              };

              _this.slotMetrics = getSlotMetrics$1(_this.props);
              return _this;
            }

            var _proto = DayColumn.prototype;

            _proto.componentDidMount = function componentDidMount() {
              this.props.selectable && this._selectable();

              if (this.props.isNow) {
                this.setTimeIndicatorPositionUpdateInterval();
              }
            };

            _proto.componentWillUnmount = function componentWillUnmount() {
              this._teardownSelectable();

              this.clearTimeIndicatorInterval();
            };

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              if (nextProps.selectable && !this.props.selectable)
                this._selectable();
              if (!nextProps.selectable && this.props.selectable)
                this._teardownSelectable();
              this.slotMetrics = this.slotMetrics.update(nextProps);
            };

            _proto.componentDidUpdate = function componentDidUpdate(
              prevProps,
              prevState
            ) {
              var getNowChanged = !dates.eq(
                prevProps.getNow(),
                this.props.getNow(),
                "minutes"
              );

              if (prevProps.isNow !== this.props.isNow || getNowChanged) {
                this.clearTimeIndicatorInterval();

                if (this.props.isNow) {
                  var tail =
                    !getNowChanged &&
                    dates.eq(prevProps.date, this.props.date, "minutes") &&
                    prevState.timeIndicatorPosition ===
                      this.state.timeIndicatorPosition;
                  this.setTimeIndicatorPositionUpdateInterval(tail);
                }
              }
            };
            /**
             * @param tail {Boolean} - whether `positionTimeIndicator` call should be
             *   deferred or called upon setting interval (`true` - if deferred);
             */

            _proto.setTimeIndicatorPositionUpdateInterval = function setTimeIndicatorPositionUpdateInterval(
              tail
            ) {
              var _this2 = this;

              if (tail === void 0) {
                tail = false;
              }

              if (!this.intervalTriggered && !tail) {
                this.positionTimeIndicator();
              }

              this._timeIndicatorTimeout = window.setTimeout(function() {
                _this2.intervalTriggered = true;

                _this2.positionTimeIndicator();

                _this2.setTimeIndicatorPositionUpdateInterval();
              }, 60000);
            };

            _proto.clearTimeIndicatorInterval = function clearTimeIndicatorInterval() {
              this.intervalTriggered = false;
              window.clearTimeout(this._timeIndicatorTimeout);
            };

            _proto.positionTimeIndicator = function positionTimeIndicator() {
              var _this$props2 = this.props,
                min = _this$props2.min,
                max = _this$props2.max,
                getNow = _this$props2.getNow;
              var current = getNow();

              if (current >= min && current <= max) {
                var _this$slotMetrics$get = this.slotMetrics.getRange(
                    current,
                    current
                  ),
                  top = _this$slotMetrics$get.top;

                this.setState({
                  timeIndicatorPosition: top,
                });
              } else {
                this.clearTimeIndicatorInterval();
              }
            };

            _proto.render = function render() {
              var _this$props3 = this.props,
                max = _this$props3.max,
                rtl = _this$props3.rtl,
                isNow = _this$props3.isNow,
                resource = _this$props3.resource,
                accessors = _this$props3.accessors,
                localizer = _this$props3.localizer,
                _this$props3$getters = _this$props3.getters,
                dayProp = _this$props3$getters.dayProp,
                getters = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props3$getters, ["dayProp"]),
                _this$props3$componen = _this$props3.components,
                EventContainer = _this$props3$componen.eventContainerWrapper,
                components = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props3$componen, ["eventContainerWrapper"]);

              var slotMetrics = this.slotMetrics;
              var _this$state = this.state,
                selecting = _this$state.selecting,
                top = _this$state.top,
                height = _this$state.height,
                startDate = _this$state.startDate,
                endDate = _this$state.endDate;
              var selectDates = {
                start: startDate,
                end: endDate,
              };

              var _dayProp = dayProp(max),
                className = _dayProp.className,
                style = _dayProp.style;

              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  style: style,
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    className,
                    "rbc-day-slot",
                    "rbc-time-column",
                    isNow && "rbc-now",
                    isNow && "rbc-today", // WHY
                    selecting && "rbc-slot-selecting"
                  ),
                },
                slotMetrics.groups.map(function(grp, idx) {
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(TimeSlotGroup, {
                    key: idx,
                    group: grp,
                    resource: resource,
                    getters: getters,
                    components: components,
                  });
                }),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  EventContainer,
                  {
                    localizer: localizer,
                    resource: resource,
                    accessors: accessors,
                    getters: getters,
                    components: components,
                    slotMetrics: slotMetrics,
                  },
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "div",
                    {
                      className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                        "rbc-events-container",
                        rtl && "rtl"
                      ),
                    },
                    this.renderEvents()
                  )
                ),
                selecting &&
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "div",
                    {
                      className: "rbc-slot-selection",
                      style: {
                        top: top,
                        height: height,
                      },
                    },
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "span",
                      null,
                      localizer.format(selectDates, "selectRangeFormat")
                    )
                  ),
                isNow &&
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "div",
                    {
                      className: "rbc-current-time-indicator",
                      style: {
                        top: this.state.timeIndicatorPosition + "%",
                      },
                    }
                  )
              );
            };

            return DayColumn;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        DayColumn.propTypes = true
          ? {
              events:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              step:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
              min: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
              max: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              isNow: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              showMultiDayTimes:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              culture: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
              timeslots:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              eventOffset:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onSelecting:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              onSelectEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              onDoubleClickEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              className:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
              dragThroughEvents:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              resource: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any,
            }
          : undefined;
        DayColumn.defaultProps = {
          dragThroughEvents: true,
          timeslots: 2,
        };

        var TimeGutter =
          /*#__PURE__*/
          (function(_Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(TimeGutter, _Component);

            function TimeGutter() {
              var _this;

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              _this =
                _Component.call.apply(_Component, [this].concat(args)) || this;

              _this.renderSlot = function(value, idx) {
                if (idx !== 0) return null;
                var _this$props = _this.props,
                  localizer = _this$props.localizer,
                  getNow = _this$props.getNow;

                var isNow = _this.slotMetrics.dateIsInGroup(getNow(), idx);

                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "span",
                  {
                    className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                      "rbc-label",
                      isNow && "rbc-now"
                    ),
                  },
                  localizer.format(value, "timeGutterFormat")
                );
              };

              var _this$props2 = _this.props,
                min = _this$props2.min,
                max = _this$props2.max,
                timeslots = _this$props2.timeslots,
                step = _this$props2.step;
              _this.slotMetrics = getSlotMetrics$1({
                min: min,
                max: max,
                timeslots: timeslots,
                step: step,
              });
              return _this;
            }

            var _proto = TimeGutter.prototype;

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              var min = nextProps.min,
                max = nextProps.max,
                timeslots = nextProps.timeslots,
                step = nextProps.step;
              this.slotMetrics = this.slotMetrics.update({
                min: min,
                max: max,
                timeslots: timeslots,
                step: step,
              });
            };

            _proto.render = function render() {
              var _this2 = this;

              var _this$props3 = this.props,
                resource = _this$props3.resource,
                components = _this$props3.components;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-time-gutter rbc-time-column",
                },
                this.slotMetrics.groups.map(function(grp, idx) {
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(TimeSlotGroup, {
                    key: idx,
                    group: grp,
                    resource: resource,
                    components: components,
                    renderSlot: _this2.renderSlot,
                  });
                })
              );
            };

            return TimeGutter;
          })(react__WEBPACK_IMPORTED_MODULE_4__["Component"]);

        TimeGutter.propTypes = true
          ? {
              min: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
              max: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
              timeslots:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
              step:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              resource:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
            }
          : undefined;

        var ResourceHeader = function ResourceHeader(_ref) {
          var label = _ref.label;
          return react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
            react__WEBPACK_IMPORTED_MODULE_4__["default"].Fragment,
            null,
            label
          );
        };

        ResourceHeader.propTypes = true
          ? {
              label: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
              index: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              resource:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
            }
          : undefined;

        var TimeGridHeader =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(TimeGridHeader, _React$Component);

            function TimeGridHeader() {
              var _this;

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                ) || this;

              _this.handleHeaderClick = function(date, view, e) {
                e.preventDefault();
                notify(_this.props.onDrillDown, [date, view]);
              };

              _this.renderRow = function(resource) {
                var _this$props = _this.props,
                  events$$1 = _this$props.events,
                  rtl = _this$props.rtl,
                  selectable = _this$props.selectable,
                  getNow = _this$props.getNow,
                  range$$1 = _this$props.range,
                  getters = _this$props.getters,
                  localizer = _this$props.localizer,
                  accessors = _this$props.accessors,
                  components = _this$props.components;
                var resourceId = accessors.resourceId(resource);
                var eventsToDisplay = resource
                  ? events$$1.filter(function(event) {
                      return accessors.resource(event) === resourceId;
                    })
                  : events$$1;
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(DateContentRow, {
                  isAllDay: true,
                  rtl: rtl,
                  getNow: getNow,
                  minRows: 2,
                  range: range$$1,
                  events: eventsToDisplay,
                  resourceId: resourceId,
                  className: "rbc-allday-cell",
                  selectable: selectable,
                  selected: _this.props.selected,
                  components: components,
                  accessors: accessors,
                  getters: getters,
                  localizer: localizer,
                  onSelect: _this.props.onSelectEvent,
                  onDoubleClick: _this.props.onDoubleClickEvent,
                  onSelectSlot: _this.props.onSelectSlot,
                  longPressThreshold: _this.props.longPressThreshold,
                });
              };

              return _this;
            }

            var _proto = TimeGridHeader.prototype;

            _proto.renderHeaderCells = function renderHeaderCells(range$$1) {
              var _this2 = this;

              var _this$props2 = this.props,
                localizer = _this$props2.localizer,
                getDrilldownView = _this$props2.getDrilldownView,
                getNow = _this$props2.getNow,
                dayProp = _this$props2.getters.dayProp,
                _this$props2$componen = _this$props2.components.header,
                HeaderComponent =
                  _this$props2$componen === void 0
                    ? Header
                    : _this$props2$componen;
              var today = getNow();
              return range$$1.map(function(date, i) {
                var drilldownView = getDrilldownView(date);
                var label = localizer.format(date, "dayFormat");

                var _dayProp = dayProp(date),
                  className = _dayProp.className,
                  style = _dayProp.style;

                var header = react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(HeaderComponent, {
                  date: date,
                  label: label,
                  localizer: localizer,
                });
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "div",
                  {
                    key: i,
                    style: style,
                    className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                      "rbc-header",
                      className,
                      dates.eq(date, today, "day") && "rbc-today"
                    ),
                  },
                  drilldownView
                    ? react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "a",
                        {
                          href: "#",
                          onClick: function onClick(e) {
                            return _this2.handleHeaderClick(
                              date,
                              drilldownView,
                              e
                            );
                          },
                        },
                        header
                      )
                    : react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement("span", null, header)
                );
              });
            };

            _proto.render = function render() {
              var _this3 = this;

              var _this$props3 = this.props,
                width = _this$props3.width,
                rtl = _this$props3.rtl,
                resources = _this$props3.resources,
                range$$1 = _this$props3.range,
                events$$1 = _this$props3.events,
                getNow = _this$props3.getNow,
                accessors = _this$props3.accessors,
                selectable = _this$props3.selectable,
                components = _this$props3.components,
                getters = _this$props3.getters,
                scrollRef = _this$props3.scrollRef,
                localizer = _this$props3.localizer,
                isOverflowing = _this$props3.isOverflowing,
                _this$props3$componen = _this$props3.components,
                TimeGutterHeader = _this$props3$componen.timeGutterHeader,
                _this$props3$componen2 = _this$props3$componen.resourceHeader,
                ResourceHeaderComponent =
                  _this$props3$componen2 === void 0
                    ? ResourceHeader
                    : _this$props3$componen2;
              var style = {};

              if (isOverflowing) {
                style[rtl ? "marginLeft" : "marginRight"] =
                  dom_helpers_util_scrollbarSize__WEBPACK_IMPORTED_MODULE_31___default()() +
                  "px";
              }

              var groupedEvents = resources.groupEvents(events$$1);
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  style: style,
                  ref: scrollRef,
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    "rbc-time-header",
                    isOverflowing && "rbc-overflowing"
                  ),
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  {
                    className: "rbc-label rbc-time-header-gutter",
                    style: {
                      width: width,
                      minWidth: width,
                      maxWidth: width,
                    },
                  },
                  TimeGutterHeader &&
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      TimeGutterHeader,
                      null
                    )
                ),
                resources.map(function(_ref, idx) {
                  var id = _ref[0],
                    resource = _ref[1];
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    "div",
                    {
                      className: "rbc-time-header-content",
                      key: id || idx,
                    },
                    resource &&
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "div",
                        {
                          className: "rbc-row rbc-row-resource",
                          key: "resource_" + idx,
                        },
                        react__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ].createElement(
                          "div",
                          {
                            className: "rbc-header",
                          },
                          react__WEBPACK_IMPORTED_MODULE_4__[
                            "default"
                          ].createElement(ResourceHeaderComponent, {
                            index: idx,
                            label: accessors.resourceTitle(resource),
                            resource: resource,
                          })
                        )
                      ),
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "div",
                      {
                        className:
                          "rbc-row rbc-time-header-cell" +
                          (range$$1.length <= 1
                            ? " rbc-time-header-cell-single-day"
                            : ""),
                      },
                      _this3.renderHeaderCells(range$$1)
                    ),
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      DateContentRow,
                      {
                        isAllDay: true,
                        rtl: rtl,
                        getNow: getNow,
                        minRows: 2,
                        range: range$$1,
                        events: groupedEvents.get(id) || [],
                        resourceId: resource && id,
                        className: "rbc-allday-cell",
                        selectable: selectable,
                        selected: _this3.props.selected,
                        components: components,
                        accessors: accessors,
                        getters: getters,
                        localizer: localizer,
                        onSelect: _this3.props.onSelectEvent,
                        onDoubleClick: _this3.props.onDoubleClickEvent,
                        onSelectSlot: _this3.props.onSelectSlot,
                        longPressThreshold: _this3.props.longPressThreshold,
                      }
                    )
                  );
                })
              );
            };

            return TimeGridHeader;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        TimeGridHeader.propTypes = true
          ? {
              range:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              events:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              resources:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              isOverflowing:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              width: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClickEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDrillDown:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              getDrilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              scrollRef: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any,
            }
          : undefined;
        var NONE = {};

        function Resources(resources, accessors) {
          return {
            map: function map(fn) {
              if (!resources) return [fn([NONE, null], 0)];
              return resources.map(function(resource, idx) {
                return fn([accessors.resourceId(resource), resource], idx);
              });
            },
            groupEvents: function groupEvents(events$$1) {
              var eventsByResource = new Map();

              if (!resources) {
                // Return all events if resources are not provided
                eventsByResource.set(NONE, events$$1);
                return eventsByResource;
              }

              events$$1.forEach(function(event) {
                var id = accessors.resource(event) || NONE;
                var resourceEvents = eventsByResource.get(id) || [];
                resourceEvents.push(event);
                eventsByResource.set(id, resourceEvents);
              });
              return eventsByResource;
            },
          };
        }

        var TimeGrid =
          /*#__PURE__*/
          (function(_Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(TimeGrid, _Component);

            function TimeGrid(props) {
              var _this;

              _this = _Component.call(this, props) || this;

              _this.handleScroll = function(e) {
                if (_this.scrollRef.current) {
                  _this.scrollRef.current.scrollLeft = e.target.scrollLeft;
                }
              };

              _this.handleResize = function() {
                dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15___default.a.cancel(
                  _this.rafHandle
                );
                _this.rafHandle = dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15___default()(
                  _this.checkOverflow
                );
              };

              _this.gutterRef = function(ref) {
                _this.gutter =
                  ref &&
                  Object(react__WEBPACK_IMPORTED_MODULE_4__["findDOMNode"])(
                    ref
                  );
              };

              _this.handleSelectAlldayEvent = function() {
                //cancel any pending selections so only the event click goes through.
                _this.clearSelection();

                for (
                  var _len = arguments.length, args = new Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key];
                }

                notify(_this.props.onSelectEvent, args);
              };

              _this.handleSelectAllDaySlot = function(slots, slotInfo) {
                var onSelectSlot = _this.props.onSelectSlot;
                notify(onSelectSlot, {
                  slots: slots,
                  start: slots[0],
                  end: slots[slots.length - 1],
                  action: slotInfo.action,
                });
              };

              _this.checkOverflow = function() {
                if (_this._updatingOverflow) return;
                var isOverflowing =
                  _this.refs.content.scrollHeight >
                  _this.refs.content.clientHeight;

                if (_this.state.isOverflowing !== isOverflowing) {
                  _this._updatingOverflow = true;

                  _this.setState(
                    {
                      isOverflowing: isOverflowing,
                    },
                    function() {
                      _this._updatingOverflow = false;
                    }
                  );
                }
              };

              _this.memoizedResources = Object(
                memoize_one__WEBPACK_IMPORTED_MODULE_27__["default"]
              )(function(resources, accessors) {
                return Resources(resources, accessors);
              });
              _this.state = {
                gutterWidth: undefined,
                isOverflowing: null,
              };
              _this.scrollRef = react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createRef();
              return _this;
            }

            var _proto = TimeGrid.prototype;

            _proto.componentWillMount = function componentWillMount() {
              this.calculateScroll();
            };

            _proto.componentDidMount = function componentDidMount() {
              this.checkOverflow();

              if (this.props.width == null) {
                this.measureGutter();
              }

              this.applyScroll();
              window.addEventListener("resize", this.handleResize);
            };

            _proto.componentWillUnmount = function componentWillUnmount() {
              window.removeEventListener("resize", this.handleResize);
              dom_helpers_util_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_15___default.a.cancel(
                this.rafHandle
              );

              if (this.measureGutterAnimationFrameRequest) {
                window.cancelAnimationFrame(
                  this.measureGutterAnimationFrameRequest
                );
              }
            };

            _proto.componentDidUpdate = function componentDidUpdate() {
              if (this.props.width == null) {
                this.measureGutter();
              }

              this.applyScroll(); //this.checkOverflow()
            };

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              var _this$props = this.props,
                range$$1 = _this$props.range,
                scrollToTime = _this$props.scrollToTime; // When paginating, reset scroll

              if (
                !dates.eq(nextProps.range[0], range$$1[0], "minute") ||
                !dates.eq(nextProps.scrollToTime, scrollToTime, "minute")
              ) {
                this.calculateScroll(nextProps);
              }
            };

            _proto.renderEvents = function renderEvents(
              range$$1,
              events$$1,
              now
            ) {
              var _this2 = this;

              var _this$props2 = this.props,
                min = _this$props2.min,
                max = _this$props2.max,
                components = _this$props2.components,
                accessors = _this$props2.accessors,
                localizer = _this$props2.localizer;
              var resources = this.memoizedResources(
                this.props.resources,
                accessors
              );
              var groupedEvents = resources.groupEvents(events$$1);
              return resources.map(function(_ref, i) {
                var id = _ref[0],
                  resource = _ref[1];
                return range$$1.map(function(date, jj) {
                  var daysEvents = (groupedEvents.get(id) || []).filter(
                    function(event) {
                      return dates.inRange(
                        date,
                        accessors.start(event),
                        accessors.end(event),
                        "day"
                      );
                    }
                  );
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    DayColumn,
                    Object(
                      _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                        "default"
                      ]
                    )({}, _this2.props, {
                      localizer: localizer,
                      min: dates.merge(date, min),
                      max: dates.merge(date, max),
                      resource: resource && id,
                      components: components,
                      isNow: dates.eq(date, now, "day"),
                      key: i + "-" + jj,
                      date: date,
                      events: daysEvents,
                    })
                  );
                });
              });
            };

            _proto.render = function render() {
              var _this$props3 = this.props,
                events$$1 = _this$props3.events,
                range$$1 = _this$props3.range,
                width = _this$props3.width,
                selected = _this$props3.selected,
                getNow = _this$props3.getNow,
                resources = _this$props3.resources,
                components = _this$props3.components,
                accessors = _this$props3.accessors,
                getters = _this$props3.getters,
                localizer = _this$props3.localizer,
                min = _this$props3.min,
                max = _this$props3.max,
                showMultiDayTimes = _this$props3.showMultiDayTimes,
                longPressThreshold = _this$props3.longPressThreshold;
              width = width || this.state.gutterWidth;
              var start = range$$1[0],
                end = range$$1[range$$1.length - 1];
              this.slots = range$$1.length;
              var allDayEvents = [],
                rangeEvents = [];
              events$$1.forEach(function(event) {
                if (inRange(event, start, end, accessors)) {
                  var eStart = accessors.start(event),
                    eEnd = accessors.end(event);

                  if (
                    accessors.allDay(event) ||
                    (dates.isJustDate(eStart) && dates.isJustDate(eEnd)) ||
                    (!showMultiDayTimes && !dates.eq(eStart, eEnd, "day"))
                  ) {
                    allDayEvents.push(event);
                  } else {
                    rangeEvents.push(event);
                  }
                }
              });
              allDayEvents.sort(function(a, b) {
                return sortEvents(a, b, accessors);
              });
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    "rbc-time-view",
                    resources && "rbc-time-view-resources"
                  ),
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  TimeGridHeader,
                  {
                    range: range$$1,
                    events: allDayEvents,
                    width: width,
                    getNow: getNow,
                    localizer: localizer,
                    selected: selected,
                    resources: this.memoizedResources(resources, accessors),
                    selectable: this.props.selectable,
                    accessors: accessors,
                    getters: getters,
                    components: components,
                    scrollRef: this.scrollRef,
                    isOverflowing: this.state.isOverflowing,
                    longPressThreshold: longPressThreshold,
                    onSelectSlot: this.handleSelectAllDaySlot,
                    onSelectEvent: this.handleSelectAlldayEvent,
                    onDoubleClickEvent: this.props.onDoubleClickEvent,
                    onDrillDown: this.props.onDrillDown,
                    getDrilldownView: this.props.getDrilldownView,
                  }
                ),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "div",
                  {
                    ref: "content",
                    className: "rbc-time-content",
                    onScroll: this.handleScroll,
                  },
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    TimeGutter,
                    {
                      date: start,
                      ref: this.gutterRef,
                      localizer: localizer,
                      min: dates.merge(start, min),
                      max: dates.merge(start, max),
                      step: this.props.step,
                      getNow: this.props.getNow,
                      timeslots: this.props.timeslots,
                      components: components,
                      className: "rbc-time-gutter",
                    }
                  ),
                  this.renderEvents(range$$1, rangeEvents, getNow())
                )
              );
            };

            _proto.clearSelection = function clearSelection() {
              clearTimeout(this._selectTimer);
              this._pendingSelection = [];
            };

            _proto.measureGutter = function measureGutter() {
              var _this3 = this;

              if (this.measureGutterAnimationFrameRequest) {
                window.cancelAnimationFrame(
                  this.measureGutterAnimationFrameRequest
                );
              }

              this.measureGutterAnimationFrameRequest = window.requestAnimationFrame(
                function() {
                  var width = dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30___default()(
                    _this3.gutter
                  );

                  if (width && _this3.state.gutterWidth !== width) {
                    _this3.setState({
                      gutterWidth: width,
                    });
                  }
                }
              );
            };

            _proto.applyScroll = function applyScroll() {
              if (this._scrollRatio) {
                var content = this.refs.content;
                content.scrollTop = content.scrollHeight * this._scrollRatio; // Only do this once

                this._scrollRatio = null;
              }
            };

            _proto.calculateScroll = function calculateScroll(props) {
              if (props === void 0) {
                props = this.props;
              }

              var _props = props,
                min = _props.min,
                max = _props.max,
                scrollToTime = _props.scrollToTime;
              var diffMillis =
                scrollToTime - dates.startOf(scrollToTime, "day");
              var totalMillis = dates.diff(max, min);
              this._scrollRatio = diffMillis / totalMillis;
            };

            return TimeGrid;
          })(react__WEBPACK_IMPORTED_MODULE_4__["Component"]);

        TimeGrid.propTypes = true
          ? {
              events:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array
                  .isRequired,
              resources:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array,
              step: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              timeslots:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              range: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                  Date
                )
              ),
              min: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              max: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              getNow:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              scrollToTime: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              showMultiDayTimes:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
              width: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
              onNavigate:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectEnd:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectStart:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onSelectEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDoubleClickEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              onDrillDown:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
              getDrilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
            }
          : undefined;
        TimeGrid.defaultProps = {
          step: 30,
          timeslots: 2,
          min: dates.startOf(new Date(), "day"),
          max: dates.endOf(new Date(), "day"),
          scrollToTime: dates.startOf(new Date(), "day"),
        };

        var Day =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Day, _React$Component);

            function Day() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = Day.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                date = _this$props.date,
                props = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props, ["date"]);

              var range$$1 = Day.range(date);
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                TimeGrid,
                Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )({}, props, {
                  range: range$$1,
                  eventOffset: 10,
                })
              );
            };

            return Day;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Day.propTypes = true
          ? {
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
            }
          : undefined;

        Day.range = function(date) {
          return [dates.startOf(date, "day")];
        };

        Day.navigate = function(date, action) {
          switch (action) {
            case navigate.PREVIOUS:
              return dates.add(date, -1, "day");

            case navigate.NEXT:
              return dates.add(date, 1, "day");

            default:
              return date;
          }
        };

        Day.title = function(date, _ref) {
          var localizer = _ref.localizer;
          return localizer.format(date, "dayHeaderFormat");
        };

        var Week =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Week, _React$Component);

            function Week() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = Week.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                date = _this$props.date,
                props = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props, ["date"]);

              var range$$1 = Week.range(date, this.props);
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                TimeGrid,
                Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )({}, props, {
                  range: range$$1,
                  eventOffset: 15,
                })
              );
            };

            return Week;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Week.propTypes = true
          ? {
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
            }
          : undefined;
        Week.defaultProps = TimeGrid.defaultProps;

        Week.navigate = function(date, action) {
          switch (action) {
            case navigate.PREVIOUS:
              return dates.add(date, -1, "week");

            case navigate.NEXT:
              return dates.add(date, 1, "week");

            default:
              return date;
          }
        };

        Week.range = function(date, _ref) {
          var localizer = _ref.localizer;
          var firstOfWeek = localizer.startOfWeek();
          var start = dates.startOf(date, "week", firstOfWeek);
          var end = dates.endOf(date, "week", firstOfWeek);
          return dates.range(start, end);
        };

        Week.title = function(date, _ref2) {
          var localizer = _ref2.localizer;

          var _Week$range = Week.range(date, {
              localizer: localizer,
            }),
            start = _Week$range[0],
            rest = _Week$range.slice(1);

          return localizer.format(
            {
              start: start,
              end: rest.pop(),
            },
            "dayRangeHeaderFormat"
          );
        };

        function workWeekRange(date, options) {
          return Week.range(date, options).filter(function(d) {
            return [6, 0].indexOf(d.getDay()) === -1;
          });
        }

        var WorkWeek =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(WorkWeek, _React$Component);

            function WorkWeek() {
              return _React$Component.apply(this, arguments) || this;
            }

            var _proto = WorkWeek.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                date = _this$props.date,
                props = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props, ["date"]);

              var range$$1 = workWeekRange(date, this.props);
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                TimeGrid,
                Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )({}, props, {
                  range: range$$1,
                  eventOffset: 15,
                })
              );
            };

            return WorkWeek;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        WorkWeek.propTypes = true
          ? {
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ).isRequired,
            }
          : undefined;
        WorkWeek.defaultProps = TimeGrid.defaultProps;
        WorkWeek.range = workWeekRange;
        WorkWeek.navigate = Week.navigate;

        WorkWeek.title = function(date, _ref) {
          var localizer = _ref.localizer;

          var _workWeekRange = workWeekRange(date, {
              localizer: localizer,
            }),
            start = _workWeekRange[0],
            rest = _workWeekRange.slice(1);

          return localizer.format(
            {
              start: start,
              end: rest.pop(),
            },
            "dayRangeHeaderFormat"
          );
        };

        var Agenda =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Agenda, _React$Component);

            function Agenda() {
              var _this;

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                ) || this;

              _this.renderDay = function(day, events$$1, dayKey) {
                var _this$props = _this.props,
                  selected = _this$props.selected,
                  getters = _this$props.getters,
                  accessors = _this$props.accessors,
                  localizer = _this$props.localizer,
                  _this$props$component = _this$props.components,
                  Event = _this$props$component.event,
                  AgendaDate = _this$props$component.date;
                events$$1 = events$$1.filter(function(e) {
                  return inRange(
                    e,
                    dates.startOf(day, "day"),
                    dates.endOf(day, "day"),
                    accessors
                  );
                });
                return events$$1.map(function(event, idx) {
                  var title = accessors.title(event);
                  var end = accessors.end(event);
                  var start = accessors.start(event);
                  var userProps = getters.eventProp(
                    event,
                    start,
                    end,
                    isSelected(event, selected)
                  );
                  var dateLabel =
                    idx === 0 && localizer.format(day, "agendaDateFormat");
                  var first =
                    idx === 0
                      ? react__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ].createElement(
                          "td",
                          {
                            rowSpan: events$$1.length,
                            className: "rbc-agenda-date-cell",
                          },
                          AgendaDate
                            ? react__WEBPACK_IMPORTED_MODULE_4__[
                                "default"
                              ].createElement(AgendaDate, {
                                day: day,
                                label: dateLabel,
                              })
                            : dateLabel
                        )
                      : false;
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    "tr",
                    {
                      key: dayKey + "_" + idx,
                      className: userProps.className,
                      style: userProps.style,
                    },
                    first,
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "td",
                      {
                        className: "rbc-agenda-time-cell",
                      },
                      _this.timeRangeLabel(day, event)
                    ),
                    react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "td",
                      {
                        className: "rbc-agenda-event-cell",
                      },
                      Event
                        ? react__WEBPACK_IMPORTED_MODULE_4__[
                            "default"
                          ].createElement(Event, {
                            event: event,
                            title: title,
                          })
                        : title
                    )
                  );
                }, []);
              };

              _this.timeRangeLabel = function(day, event) {
                var _this$props2 = _this.props,
                  accessors = _this$props2.accessors,
                  localizer = _this$props2.localizer,
                  components = _this$props2.components;
                var labelClass = "",
                  TimeComponent = components.time,
                  label = localizer.messages.allDay;
                var end = accessors.end(event);
                var start = accessors.start(event);

                if (!accessors.allDay(event)) {
                  if (dates.eq(start, end, "day")) {
                    label = localizer.format(
                      {
                        start: start,
                        end: end,
                      },
                      "agendaTimeRangeFormat"
                    );
                  } else if (dates.eq(day, start, "day")) {
                    label = localizer.format(start, "agendaTimeFormat");
                  } else if (dates.eq(day, end, "day")) {
                    label = localizer.format(end, "agendaTimeFormat");
                  }
                }

                if (dates.gt(day, start, "day"))
                  labelClass = "rbc-continues-prior";
                if (dates.lt(day, end, "day"))
                  labelClass += " rbc-continues-after";
                return react__WEBPACK_IMPORTED_MODULE_4__[
                  "default"
                ].createElement(
                  "span",
                  {
                    className: labelClass.trim(),
                  },
                  TimeComponent
                    ? react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(TimeComponent, {
                        event: event,
                        day: day,
                        label: label,
                      })
                    : label
                );
              };

              _this._adjustHeader = function() {
                if (!_this.refs.tbody) return;
                var header = _this.refs.header;
                var firstRow = _this.refs.tbody.firstChild;
                if (!firstRow) return;
                var isOverflowing =
                  _this.refs.content.scrollHeight >
                  _this.refs.content.clientHeight;
                var widths = _this._widths || [];
                _this._widths = [
                  dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30___default()(
                    firstRow.children[0]
                  ),
                  dom_helpers_query_width__WEBPACK_IMPORTED_MODULE_30___default()(
                    firstRow.children[1]
                  ),
                ];

                if (
                  widths[0] !== _this._widths[0] ||
                  widths[1] !== _this._widths[1]
                ) {
                  _this.refs.dateCol.style.width = _this._widths[0] + "px";
                  _this.refs.timeCol.style.width = _this._widths[1] + "px";
                }

                if (isOverflowing) {
                  dom_helpers_class__WEBPACK_IMPORTED_MODULE_32___default.a.addClass(
                    header,
                    "rbc-header-overflowing"
                  );
                  header.style.marginRight =
                    dom_helpers_util_scrollbarSize__WEBPACK_IMPORTED_MODULE_31___default()() +
                    "px";
                } else {
                  dom_helpers_class__WEBPACK_IMPORTED_MODULE_32___default.a.removeClass(
                    header,
                    "rbc-header-overflowing"
                  );
                }
              };

              return _this;
            }

            var _proto = Agenda.prototype;

            _proto.componentDidMount = function componentDidMount() {
              this._adjustHeader();
            };

            _proto.componentDidUpdate = function componentDidUpdate() {
              this._adjustHeader();
            };

            _proto.render = function render() {
              var _this2 = this;

              var _this$props3 = this.props,
                length = _this$props3.length,
                date = _this$props3.date,
                events$$1 = _this$props3.events,
                accessors = _this$props3.accessors,
                localizer = _this$props3.localizer;
              var messages = localizer.messages;
              var end = dates.add(date, length, "day");
              var range$$1 = dates.range(date, end, "day");
              events$$1 = events$$1.filter(function(event) {
                return inRange(event, date, end, accessors);
              });
              events$$1.sort(function(a, b) {
                return +accessors.start(a) - +accessors.start(b);
              });
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-agenda-view",
                },
                events$$1.length !== 0
                  ? react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      react__WEBPACK_IMPORTED_MODULE_4__["default"].Fragment,
                      null,
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "table",
                        {
                          ref: "header",
                          className: "rbc-agenda-table",
                        },
                        react__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ].createElement(
                          "thead",
                          null,
                          react__WEBPACK_IMPORTED_MODULE_4__[
                            "default"
                          ].createElement(
                            "tr",
                            null,
                            react__WEBPACK_IMPORTED_MODULE_4__[
                              "default"
                            ].createElement(
                              "th",
                              {
                                className: "rbc-header",
                                ref: "dateCol",
                              },
                              messages.date
                            ),
                            react__WEBPACK_IMPORTED_MODULE_4__[
                              "default"
                            ].createElement(
                              "th",
                              {
                                className: "rbc-header",
                                ref: "timeCol",
                              },
                              messages.time
                            ),
                            react__WEBPACK_IMPORTED_MODULE_4__[
                              "default"
                            ].createElement(
                              "th",
                              {
                                className: "rbc-header",
                              },
                              messages.event
                            )
                          )
                        )
                      ),
                      react__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ].createElement(
                        "div",
                        {
                          className: "rbc-agenda-content",
                          ref: "content",
                        },
                        react__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ].createElement(
                          "table",
                          {
                            className: "rbc-agenda-table",
                          },
                          react__WEBPACK_IMPORTED_MODULE_4__[
                            "default"
                          ].createElement(
                            "tbody",
                            {
                              ref: "tbody",
                            },
                            range$$1.map(function(day, idx) {
                              return _this2.renderDay(day, events$$1, idx);
                            })
                          )
                        )
                      )
                    )
                  : react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                      "span",
                      {
                        className: "rbc-agenda-empty",
                      },
                      messages.noEventsInRange
                    )
              );
            };

            return Agenda;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Agenda.propTypes = true
          ? {
              events: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.array,
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),
              length:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number
                  .isRequired,
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              accessors:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              components:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              getters:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,
            }
          : undefined;
        Agenda.defaultProps = {
          length: 30,
        };

        Agenda.range = function(start, _ref) {
          var _ref$length = _ref.length,
            length =
              _ref$length === void 0 ? Agenda.defaultProps.length : _ref$length;
          var end = dates.add(start, length, "day");
          return {
            start: start,
            end: end,
          };
        };

        Agenda.navigate = function(date, action, _ref2) {
          var _ref2$length = _ref2.length,
            length =
              _ref2$length === void 0
                ? Agenda.defaultProps.length
                : _ref2$length;

          switch (action) {
            case navigate.PREVIOUS:
              return dates.add(date, -length, "day");

            case navigate.NEXT:
              return dates.add(date, length, "day");

            default:
              return date;
          }
        };

        Agenda.title = function(start, _ref3) {
          var _ref3$length = _ref3.length,
            length =
              _ref3$length === void 0
                ? Agenda.defaultProps.length
                : _ref3$length,
            localizer = _ref3.localizer;
          var end = dates.add(start, length, "day");
          return localizer.format(
            {
              start: start,
              end: end,
            },
            "agendaHeaderFormat"
          );
        };

        var _VIEWS;

        var VIEWS = ((_VIEWS = {}),
        (_VIEWS[views.MONTH] = MonthView),
        (_VIEWS[views.WEEK] = Week),
        (_VIEWS[views.WORK_WEEK] = WorkWeek),
        (_VIEWS[views.DAY] = Day),
        (_VIEWS[views.AGENDA] = Agenda),
        _VIEWS);

        function moveDate(View, _ref) {
          var action = _ref.action,
            date = _ref.date,
            today = _ref.today,
            props = Object(
              _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                "default"
              ]
            )(_ref, ["action", "date", "today"]);

          View = typeof View === "string" ? VIEWS[View] : View;

          switch (action) {
            case navigate.TODAY:
              date = today || new Date();
              break;

            case navigate.DATE:
              break;

            default:
              !(View && typeof View.navigate === "function")
                ? true
                  ? invariant__WEBPACK_IMPORTED_MODULE_10___default()(
                      false,
                      "Calendar View components must implement a static `.navigate(date, action)` method.s"
                    )
                  : undefined
                : void 0;
              date = View.navigate(date, action, props);
          }

          return date;
        }

        var Toolbar =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Toolbar, _React$Component);

            function Toolbar() {
              var _this;

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                ) || this;

              _this.navigate = function(action) {
                _this.props.onNavigate(action);
              };

              _this.view = function(view) {
                _this.props.onView(view);
              };

              return _this;
            }

            var _proto = Toolbar.prototype;

            _proto.render = function render() {
              var _this$props = this.props,
                messages = _this$props.localizer.messages,
                label = _this$props.label;
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                {
                  className: "rbc-toolbar",
                },
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "span",
                  {
                    className: "rbc-btn-group",
                  },
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "button",
                    {
                      type: "button",
                      onClick: this.navigate.bind(null, navigate.TODAY),
                    },
                    messages.today
                  ),
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "button",
                    {
                      type: "button",
                      onClick: this.navigate.bind(null, navigate.PREVIOUS),
                    },
                    messages.previous
                  ),
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    "button",
                    {
                      type: "button",
                      onClick: this.navigate.bind(null, navigate.NEXT),
                    },
                    messages.next
                  )
                ),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "span",
                  {
                    className: "rbc-toolbar-label",
                  },
                  label
                ),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  "span",
                  {
                    className: "rbc-btn-group",
                  },
                  this.viewNamesGroup(messages)
                )
              );
            };

            _proto.viewNamesGroup = function viewNamesGroup(messages) {
              var _this2 = this;

              var viewNames = this.props.views;
              var view = this.props.view;

              if (viewNames.length > 1) {
                return viewNames.map(function(name) {
                  return react__WEBPACK_IMPORTED_MODULE_4__[
                    "default"
                  ].createElement(
                    "button",
                    {
                      type: "button",
                      key: name,
                      className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                        {
                          "rbc-active": view === name,
                        }
                      ),
                      onClick: _this2.view.bind(null, name),
                    },
                    messages[name]
                  );
                });
              }
            };

            return Toolbar;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Toolbar.propTypes = true
          ? {
              view:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string
                  .isRequired,
              views: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string
              ).isRequired,
              label:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node
                  .isRequired,
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
              onNavigate:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
              onView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
                  .isRequired,
            }
          : undefined;
        /**
         * Retrieve via an accessor-like property
         *
         *    accessor(obj, 'name')   // => retrieves obj['name']
         *    accessor(data, func)    // => retrieves func(data)
         *    ... otherwise null
         */

        function accessor$1(data, field) {
          var value = null;
          if (typeof field === "function") value = field(data);
          else if (
            typeof field === "string" &&
            _typeof(data) === "object" &&
            data != null &&
            field in data
          )
            value = data[field];
          return value;
        }

        var wrapAccessor = function wrapAccessor(acc) {
          return function(data) {
            return accessor$1(data, acc);
          };
        };

        function viewNames$1(_views) {
          return !Array.isArray(_views) ? Object.keys(_views) : _views;
        }

        function isValidView(view, _ref) {
          var _views = _ref.views;
          var names = viewNames$1(_views);
          return names.indexOf(view) !== -1;
        }
        /**
         * react-big-calendar is a full featured Calendar component for managing events and dates. It uses
         * modern `flexbox` for layout, making it super responsive and performant. Leaving most of the layout heavy lifting
         * to the browser. __note:__ The default styles use `height: 100%` which means your container must set an explicit
         * height (feel free to adjust the styles to suit your specific needs).
         *
         * Big Calendar is unopiniated about editing and moving events, preferring to let you implement it in a way that makes
         * the most sense to your app. It also tries not to be prescriptive about your event data structures, just tell it
         * how to find the start and end datetimes and you can pass it whatever you want.
         *
         * One thing to note is that, `react-big-calendar` treats event start/end dates as an _exclusive_ range.
         * which means that the event spans up to, but not including, the end date. In the case
         * of displaying events on whole days, end dates are rounded _up_ to the next day. So an
         * event ending on `Apr 8th 12:00:00 am` will not appear on the 8th, whereas one ending
         * on `Apr 8th 12:01:00 am` will. If you want _inclusive_ ranges consider providing a
         * function `endAccessor` that returns the end date + 1 day for those events that end at midnight.
         */

        var Calendar =
          /*#__PURE__*/
          (function(_React$Component) {
            Object(
              _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[
                "default"
              ]
            )(Calendar, _React$Component);

            function Calendar() {
              var _this;

              for (
                var _len = arguments.length, _args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                _args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(_args)
                ) || this;

              _this.getViews = function() {
                var views$$1 = _this.props.views;

                if (Array.isArray(views$$1)) {
                  return lodash_transform__WEBPACK_IMPORTED_MODULE_35___default()(
                    views$$1,
                    function(obj, name) {
                      return (obj[name] = VIEWS[name]);
                    },
                    {}
                  );
                }

                if (_typeof(views$$1) === "object") {
                  return lodash_mapValues__WEBPACK_IMPORTED_MODULE_36___default()(
                    views$$1,
                    function(value, key) {
                      if (value === true) {
                        return VIEWS[key];
                      }

                      return value;
                    }
                  );
                }

                return VIEWS;
              };

              _this.getView = function() {
                var views$$1 = _this.getViews();

                return views$$1[_this.props.view];
              };

              _this.getDrilldownView = function(date) {
                var _this$props = _this.props,
                  view = _this$props.view,
                  drilldownView = _this$props.drilldownView,
                  getDrilldownView = _this$props.getDrilldownView;
                if (!getDrilldownView) return drilldownView;
                return getDrilldownView(
                  date,
                  view,
                  Object.keys(_this.getViews())
                );
              };

              _this.handleRangeChange = function(date, viewComponent, view) {
                var _this$props2 = _this.props,
                  onRangeChange = _this$props2.onRangeChange,
                  localizer = _this$props2.localizer;

                if (onRangeChange) {
                  if (viewComponent.range) {
                    onRangeChange(
                      viewComponent.range(date, {
                        localizer: localizer,
                      }),
                      view
                    );
                  } else {
                    true
                      ? warning__WEBPACK_IMPORTED_MODULE_9___default()(
                          true,
                          "onRangeChange prop not supported for this view"
                        )
                      : undefined;
                  }
                }
              };

              _this.handleNavigate = function(action, newDate) {
                var _this$props3 = _this.props,
                  view = _this$props3.view,
                  date = _this$props3.date,
                  getNow = _this$props3.getNow,
                  onNavigate = _this$props3.onNavigate,
                  props = Object(
                    _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                      "default"
                    ]
                  )(_this$props3, ["view", "date", "getNow", "onNavigate"]);

                var ViewComponent = _this.getView();

                var today = getNow();
                date = moveDate(
                  ViewComponent,
                  Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )({}, props, {
                    action: action,
                    date: newDate || date || today,
                    today: today,
                  })
                );
                onNavigate(date, view, action);

                _this.handleRangeChange(date, ViewComponent);
              };

              _this.handleViewChange = function(view) {
                if (
                  view !== _this.props.view &&
                  isValidView(view, _this.props)
                ) {
                  _this.props.onView(view);
                }

                var views$$1 = _this.getViews();

                _this.handleRangeChange(
                  _this.props.date || _this.props.getNow(),
                  views$$1[view],
                  view
                );
              };

              _this.handleSelectEvent = function() {
                for (
                  var _len2 = arguments.length,
                    args = new Array(_len2),
                    _key2 = 0;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2] = arguments[_key2];
                }

                notify(_this.props.onSelectEvent, args);
              };

              _this.handleDoubleClickEvent = function() {
                for (
                  var _len3 = arguments.length,
                    args = new Array(_len3),
                    _key3 = 0;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3] = arguments[_key3];
                }

                notify(_this.props.onDoubleClickEvent, args);
              };

              _this.handleSelectSlot = function(slotInfo) {
                notify(_this.props.onSelectSlot, slotInfo);
              };

              _this.handleDrillDown = function(date, view) {
                var onDrillDown = _this.props.onDrillDown;

                if (onDrillDown) {
                  onDrillDown(date, view, _this.drilldownView);
                  return;
                }

                if (view) _this.handleViewChange(view);

                _this.handleNavigate(navigate.DATE, date);
              };

              _this.state = {
                context: _this.getContext(_this.props),
              };
              return _this;
            }

            var _proto = Calendar.prototype;

            _proto.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              this.setState({
                context: this.getContext(nextProps),
              });
            };

            _proto.getContext = function getContext(_ref2) {
              var startAccessor = _ref2.startAccessor,
                endAccessor = _ref2.endAccessor,
                allDayAccessor = _ref2.allDayAccessor,
                tooltipAccessor = _ref2.tooltipAccessor,
                titleAccessor = _ref2.titleAccessor,
                resourceAccessor = _ref2.resourceAccessor,
                resourceIdAccessor = _ref2.resourceIdAccessor,
                resourceTitleAccessor = _ref2.resourceTitleAccessor,
                eventPropGetter = _ref2.eventPropGetter,
                slotPropGetter = _ref2.slotPropGetter,
                dayPropGetter = _ref2.dayPropGetter,
                view = _ref2.view,
                views$$1 = _ref2.views,
                localizer = _ref2.localizer,
                culture = _ref2.culture,
                _ref2$messages = _ref2.messages,
                messages$$1 = _ref2$messages === void 0 ? {} : _ref2$messages,
                _ref2$components = _ref2.components,
                components =
                  _ref2$components === void 0 ? {} : _ref2$components,
                _ref2$formats = _ref2.formats,
                formats = _ref2$formats === void 0 ? {} : _ref2$formats;
              var names = viewNames$1(views$$1);
              var msgs = messages(messages$$1);
              return {
                viewNames: names,
                localizer: mergeWithDefaults(localizer, culture, formats, msgs),
                getters: {
                  eventProp: function eventProp() {
                    return (
                      (eventPropGetter &&
                        eventPropGetter.apply(void 0, arguments)) ||
                      {}
                    );
                  },
                  slotProp: function slotProp() {
                    return (
                      (slotPropGetter &&
                        slotPropGetter.apply(void 0, arguments)) ||
                      {}
                    );
                  },
                  dayProp: function dayProp() {
                    return (
                      (dayPropGetter &&
                        dayPropGetter.apply(void 0, arguments)) ||
                      {}
                    );
                  },
                },
                components: lodash_defaults__WEBPACK_IMPORTED_MODULE_34___default()(
                  components[view] || {},
                  lodash_omit__WEBPACK_IMPORTED_MODULE_33___default()(
                    components,
                    names
                  ),
                  {
                    eventWrapper: NoopWrapper,
                    eventContainerWrapper: NoopWrapper,
                    dayWrapper: NoopWrapper,
                    dateCellWrapper: NoopWrapper,
                    weekWrapper: NoopWrapper,
                    timeSlotWrapper: NoopWrapper,
                  }
                ),
                accessors: {
                  start: wrapAccessor(startAccessor),
                  end: wrapAccessor(endAccessor),
                  allDay: wrapAccessor(allDayAccessor),
                  tooltip: wrapAccessor(tooltipAccessor),
                  title: wrapAccessor(titleAccessor),
                  resource: wrapAccessor(resourceAccessor),
                  resourceId: wrapAccessor(resourceIdAccessor),
                  resourceTitle: wrapAccessor(resourceTitleAccessor),
                },
              };
            };

            _proto.render = function render() {
              var _this$props4 = this.props,
                view = _this$props4.view,
                toolbar = _this$props4.toolbar,
                events$$1 = _this$props4.events,
                style = _this$props4.style,
                className = _this$props4.className,
                elementProps = _this$props4.elementProps,
                current = _this$props4.date,
                getNow = _this$props4.getNow,
                length = _this$props4.length,
                showMultiDayTimes = _this$props4.showMultiDayTimes,
                onShowMore = _this$props4.onShowMore,
                _0 = _this$props4.components,
                _1 = _this$props4.formats,
                _2 = _this$props4.messages,
                _3 = _this$props4.culture,
                props = Object(
                  _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]
                )(_this$props4, [
                  "view",
                  "toolbar",
                  "events",
                  "style",
                  "className",
                  "elementProps",
                  "date",
                  "getNow",
                  "length",
                  "showMultiDayTimes",
                  "onShowMore",
                  "components",
                  "formats",
                  "messages",
                  "culture",
                ]);

              current = current || getNow();
              var View = this.getView();
              var _this$state$context = this.state.context,
                accessors = _this$state$context.accessors,
                components = _this$state$context.components,
                getters = _this$state$context.getters,
                localizer = _this$state$context.localizer,
                viewNames = _this$state$context.viewNames;
              var CalToolbar = components.toolbar || Toolbar;
              var label = View.title(current, {
                localizer: localizer,
                length: length,
              });
              return react__WEBPACK_IMPORTED_MODULE_4__[
                "default"
              ].createElement(
                "div",
                Object(
                  _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                    "default"
                  ]
                )({}, elementProps, {
                  className: classnames__WEBPACK_IMPORTED_MODULE_6___default()(
                    className,
                    "rbc-calendar",
                    props.rtl && "rbc-is-rtl"
                  ),
                  style: style,
                }),
                toolbar &&
                  react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                    CalToolbar,
                    {
                      date: current,
                      view: view,
                      views: viewNames,
                      label: label,
                      onView: this.handleViewChange,
                      onNavigate: this.handleNavigate,
                      localizer: localizer,
                    }
                  ),
                react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(
                  View,
                  Object(
                    _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
                      "default"
                    ]
                  )(
                    {
                      ref: "view",
                    },
                    props,
                    {
                      events: events$$1,
                      date: current,
                      getNow: getNow,
                      length: length,
                      localizer: localizer,
                      getters: getters,
                      components: components,
                      accessors: accessors,
                      showMultiDayTimes: showMultiDayTimes,
                      getDrilldownView: this.getDrilldownView,
                      onNavigate: this.handleNavigate,
                      onDrillDown: this.handleDrillDown,
                      onSelectEvent: this.handleSelectEvent,
                      onDoubleClickEvent: this.handleDoubleClickEvent,
                      onSelectSlot: this.handleSelectSlot,
                      onShowMore: onShowMore,
                    }
                  )
                )
              );
            };
            /**
             *
             * @param date
             * @param viewComponent
             * @param {'month'|'week'|'work_week'|'day'|'agenda'} [view] - optional
             * parameter. It appears when range change on view changing. It could be handy
             * when you need to have both: range and view type at once, i.e. for manage rbc
             * state via url
             */

            return Calendar;
          })(react__WEBPACK_IMPORTED_MODULE_4__["default"].Component);

        Calendar.defaultProps = {
          elementProps: {},
          popup: false,
          toolbar: true,
          view: views.MONTH,
          views: [views.MONTH, views.WEEK, views.DAY, views.AGENDA],
          step: 30,
          length: 30,
          drilldownView: views.DAY,
          titleAccessor: "title",
          tooltipAccessor: "title",
          allDayAccessor: "allDay",
          startAccessor: "start",
          endAccessor: "end",
          resourceAccessor: "resourceId",
          resourceIdAccessor: "id",
          resourceTitleAccessor: "title",
          longPressThreshold: 250,
          getNow: function getNow() {
            return new Date();
          },
        };
        Calendar.propTypes = true
          ? {
              localizer:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
                  .isRequired,

              /**
               * Props passed to main calendar `<div>`.
               *
               */
              elementProps:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,

              /**
               * The current date value of the calendar. Determines the visible view range.
               * If `date` is omitted then the result of `getNow` is used; otherwise the
               * current date is used.
               *
               * @controllable onNavigate
               */
              date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),

              /**
               * The current view of the calendar.
               *
               * @default 'month'
               * @controllable onView
               */
              view: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

              /**
               * The initial view set for the Calendar.
               * @type Calendar.Views ('month'|'week'|'work_week'|'day'|'agenda')
               * @default 'month'
               */
              defaultView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

              /**
               * An array of event objects to display on the calendar. Events objects
               * can be any shape, as long as the Calendar knows how to retrieve the
               * following details of the event:
               *
               *  - start time
               *  - end time
               *  - title
               *  - whether its an "all day" event or not
               *  - any resource the event may be related to
               *
               * Each of these properties can be customized or generated dynamically by
               * setting the various "accessor" props. Without any configuration the default
               * event should look like:
               *
               * ```js
               * Event {
               *   title: string,
               *   start: Date,
               *   end: Date,
               *   allDay?: boolean
               *   resource?: any,
               * }
               * ```
               */
              events: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
              ),

              /**
               * Accessor for the event title, used to display event information. Should
               * resolve to a `renderable` value.
               *
               * ```js
               * string | (event: Object) => string
               * ```
               *
               * @type {(func|string)}
               */
              titleAccessor: accessor,

              /**
               * Accessor for the event tooltip. Should
               * resolve to a `renderable` value. Removes the tooltip if null.
               *
               * ```js
               * string | (event: Object) => string
               * ```
               *
               * @type {(func|string)}
               */
              tooltipAccessor: accessor,

              /**
               * Determines whether the event should be considered an "all day" event and ignore time.
               * Must resolve to a `boolean` value.
               *
               * ```js
               * string | (event: Object) => boolean
               * ```
               *
               * @type {(func|string)}
               */
              allDayAccessor: accessor,

              /**
               * The start date/time of the event. Must resolve to a JavaScript `Date` object.
               *
               * ```js
               * string | (event: Object) => Date
               * ```
               *
               * @type {(func|string)}
               */
              startAccessor: accessor,

              /**
               * The end date/time of the event. Must resolve to a JavaScript `Date` object.
               *
               * ```js
               * string | (event: Object) => Date
               * ```
               *
               * @type {(func|string)}
               */
              endAccessor: accessor,

              /**
               * Returns the id of the `resource` that the event is a member of. This
               * id should match at least one resource in the `resources` array.
               *
               * ```js
               * string | (event: Object) => Date
               * ```
               *
               * @type {(func|string)}
               */
              resourceAccessor: accessor,

              /**
               * An array of resource objects that map events to a specific resource.
               * Resource objects, like events, can be any shape or have any properties,
               * but should be uniquly identifiable via the `resourceIdAccessor`, as
               * well as a "title" or name as provided by the `resourceTitleAccessor` prop.
               */
              resources: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.arrayOf(
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object
              ),

              /**
               * Provides a unique identifier for each resource in the `resources` array
               *
               * ```js
               * string | (resource: Object) => any
               * ```
               *
               * @type {(func|string)}
               */
              resourceIdAccessor: accessor,

              /**
               * Provides a human readable name for the resource object, used in headers.
               *
               * ```js
               * string | (resource: Object) => any
               * ```
               *
               * @type {(func|string)}
               */
              resourceTitleAccessor: accessor,

              /**
               * Determines the current date/time which is highlighted in the views.
               *
               * The value affects which day is shaded and which time is shown as
               * the current time. It also affects the date used by the Today button in
               * the toolbar.
               *
               * Providing a value here can be useful when you are implementing time zones
               * using the `startAccessor` and `endAccessor` properties.
               *
               * @type {func}
               * @default () => new Date()
               */
              getNow: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when the `date` value changes.
               *
               * @controllable date
               */
              onNavigate:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when the `view` value changes.
               *
               * @controllable view
               */
              onView: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when date header, or the truncated events links are clicked
               *
               */
              onDrillDown:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               *
               * ```js
               * (dates: Date[] | { start: Date; end: Date }, view?: 'month'|'week'|'work_week'|'day'|'agenda') => void
               * ```
               *
               * Callback fired when the visible date range changes. Returns an Array of dates
               * or an object with start and end dates for BUILTIN views. Optionally new `view`
               * will be returned when callback called after view change.
               *
               * Custom views may return something different.
               */
              onRangeChange:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * A callback fired when a date selection is made. Only fires when `selectable` is `true`.
               *
               * ```js
               * (
               *   slotInfo: {
               *     start: Date,
               *     end: Date,
               *     slots: Array<Date>,
               *     action: "select" | "click" | "doubleClick",
               *     bounds: ?{ // For "select" action
               *       x: number,
               *       y: number,
               *       top: number,
               *       right: number,
               *       left: number,
               *       bottom: number,
               *     },
               *     box: ?{ // For "click" or "doubleClick" actions
               *       clientX: number,
               *       clientY: number,
               *       x: number,
               *       y: number,
               *     },
               *   }
               * ) => any
               * ```
               */
              onSelectSlot:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when a calendar event is selected.
               *
               * ```js
               * (event: Object, e: SyntheticEvent) => any
               * ```
               *
               * @controllable selected
               */
              onSelectEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when a calendar event is clicked twice.
               *
               * ```js
               * (event: Object, e: SyntheticEvent) => void
               * ```
               */
              onDoubleClickEvent:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when dragging a selection in the Time views.
               *
               * Returning `false` from the handler will prevent a selection.
               *
               * ```js
               * (range: { start: Date, end: Date }) => ?boolean
               * ```
               */
              onSelecting:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Callback fired when a +{count} more is clicked
               *
               * ```js
               * (events: Object, date: Date) => any
               * ```
               */
              onShowMore:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * The selected event, if any.
               */
              selected:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,

              /**
   * An array of built-in view names to allow the calendar to display.
   * accepts either an array of builtin view names,
   *
   * ```jsx
   * views={['month', 'day', 'agenda']}
   * ```
   * or an object hash of the view name and the component (or boolean for builtin).
   *
   * ```jsx
   * views={{
   *   month: true,
   *   week: false,
   *   myweek: WorkWeekViewComponent,
   * }}
   * ```
   *
   * Custom views can be any React component, that implements the following
   * interface:
   *
   * ```js
   * interface View {
   *   static title(date: Date, { formats: DateFormat[], culture: string?, ...props }): string
   *   static navigate(date: Date, action: 'PREV' | 'NEXT' | 'DATE'): Date
   * }
   * ```
   *
   * @type Calendar.Views ('month'|'week'|'work_week'|'day'|'agenda')
   * @View
   ['month', 'week', 'day', 'agenda']
   */
              views: views$1,

              /**
               * The string name of the destination view for drill-down actions, such
               * as clicking a date header, or the truncated events links. If
               * `getDrilldownView` is also specified it will be used instead.
               *
               * Set to `null` to disable drill-down actions.
               *
               * ```js
               * <BigCalendar
               *   drilldownView="agenda"
               * />
               * ```
               */
              drilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

              /**
               * Functionally equivalent to `drilldownView`, but accepts a function
               * that can return a view name. It's useful for customizing the drill-down
               * actions depending on the target date and triggering view.
               *
               * Return `null` to disable drill-down actions.
               *
               * ```js
               * <BigCalendar
               *   getDrilldownView={(targetDate, currentViewName, configuredViewNames) =>
               *     if (currentViewName === 'month' && configuredViewNames.includes('week'))
               *       return 'week'
               *
               *     return null;
               *   }}
               * />
               * ```
               */
              getDrilldownView:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Determines the end date from date prop in the agenda view
               * date prop + length (in number of days) = end date
               */
              length: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,

              /**
               * Determines whether the toolbar is displayed
               */
              toolbar: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

              /**
               * Show truncated events in an overlay when you click the "+_x_ more" link.
               */
              popup: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

              /**
               * Distance in pixels, from the edges of the viewport, the "show more" overlay should be positioned.
               *
               * ```jsx
               * <BigCalendar popupOffset={30}/>
               * <BigCalendar popupOffset={{x: 30, y: 20}}/>
               * ```
               */
              popupOffset: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType(
                [
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
                    x: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                    y: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
                  }),
                ]
              ),

              /**
               * Allows mouse selection of ranges of dates/times.
               *
               * The 'ignoreEvents' option prevents selection code from running when a
               * drag begins over an event. Useful when you want custom event click or drag
               * logic
               */
              selectable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(
                [true, false, "ignoreEvents"]
              ),

              /**
               * Specifies the number of miliseconds the user must press and hold on the screen for a touch
               * to be considered a "long press." Long presses are used for time slot selection on touch
               * devices.
               *
               * @type {number}
               * @default 250
               */
              longPressThreshold:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,

              /**
               * Determines the selectable time increments in week and day views
               */
              step: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,

              /**
               * The number of slots per "section" in the time grid views. Adjust with `step`
               * to change the default of 1 hour long groups, with 30 minute slots.
               */
              timeslots:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,

              /**
               *Switch the calendar to a `right-to-left` read direction.
               */
              rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

              /**
               * Optionally provide a function that returns an object of className or style props
               * to be applied to the the event node.
               *
               * ```js
               * (
               * 	event: Object,
               * 	start: Date,
               * 	end: Date,
               * 	isSelected: boolean
               * ) => { className?: string, style?: Object }
               * ```
               */
              eventPropGetter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Optionally provide a function that returns an object of className or style props
               * to be applied to the the time-slot node. Caution! Styles that change layout or
               * position may break the calendar in unexpected ways.
               *
               * ```js
               * (date: Date, resourceId: (number|string)) => { className?: string, style?: Object }
               * ```
               */
              slotPropGetter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Optionally provide a function that returns an object of className or style props
               * to be applied to the the day background. Caution! Styles that change layout or
               * position may break the calendar in unexpected ways.
               *
               * ```js
               * (date: Date) => { className?: string, style?: Object }
               * ```
               */
              dayPropGetter:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

              /**
               * Support to show multi-day events with specific start and end times in the
               * main time grid (rather than in the all day header).
               *
               * **Note: This may cause calendars with several events to look very busy in
               * the week and day views.**
               */
              showMultiDayTimes:
                prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

              /**
               * Constrains the minimum _time_ of the Day and Week views.
               */
              min: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),

              /**
               * Constrains the maximum _time_ of the Day and Week views.
               */
              max: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),

              /**
               * Determines how far down the scroll pane is initially scrolled down.
               */
              scrollToTime: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.instanceOf(
                Date
              ),

              /**
               * Specify a specific culture code for the Calendar.
               *
               * **Note: it's generally better to handle this globally via your i18n library.**
               */
              culture: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

              /**
               * Localizer specific formats, tell the Calendar how to format and display dates.
               *
               * `format` types are dependent on the configured localizer; both Moment and Globalize
               * accept strings of tokens according to their own specification, such as: `'DD mm yyyy'`.
               *
               * ```jsx
               * let formats = {
               *   dateFormat: 'dd',
               *
               *   dayFormat: (date, , localizer) =>
               *     localizer.format(date, 'DDD', culture),
               *
               *   dayRangeHeaderFormat: ({ start, end }, culture, localizer) =>
               *     localizer.format(start, { date: 'short' }, culture) + '  ' +
               *     localizer.format(end, { date: 'short' }, culture)
               * }
               *
               * <Calendar formats={formats} />
               * ```
               *
               * All localizers accept a function of
               * the form `(date: Date, culture: ?string, localizer: Localizer) -> string`
               */
              formats: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
                /**
                 * Format for the day of the month heading in the Month view.
                 * e.g. "01", "02", "03", etc
                 */
                dateFormat: dateFormat,

                /**
                 * A day of the week format for Week and Day headings,
                 * e.g. "Wed 01/04"
                 *
                 */
                dayFormat: dateFormat,

                /**
                 * Week day name format for the Month week day headings,
                 * e.g: "Sun", "Mon", "Tue", etc
                 *
                 */
                weekdayFormat: dateFormat,

                /**
                 * The timestamp cell formats in Week and Time views, e.g. "4:00 AM"
                 */
                timeGutterFormat: dateFormat,

                /**
                 * Toolbar header format for the Month view, e.g "2015 April"
                 *
                 */
                monthHeaderFormat: dateFormat,

                /**
                 * Toolbar header format for the Week views, e.g. "Mar 29 - Apr 04"
                 */
                dayRangeHeaderFormat: dateRangeFormat,

                /**
                 * Toolbar header format for the Day view, e.g. "Wednesday Apr 01"
                 */
                dayHeaderFormat: dateFormat,

                /**
                 * Toolbar header format for the Agenda view, e.g. "4/1/2015  5/1/2015"
                 */
                agendaHeaderFormat: dateRangeFormat,

                /**
                 * A time range format for selecting time slots, e.g "8:00am  2:00pm"
                 */
                selectRangeFormat: dateRangeFormat,
                agendaDateFormat: dateFormat,
                agendaTimeFormat: dateFormat,
                agendaTimeRangeFormat: dateRangeFormat,

                /**
                 * Time range displayed on events.
                 */
                eventTimeRangeFormat: dateRangeFormat,

                /**
                 * An optional event time range for events that continue onto another day
                 */
                eventTimeRangeStartFormat: dateFormat,

                /**
                 * An optional event time range for events that continue from another day
                 */
                eventTimeRangeEndFormat: dateFormat,
              }),

              /**
               * Customize how different sections of the calendar render by providing custom Components.
               * In particular the `Event` component can be specified for the entire calendar, or you can
               * provide an individual component for each view type.
               *
               * ```jsx
               * let components = {
               *   event: MyEvent, // used by each view (Month, Day, Week)
               *   eventWrapper: MyEventWrapper,
               *   eventContainerWrapper: MyEventContainerWrapper,
               *   dayWrapper: MyDayWrapper,
               *   dateCellWrapper: MyDateCellWrapper,
               *   timeSlotWrapper: MyTimeSlotWrapper,
               *   timeGutterHeader: MyTimeGutterWrapper,
               *   toolbar: MyToolbar,
               *   agenda: {
               *   	 event: MyAgendaEvent // with the agenda view use a different component to render events
               *     time: MyAgendaTime,
               *     date: MyAgendaDate,
               *   },
               *   day: {
               *     header: MyDayHeader,
               *     event: MyDayEvent,
               *   },
               *   week: {
               *     header: MyWeekHeader,
               *     event: MyWeekEvent,
               *   },
               *   month: {
               *     header: MyMonthHeader,
               *     dateHeader: MyMonthDateHeader,
               *     event: MyMonthEvent,
               *   }
               * }
               * <Calendar components={components} />
               * ```
               */
              components: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape(
                {
                  event:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  eventWrapper:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  eventContainerWrapper:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  dayWrapper:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  dateCellWrapper:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  timeSlotWrapper:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  timeGutterHeader:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  toolbar:
                    prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  agenda: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape(
                    {
                      date:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                      time:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                      event:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                    }
                  ),
                  day: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({
                    header:
                      prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                    event:
                      prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                  }),
                  week: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape(
                    {
                      header:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                      event:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                    }
                  ),
                  month: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape(
                    {
                      header:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                      dateHeader:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                      event:
                        prop_types_extra_lib_elementType__WEBPACK_IMPORTED_MODULE_7___default.a,
                    }
                  ),
                }
              ),

              /**
               * String messages used throughout the component, override to provide localizations
               */
              messages: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape(
                {
                  allDay:
                    prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  previous:
                    prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  next: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  today: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  month: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  week: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  day: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  agenda:
                    prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  date: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  time: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  event: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  noEventsInRange:
                    prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node,
                  showMore:
                    prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
                }
              ),
            }
          : undefined;
        var Calendar$1 = uncontrollable__WEBPACK_IMPORTED_MODULE_5___default()(
          Calendar,
          {
            view: "onView",
            date: "onNavigate",
            selected: "onSelectEvent",
          }
        );

        var dateRangeFormat$1 = function dateRangeFormat(_ref, culture, local) {
          var start = _ref.start,
            end = _ref.end;
          return (
            local.format(start, "L", culture) +
            "  " +
            local.format(end, "L", culture)
          );
        };

        var timeRangeFormat = function timeRangeFormat(_ref2, culture, local) {
          var start = _ref2.start,
            end = _ref2.end;
          return (
            local.format(start, "LT", culture) +
            "  " +
            local.format(end, "LT", culture)
          );
        };

        var timeRangeStartFormat = function timeRangeStartFormat(
          _ref3,
          culture,
          local
        ) {
          var start = _ref3.start;
          return local.format(start, "LT", culture) + "  ";
        };

        var timeRangeEndFormat = function timeRangeEndFormat(
          _ref4,
          culture,
          local
        ) {
          var end = _ref4.end;
          return "  " + local.format(end, "LT", culture);
        };

        var weekRangeFormat = function weekRangeFormat(_ref5, culture, local) {
          var start = _ref5.start,
            end = _ref5.end;
          return (
            local.format(start, "MMMM DD", culture) +
            " - " +
            local.format(
              end,
              dates.eq(start, end, "month") ? "DD" : "MMMM DD",
              culture
            )
          );
        };

        var formats = {
          dateFormat: "DD",
          dayFormat: "DD ddd",
          weekdayFormat: "ddd",
          selectRangeFormat: timeRangeFormat,
          eventTimeRangeFormat: timeRangeFormat,
          eventTimeRangeStartFormat: timeRangeStartFormat,
          eventTimeRangeEndFormat: timeRangeEndFormat,
          timeGutterFormat: "LT",
          monthHeaderFormat: "MMMM YYYY",
          dayHeaderFormat: "dddd MMM DD",
          dayRangeHeaderFormat: weekRangeFormat,
          agendaHeaderFormat: dateRangeFormat$1,
          agendaDateFormat: "ddd MMM DD",
          agendaTimeFormat: "LT",
          agendaTimeRangeFormat: timeRangeFormat,
        };

        function momentLocalizer(moment) {
          var locale = function locale(m, c) {
            return c ? m.locale(c) : m;
          };

          return new DateLocalizer({
            formats: formats,
            firstOfWeek: function firstOfWeek(culture) {
              var data = culture
                ? moment.localeData(culture)
                : moment.localeData();
              return data ? data.firstDayOfWeek() : 0;
            },
            format: function format(value, _format, culture) {
              return locale(moment(value), culture).format(_format);
            },
          });
        }

        var dateRangeFormat$2 = function dateRangeFormat(_ref, culture, local) {
          var start = _ref.start,
            end = _ref.end;
          return (
            local.format(start, "d", culture) +
            "  " +
            local.format(end, "d", culture)
          );
        };

        var timeRangeFormat$1 = function timeRangeFormat(
          _ref2,
          culture,
          local
        ) {
          var start = _ref2.start,
            end = _ref2.end;
          return (
            local.format(start, "t", culture) +
            "  " +
            local.format(end, "t", culture)
          );
        };

        var timeRangeStartFormat$1 = function timeRangeStartFormat(
          _ref3,
          culture,
          local
        ) {
          var start = _ref3.start;
          return local.format(start, "t", culture) + "  ";
        };

        var timeRangeEndFormat$1 = function timeRangeEndFormat(
          _ref4,
          culture,
          local
        ) {
          var end = _ref4.end;
          return "  " + local.format(end, "t", culture);
        };

        var weekRangeFormat$1 = function weekRangeFormat(
          _ref5,
          culture,
          local
        ) {
          var start = _ref5.start,
            end = _ref5.end;
          return (
            local.format(start, "MMM dd", culture) +
            " - " +
            local.format(
              end,
              dates.eq(start, end, "month") ? "dd" : "MMM dd",
              culture
            )
          );
        };

        var formats$1 = {
          dateFormat: "dd",
          dayFormat: "ddd dd/MM",
          weekdayFormat: "ddd",
          selectRangeFormat: timeRangeFormat$1,
          eventTimeRangeFormat: timeRangeFormat$1,
          eventTimeRangeStartFormat: timeRangeStartFormat$1,
          eventTimeRangeEndFormat: timeRangeEndFormat$1,
          timeGutterFormat: "t",
          monthHeaderFormat: "Y",
          dayHeaderFormat: "dddd MMM dd",
          dayRangeHeaderFormat: weekRangeFormat$1,
          agendaHeaderFormat: dateRangeFormat$2,
          agendaDateFormat: "ddd MMM dd",
          agendaTimeFormat: "t",
          agendaTimeRangeFormat: timeRangeFormat$1,
        };

        function oldGlobalize(globalize) {
          function getCulture(culture) {
            return culture
              ? globalize.findClosestCulture(culture)
              : globalize.culture();
          }

          function firstOfWeek(culture) {
            culture = getCulture(culture);
            return (culture && culture.calendar.firstDay) || 0;
          }

          return new DateLocalizer({
            firstOfWeek: firstOfWeek,
            formats: formats$1,
            format: function format(value, _format, culture) {
              return globalize.format(value, _format, culture);
            },
          });
        }

        var dateRangeFormat$3 = function dateRangeFormat(_ref, culture, local) {
          var start = _ref.start,
            end = _ref.end;
          return (
            local.format(
              start,
              {
                date: "short",
              },
              culture
            ) +
            "  " +
            local.format(
              end,
              {
                date: "short",
              },
              culture
            )
          );
        };

        var timeRangeFormat$2 = function timeRangeFormat(
          _ref2,
          culture,
          local
        ) {
          var start = _ref2.start,
            end = _ref2.end;
          return (
            local.format(
              start,
              {
                time: "short",
              },
              culture
            ) +
            "  " +
            local.format(
              end,
              {
                time: "short",
              },
              culture
            )
          );
        };

        var timeRangeStartFormat$2 = function timeRangeStartFormat(
          _ref3,
          culture,
          local
        ) {
          var start = _ref3.start;
          return (
            local.format(
              start,
              {
                time: "short",
              },
              culture
            ) + "  "
          );
        };

        var timeRangeEndFormat$2 = function timeRangeEndFormat(
          _ref4,
          culture,
          local
        ) {
          var end = _ref4.end;
          return (
            "  " +
            local.format(
              end,
              {
                time: "short",
              },
              culture
            )
          );
        };

        var weekRangeFormat$2 = function weekRangeFormat(
          _ref5,
          culture,
          local
        ) {
          var start = _ref5.start,
            end = _ref5.end;
          return (
            local.format(start, "MMM dd", culture) +
            "  " +
            local.format(
              end,
              dates.eq(start, end, "month") ? "dd" : "MMM dd",
              culture
            )
          );
        };

        var formats$2 = {
          dateFormat: "dd",
          dayFormat: "eee dd/MM",
          weekdayFormat: "eee",
          selectRangeFormat: timeRangeFormat$2,
          eventTimeRangeFormat: timeRangeFormat$2,
          eventTimeRangeStartFormat: timeRangeStartFormat$2,
          eventTimeRangeEndFormat: timeRangeEndFormat$2,
          timeGutterFormat: {
            time: "short",
          },
          monthHeaderFormat: "MMMM yyyy",
          dayHeaderFormat: "eeee MMM dd",
          dayRangeHeaderFormat: weekRangeFormat$2,
          agendaHeaderFormat: dateRangeFormat$3,
          agendaDateFormat: "eee MMM dd",
          agendaTimeFormat: {
            time: "short",
          },
          agendaTimeRangeFormat: timeRangeFormat$2,
        };

        function globalizeLocalizer(globalize) {
          var locale = function locale(culture) {
            return culture ? globalize(culture) : globalize;
          }; // return the first day of the week from the locale data. Defaults to 'world'
          // territory if no territory is derivable from CLDR.
          // Failing to use CLDR supplemental (not loaded?), revert to the original
          // method of getting first day of week.

          function firstOfWeek(culture) {
            try {
              var days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
              var cldr = locale(culture).cldr;
              var territory = cldr.attributes.territory;
              var weekData = cldr.get("supplemental").weekData;
              var firstDay = weekData.firstDay[territory || "001"];
              return days.indexOf(firstDay);
            } catch (e) {
              true
                ? warning__WEBPACK_IMPORTED_MODULE_9___default()(
                    true,
                    "Failed to accurately determine first day of the week.\n            Is supplemental data loaded into CLDR?"
                  )
                : undefined; // maybe cldr supplemental is not loaded? revert to original method

              var date = new Date(); //cldr-data doesn't seem to be zero based

              var localeDay = Math.max(
                parseInt(
                  locale(culture).formatDate(date, {
                    raw: "e",
                  }),
                  10
                ) - 1,
                0
              );
              return Math.abs(date.getDay() - localeDay);
            }
          }

          if (!globalize.load) return oldGlobalize(globalize);
          return new DateLocalizer({
            firstOfWeek: firstOfWeek,
            formats: formats$2,
            format: function format(value, _format, culture) {
              _format =
                typeof _format === "string"
                  ? {
                      raw: _format,
                    }
                  : _format;
              return locale(culture).formatDate(value, _format);
            },
          });
        }

        Object(
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[
            "default"
          ]
        )(Calendar$1, {
          globalizeLocalizer: globalizeLocalizer,
          momentLocalizer: momentLocalizer,
          Views: views,
          Navigate: navigate,
          move: moveDate,
          components: {
            eventWrapper: NoopWrapper,
            dayWrapper: NoopWrapper,
            dateCellWrapper: NoopWrapper,
          },
        });

        /* harmony default export */ __webpack_exports__[
          "default"
        ] = Calendar$1;

        /***/
      },

    /***/ "./node_modules/react-big-calendar/lib/utils/dates.js":
      /*!************************************************************!*\
  !*** ./node_modules/react-big-calendar/lib/utils/dates.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        var _interopRequireDefault = __webpack_require__(
          /*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
        );

        exports.__esModule = true;
        exports.default = void 0;

        var _extends2 = _interopRequireDefault(
          __webpack_require__(
            /*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"
          )
        );

        var _dateArithmetic = _interopRequireDefault(
          __webpack_require__(
            /*! date-arithmetic */ "./node_modules/date-arithmetic/index.js"
          )
        );
        /* eslint no-fallthrough: off */

        var MILLI = {
          seconds: 1000,
          minutes: 1000 * 60,
          hours: 1000 * 60 * 60,
          day: 1000 * 60 * 60 * 24,
        };
        var MONTHS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        var dates = (0, _extends2.default)({}, _dateArithmetic.default, {
          monthsInYear: function monthsInYear(year) {
            var date = new Date(year, 0, 1);
            return MONTHS.map(function(i) {
              return dates.month(date, i);
            });
          },
          firstVisibleDay: function firstVisibleDay(date, localizer) {
            var firstOfMonth = dates.startOf(date, "month");
            return dates.startOf(firstOfMonth, "week", localizer.startOfWeek());
          },
          lastVisibleDay: function lastVisibleDay(date, localizer) {
            var endOfMonth = dates.endOf(date, "month");
            return dates.endOf(endOfMonth, "week", localizer.startOfWeek());
          },
          visibleDays: function visibleDays(date, localizer) {
            var current = dates.firstVisibleDay(date, localizer),
              last = dates.lastVisibleDay(date, localizer),
              days = [];

            while (dates.lte(current, last, "day")) {
              days.push(current);
              current = dates.add(current, 1, "day");
            }

            return days;
          },
          ceil: function ceil(date, unit) {
            var floor = dates.startOf(date, unit);
            return dates.eq(floor, date) ? floor : dates.add(floor, 1, unit);
          },
          range: function range(start, end, unit) {
            if (unit === void 0) {
              unit = "day";
            }

            var current = start,
              days = [];

            while (dates.lte(current, end, unit)) {
              days.push(current);
              current = dates.add(current, 1, unit);
            }

            return days;
          },
          merge: function merge(date, time) {
            if (time == null && date == null) return null;
            if (time == null) time = new Date();
            if (date == null) date = new Date();
            date = dates.startOf(date, "day");
            date = dates.hours(date, dates.hours(time));
            date = dates.minutes(date, dates.minutes(time));
            date = dates.seconds(date, dates.seconds(time));
            return dates.milliseconds(date, dates.milliseconds(time));
          },
          eqTime: function eqTime(dateA, dateB) {
            return (
              dates.hours(dateA) === dates.hours(dateB) &&
              dates.minutes(dateA) === dates.minutes(dateB) &&
              dates.seconds(dateA) === dates.seconds(dateB)
            );
          },
          isJustDate: function isJustDate(date) {
            return (
              dates.hours(date) === 0 &&
              dates.minutes(date) === 0 &&
              dates.seconds(date) === 0 &&
              dates.milliseconds(date) === 0
            );
          },
          duration: function duration(start, end, unit, firstOfWeek) {
            if (unit === "day") unit = "date";
            return Math.abs(
              dates[unit](start, undefined, firstOfWeek) -
                dates[unit](end, undefined, firstOfWeek)
            );
          },
          diff: function diff(dateA, dateB, unit) {
            if (!unit || unit === "milliseconds")
              return Math.abs(+dateA - +dateB); // the .round() handles an edge case
            // with DST where the total won't be exact
            // since one day in the range may be shorter/longer by an hour

            return Math.round(
              Math.abs(
                +dates.startOf(dateA, unit) / MILLI[unit] -
                  +dates.startOf(dateB, unit) / MILLI[unit]
              )
            );
          },
          total: function total(date, unit) {
            var ms = date.getTime(),
              div = 1;

            switch (unit) {
              case "week":
                div *= 7;

              case "day":
                div *= 24;

              case "hours":
                div *= 60;

              case "minutes":
                div *= 60;

              case "seconds":
                div *= 1000;
            }

            return ms / div;
          },
          week: function week(date) {
            var d = new Date(date);
            d.setHours(0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            return Math.ceil(
              ((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7
            );
          },
          today: function today() {
            return dates.startOf(new Date(), "day");
          },
          yesterday: function yesterday() {
            return dates.add(dates.startOf(new Date(), "day"), -1, "day");
          },
          tomorrow: function tomorrow() {
            return dates.add(dates.startOf(new Date(), "day"), 1, "day");
          },
        });
        var _default = dates;
        exports.default = _default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-big-calendar/node_modules/memoize-one/dist/memoize-one.esm.js":
      /*!******************************************************************************************!*\
  !*** ./node_modules/react-big-calendar/node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \******************************************************************************************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var simpleIsEqual = function simpleIsEqual(a, b) {
          return a === b;
        };

        function index(resultFn, isEqual) {
          if (isEqual === void 0) {
            isEqual = simpleIsEqual;
          }

          var lastThis;
          var lastArgs = [];
          var lastResult;
          var calledOnce = false;

          var isNewArgEqualToLast = function isNewArgEqualToLast(
            newArg,
            index
          ) {
            return isEqual(newArg, lastArgs[index], index);
          };

          var result = function result() {
            for (
              var _len = arguments.length, newArgs = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              newArgs[_key] = arguments[_key];
            }

            if (
              calledOnce &&
              lastThis === this &&
              newArgs.length === lastArgs.length &&
              newArgs.every(isNewArgEqualToLast)
            ) {
              return lastResult;
            }

            lastResult = resultFn.apply(this, newArgs);
            calledOnce = true;
            lastThis = this;
            lastArgs = newArgs;
            return lastResult;
          };

          return result;
        }

        /* harmony default export */ __webpack_exports__["default"] = index;

        /***/
      },

    /***/ "./node_modules/react-big-calendar/node_modules/warning/warning.js":
      /*!*************************************************************************!*\
  !*** ./node_modules/react-big-calendar/node_modules/warning/warning.js ***!
  \*************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        /**
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */

        var __DEV__ = "development" !== "production";

        var warning = function warning() {};

        if (__DEV__) {
          var printWarning = function printWarning(format, args) {
            var len = arguments.length;
            args = new Array(len > 1 ? len - 1 : 0);

            for (var key = 1; key < len; key++) {
              args[key - 1] = arguments[key];
            }

            var argIndex = 0;
            var message =
              "Warning: " +
              format.replace(/%s/g, function() {
                return args[argIndex++];
              });

            if (typeof console !== "undefined") {
              console.error(message);
            }

            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };

          warning = function warning(condition, format, args) {
            var len = arguments.length;
            args = new Array(len > 2 ? len - 2 : 0);

            for (var key = 2; key < len; key++) {
              args[key - 2] = arguments[key];
            }

            if (format === undefined) {
              throw new Error(
                "`warning(condition, format, ...args)` requires a warning " +
                  "message argument"
              );
            }

            if (!condition) {
              printWarning.apply(null, [format].concat(args));
            }
          };
        }

        module.exports = warning;

        /***/
      },

    /***/ "./node_modules/react-is/cjs/react-is.development.js":
      /*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /** @license React v16.8.6
         * react-is.development.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        if (true) {
          (function() {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true,
            }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.

            var hasSymbol = typeof Symbol === "function" && Symbol.for;
            var REACT_ELEMENT_TYPE = hasSymbol
              ? Symbol.for("react.element")
              : 0xeac7;
            var REACT_PORTAL_TYPE = hasSymbol
              ? Symbol.for("react.portal")
              : 0xeaca;
            var REACT_FRAGMENT_TYPE = hasSymbol
              ? Symbol.for("react.fragment")
              : 0xeacb;
            var REACT_STRICT_MODE_TYPE = hasSymbol
              ? Symbol.for("react.strict_mode")
              : 0xeacc;
            var REACT_PROFILER_TYPE = hasSymbol
              ? Symbol.for("react.profiler")
              : 0xead2;
            var REACT_PROVIDER_TYPE = hasSymbol
              ? Symbol.for("react.provider")
              : 0xeacd;
            var REACT_CONTEXT_TYPE = hasSymbol
              ? Symbol.for("react.context")
              : 0xeace;
            var REACT_ASYNC_MODE_TYPE = hasSymbol
              ? Symbol.for("react.async_mode")
              : 0xeacf;
            var REACT_CONCURRENT_MODE_TYPE = hasSymbol
              ? Symbol.for("react.concurrent_mode")
              : 0xeacf;
            var REACT_FORWARD_REF_TYPE = hasSymbol
              ? Symbol.for("react.forward_ref")
              : 0xead0;
            var REACT_SUSPENSE_TYPE = hasSymbol
              ? Symbol.for("react.suspense")
              : 0xead1;
            var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
            var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;

            function isValidElementType(type) {
              return (
                typeof type === "string" ||
                typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
                type === REACT_FRAGMENT_TYPE ||
                type === REACT_CONCURRENT_MODE_TYPE ||
                type === REACT_PROFILER_TYPE ||
                type === REACT_STRICT_MODE_TYPE ||
                type === REACT_SUSPENSE_TYPE ||
                (_typeof(type) === "object" &&
                  type !== null &&
                  (type.$$typeof === REACT_LAZY_TYPE ||
                    type.$$typeof === REACT_MEMO_TYPE ||
                    type.$$typeof === REACT_PROVIDER_TYPE ||
                    type.$$typeof === REACT_CONTEXT_TYPE ||
                    type.$$typeof === REACT_FORWARD_REF_TYPE))
              );
            }
            /**
             * Forked from fbjs/warning:
             * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
             *
             * Only change is we use console.warn instead of console.error,
             * and do nothing when 'console' is not supported.
             * This really simplifies the code.
             * ---
             * Similar to invariant but only logs a warning if the condition is not met.
             * This can be used to log issues in development environments in critical
             * paths. Removing the logging code for production environments will keep the
             * same logic and follow the same code paths.
             */

            var lowPriorityWarning = function lowPriorityWarning() {};

            {
              var printWarning = function printWarning(format) {
                for (
                  var _len = arguments.length,
                    args = Array(_len > 1 ? _len - 1 : 0),
                    _key = 1;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 1] = arguments[_key];
                }

                var argIndex = 0;
                var message =
                  "Warning: " +
                  format.replace(/%s/g, function() {
                    return args[argIndex++];
                  });

                if (typeof console !== "undefined") {
                  console.warn(message);
                }

                try {
                  // --- Welcome to debugging React ---
                  // This error was thrown as a convenience so that you can use this stack
                  // to find the callsite that caused this warning to fire.
                  throw new Error(message);
                } catch (x) {}
              };

              lowPriorityWarning = function lowPriorityWarning(
                condition,
                format
              ) {
                if (format === undefined) {
                  throw new Error(
                    "`lowPriorityWarning(condition, format, ...args)` requires a warning " +
                      "message argument"
                  );
                }

                if (!condition) {
                  for (
                    var _len2 = arguments.length,
                      args = Array(_len2 > 2 ? _len2 - 2 : 0),
                      _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 2] = arguments[_key2];
                  }

                  printWarning.apply(undefined, [format].concat(args));
                }
              };
            }
            var lowPriorityWarning$1 = lowPriorityWarning;

            function typeOf(object) {
              if (_typeof(object) === "object" && object !== null) {
                var $$typeof = object.$$typeof;

                switch ($$typeof) {
                  case REACT_ELEMENT_TYPE:
                    var type = object.type;

                    switch (type) {
                      case REACT_ASYNC_MODE_TYPE:
                      case REACT_CONCURRENT_MODE_TYPE:
                      case REACT_FRAGMENT_TYPE:
                      case REACT_PROFILER_TYPE:
                      case REACT_STRICT_MODE_TYPE:
                      case REACT_SUSPENSE_TYPE:
                        return type;

                      default:
                        var $$typeofType = type && type.$$typeof;

                        switch ($$typeofType) {
                          case REACT_CONTEXT_TYPE:
                          case REACT_FORWARD_REF_TYPE:
                          case REACT_PROVIDER_TYPE:
                            return $$typeofType;

                          default:
                            return $$typeof;
                        }
                    }

                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PORTAL_TYPE:
                    return $$typeof;
                }
              }

              return undefined;
            } // AsyncMode is deprecated along with isAsyncMode

            var AsyncMode = REACT_ASYNC_MODE_TYPE;
            var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
            var ContextConsumer = REACT_CONTEXT_TYPE;
            var ContextProvider = REACT_PROVIDER_TYPE;
            var Element = REACT_ELEMENT_TYPE;
            var ForwardRef = REACT_FORWARD_REF_TYPE;
            var Fragment = REACT_FRAGMENT_TYPE;
            var Lazy = REACT_LAZY_TYPE;
            var Memo = REACT_MEMO_TYPE;
            var Portal = REACT_PORTAL_TYPE;
            var Profiler = REACT_PROFILER_TYPE;
            var StrictMode = REACT_STRICT_MODE_TYPE;
            var Suspense = REACT_SUSPENSE_TYPE;
            var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

            function isAsyncMode(object) {
              {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                  hasWarnedAboutDeprecatedIsAsyncMode = true;
                  lowPriorityWarning$1(
                    false,
                    "The ReactIs.isAsyncMode() alias has been deprecated, " +
                      "and will be removed in React 17+. Update your code to use " +
                      "ReactIs.isConcurrentMode() instead. It has the exact same API."
                  );
                }
              }
              return (
                isConcurrentMode(object) ||
                typeOf(object) === REACT_ASYNC_MODE_TYPE
              );
            }

            function isConcurrentMode(object) {
              return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
            }

            function isContextConsumer(object) {
              return typeOf(object) === REACT_CONTEXT_TYPE;
            }

            function isContextProvider(object) {
              return typeOf(object) === REACT_PROVIDER_TYPE;
            }

            function isElement(object) {
              return (
                _typeof(object) === "object" &&
                object !== null &&
                object.$$typeof === REACT_ELEMENT_TYPE
              );
            }

            function isForwardRef(object) {
              return typeOf(object) === REACT_FORWARD_REF_TYPE;
            }

            function isFragment(object) {
              return typeOf(object) === REACT_FRAGMENT_TYPE;
            }

            function isLazy(object) {
              return typeOf(object) === REACT_LAZY_TYPE;
            }

            function isMemo(object) {
              return typeOf(object) === REACT_MEMO_TYPE;
            }

            function isPortal(object) {
              return typeOf(object) === REACT_PORTAL_TYPE;
            }

            function isProfiler(object) {
              return typeOf(object) === REACT_PROFILER_TYPE;
            }

            function isStrictMode(object) {
              return typeOf(object) === REACT_STRICT_MODE_TYPE;
            }

            function isSuspense(object) {
              return typeOf(object) === REACT_SUSPENSE_TYPE;
            }

            exports.typeOf = typeOf;
            exports.AsyncMode = AsyncMode;
            exports.ConcurrentMode = ConcurrentMode;
            exports.ContextConsumer = ContextConsumer;
            exports.ContextProvider = ContextProvider;
            exports.Element = Element;
            exports.ForwardRef = ForwardRef;
            exports.Fragment = Fragment;
            exports.Lazy = Lazy;
            exports.Memo = Memo;
            exports.Portal = Portal;
            exports.Profiler = Profiler;
            exports.StrictMode = StrictMode;
            exports.Suspense = Suspense;
            exports.isValidElementType = isValidElementType;
            exports.isAsyncMode = isAsyncMode;
            exports.isConcurrentMode = isConcurrentMode;
            exports.isContextConsumer = isContextConsumer;
            exports.isContextProvider = isContextProvider;
            exports.isElement = isElement;
            exports.isForwardRef = isForwardRef;
            exports.isFragment = isFragment;
            exports.isLazy = isLazy;
            exports.isMemo = isMemo;
            exports.isPortal = isPortal;
            exports.isProfiler = isProfiler;
            exports.isStrictMode = isStrictMode;
            exports.isSuspense = isSuspense;
          })();
        }

        /***/
      },

    /***/ "./node_modules/react-is/index.js":
      /*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        if (false) {
        } else {
          module.exports = __webpack_require__(
            /*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js"
          );
        }

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/LegacyPortal.js":
      /*!*********************************************************!*\
  !*** ./node_modules/react-overlays/lib/LegacyPortal.js ***!
  \*********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        exports.__esModule = true;

        var _propTypes = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _componentOrElement = __webpack_require__(
          /*! prop-types-extra/lib/componentOrElement */ "./node_modules/prop-types-extra/lib/componentOrElement.js"
        );

        var _componentOrElement2 = _interopRequireDefault(_componentOrElement);

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _getContainer = __webpack_require__(
          /*! ./utils/getContainer */ "./node_modules/react-overlays/lib/utils/getContainer.js"
        );

        var _getContainer2 = _interopRequireDefault(_getContainer);

        var _ownerDocument = __webpack_require__(
          /*! ./utils/ownerDocument */ "./node_modules/react-overlays/lib/utils/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return call &&
            (_typeof(call) === "object" || typeof call === "function")
            ? call
            : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                _typeof(superClass)
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            }
          );
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass);
        }
        /**
         * The `<Portal/>` component renders its children into a new "subtree" outside of current component hierarchy.
         * You can think of it as a declarative `appendChild()`, or jQuery's `$.fn.appendTo()`.
         * The children of `<Portal/>` component will be appended to the `container` specified.
         */

        var Portal = (function(_React$Component) {
          _inherits(Portal, _React$Component);

          function Portal() {
            var _temp, _this, _ret;

            _classCallCheck(this, Portal);

            for (
              var _len = arguments.length, args = Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            return (
              (_ret = ((_temp = ((_this = _possibleConstructorReturn(
                this,
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                )
              )),
              _this)),
              (_this._mountOverlayTarget = function() {
                if (!_this._overlayTarget) {
                  _this._overlayTarget = document.createElement("div");
                  _this._portalContainerNode = (0, _getContainer2.default)(
                    _this.props.container,
                    (0, _ownerDocument2.default)(_this).body
                  );

                  _this._portalContainerNode.appendChild(_this._overlayTarget);
                }
              }),
              (_this._unmountOverlayTarget = function() {
                if (_this._overlayTarget) {
                  _this._portalContainerNode.removeChild(_this._overlayTarget);

                  _this._overlayTarget = null;
                }

                _this._portalContainerNode = null;
              }),
              (_this._renderOverlay = function() {
                var overlay = !_this.props.children
                  ? null
                  : _react2.default.Children.only(_this.props.children); // Save reference for future access.

                if (overlay !== null) {
                  _this._mountOverlayTarget();

                  var initialRender = !_this._overlayInstance;
                  _this._overlayInstance = _reactDom2.default.unstable_renderSubtreeIntoContainer(
                    _this,
                    overlay,
                    _this._overlayTarget,
                    function() {
                      if (initialRender && _this.props.onRendered) {
                        _this.props.onRendered();
                      }
                    }
                  );
                } else {
                  // Unrender if the component is null for transitions to null
                  _this._unrenderOverlay();

                  _this._unmountOverlayTarget();
                }
              }),
              (_this._unrenderOverlay = function() {
                if (_this._overlayTarget) {
                  _reactDom2.default.unmountComponentAtNode(
                    _this._overlayTarget
                  );

                  _this._overlayInstance = null;
                }
              }),
              (_this.getMountNode = function() {
                return _this._overlayTarget;
              }),
              _temp)),
              _possibleConstructorReturn(_this, _ret)
            );
          }

          Portal.prototype.componentDidMount = function componentDidMount() {
            this._isMounted = true;

            this._renderOverlay();
          };

          Portal.prototype.componentDidUpdate = function componentDidUpdate() {
            this._renderOverlay();
          };

          Portal.prototype.componentWillReceiveProps = function componentWillReceiveProps(
            nextProps
          ) {
            if (
              this._overlayTarget &&
              nextProps.container !== this.props.container
            ) {
              this._portalContainerNode.removeChild(this._overlayTarget);

              this._portalContainerNode = (0, _getContainer2.default)(
                nextProps.container,
                (0, _ownerDocument2.default)(this).body
              );

              this._portalContainerNode.appendChild(this._overlayTarget);
            }
          };

          Portal.prototype.componentWillUnmount = function componentWillUnmount() {
            this._isMounted = false;

            this._unrenderOverlay();

            this._unmountOverlayTarget();
          };

          Portal.prototype.render = function render() {
            return null;
          };

          return Portal;
        })(_react2.default.Component);

        Portal.displayName = "Portal";
        Portal.propTypes = {
          /**
           * A Node, Component instance, or function that returns either. The `container` will have the Portal children
           * appended to it.
           */
          container: _propTypes2.default.oneOfType([
            _componentOrElement2.default,
            _propTypes2.default.func,
          ]),
          onRendered: _propTypes2.default.func,
        };
        exports.default = Portal;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/Overlay.js":
      /*!****************************************************!*\
  !*** ./node_modules/react-overlays/lib/Overlay.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        exports.__esModule = true;

        var _extends =
          Object.assign ||
          function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];

              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }

            return target;
          };

        var _propTypes = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _elementType = __webpack_require__(
          /*! prop-types-extra/lib/elementType */ "./node_modules/prop-types-extra/lib/elementType.js"
        );

        var _elementType2 = _interopRequireDefault(_elementType);

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _Portal = __webpack_require__(
          /*! ./Portal */ "./node_modules/react-overlays/lib/Portal.js"
        );

        var _Portal2 = _interopRequireDefault(_Portal);

        var _Position = __webpack_require__(
          /*! ./Position */ "./node_modules/react-overlays/lib/Position.js"
        );

        var _Position2 = _interopRequireDefault(_Position);

        var _RootCloseWrapper = __webpack_require__(
          /*! ./RootCloseWrapper */ "./node_modules/react-overlays/lib/RootCloseWrapper.js"
        );

        var _RootCloseWrapper2 = _interopRequireDefault(_RootCloseWrapper);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _objectWithoutProperties(obj, keys) {
          var target = {};

          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }

          return target;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return call &&
            (_typeof(call) === "object" || typeof call === "function")
            ? call
            : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                _typeof(superClass)
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            }
          );
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass);
        }
        /**
         * Built on top of `<Position/>` and `<Portal/>`, the overlay component is great for custom tooltip overlays.
         */

        var Overlay = (function(_React$Component) {
          _inherits(Overlay, _React$Component);

          function Overlay(props, context) {
            _classCallCheck(this, Overlay);

            var _this = _possibleConstructorReturn(
              this,
              _React$Component.call(this, props, context)
            );

            _this.handleHidden = function() {
              _this.setState({
                exited: true,
              });

              if (_this.props.onExited) {
                var _this$props;

                (_this$props = _this.props).onExited.apply(
                  _this$props,
                  arguments
                );
              }
            };

            _this.state = {
              exited: !props.show,
            };
            _this.onHiddenListener = _this.handleHidden.bind(_this);
            return _this;
          }

          Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(
            nextProps
          ) {
            if (nextProps.show) {
              this.setState({
                exited: false,
              });
            } else if (!nextProps.transition) {
              // Otherwise let handleHidden take care of marking exited.
              this.setState({
                exited: true,
              });
            }
          };

          Overlay.prototype.render = function render() {
            var _props = this.props,
              container = _props.container,
              containerPadding = _props.containerPadding,
              target = _props.target,
              placement = _props.placement,
              shouldUpdatePosition = _props.shouldUpdatePosition,
              rootClose = _props.rootClose,
              children = _props.children,
              Transition = _props.transition,
              props = _objectWithoutProperties(_props, [
                "container",
                "containerPadding",
                "target",
                "placement",
                "shouldUpdatePosition",
                "rootClose",
                "children",
                "transition",
              ]); // Don't un-render the overlay while it's transitioning out.

            var mountOverlay = props.show || (Transition && !this.state.exited);

            if (!mountOverlay) {
              // Don't bother showing anything if we don't have to.
              return null;
            }

            var child = children; // Position is be inner-most because it adds inline styles into the child,
            // which the other wrappers don't forward correctly.

            child = _react2.default.createElement(
              _Position2.default,
              {
                container: container,
                containerPadding: containerPadding,
                target: target,
                placement: placement,
                shouldUpdatePosition: shouldUpdatePosition,
              },
              child
            );

            if (Transition) {
              var onExit = props.onExit,
                onExiting = props.onExiting,
                onEnter = props.onEnter,
                onEntering = props.onEntering,
                onEntered = props.onEntered; // This animates the child node by injecting props, so it must precede
              // anything that adds a wrapping div.

              child = _react2.default.createElement(
                Transition,
                {
                  in: props.show,
                  appear: true,
                  onExit: onExit,
                  onExiting: onExiting,
                  onExited: this.onHiddenListener,
                  onEnter: onEnter,
                  onEntering: onEntering,
                  onEntered: onEntered,
                },
                child
              );
            } // This goes after everything else because it adds a wrapping div.

            if (rootClose) {
              child = _react2.default.createElement(
                _RootCloseWrapper2.default,
                {
                  onRootClose: props.onHide,
                },
                child
              );
            }

            return _react2.default.createElement(
              _Portal2.default,
              {
                container: container,
              },
              child
            );
          };

          return Overlay;
        })(_react2.default.Component);

        Overlay.propTypes = _extends(
          {},
          _Portal2.default.propTypes,
          _Position2.default.propTypes,
          {
            /**
             * Set the visibility of the Overlay
             */
            show: _propTypes2.default.bool,

            /**
             * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
             */
            rootClose: _propTypes2.default.bool,

            /**
             * A Callback fired by the Overlay when it wishes to be hidden.
             *
             * __required__ when `rootClose` is `true`.
             *
             * @type func
             */
            onHide: function onHide(props) {
              var propType = _propTypes2.default.func;

              if (props.rootClose) {
                propType = propType.isRequired;
              }

              for (
                var _len = arguments.length,
                  args = Array(_len > 1 ? _len - 1 : 0),
                  _key = 1;
                _key < _len;
                _key++
              ) {
                args[_key - 1] = arguments[_key];
              }

              return propType.apply(undefined, [props].concat(args));
            },

            /**
             * A `react-transition-group@2.0.0` `<Transition/>` component
             * used to animate the overlay as it changes visibility.
             */
            transition: _elementType2.default,

            /**
             * Callback fired before the Overlay transitions in
             */
            onEnter: _propTypes2.default.func,

            /**
             * Callback fired as the Overlay begins to transition in
             */
            onEntering: _propTypes2.default.func,

            /**
             * Callback fired after the Overlay finishes transitioning in
             */
            onEntered: _propTypes2.default.func,

            /**
             * Callback fired right before the Overlay transitions out
             */
            onExit: _propTypes2.default.func,

            /**
             * Callback fired as the Overlay begins to transition out
             */
            onExiting: _propTypes2.default.func,

            /**
             * Callback fired after the Overlay finishes transitioning out
             */
            onExited: _propTypes2.default.func,
          }
        );
        exports.default = Overlay;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/Portal.js":
      /*!***************************************************!*\
  !*** ./node_modules/react-overlays/lib/Portal.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        exports.__esModule = true;

        var _propTypes = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _componentOrElement = __webpack_require__(
          /*! prop-types-extra/lib/componentOrElement */ "./node_modules/prop-types-extra/lib/componentOrElement.js"
        );

        var _componentOrElement2 = _interopRequireDefault(_componentOrElement);

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _getContainer = __webpack_require__(
          /*! ./utils/getContainer */ "./node_modules/react-overlays/lib/utils/getContainer.js"
        );

        var _getContainer2 = _interopRequireDefault(_getContainer);

        var _ownerDocument = __webpack_require__(
          /*! ./utils/ownerDocument */ "./node_modules/react-overlays/lib/utils/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        var _LegacyPortal = __webpack_require__(
          /*! ./LegacyPortal */ "./node_modules/react-overlays/lib/LegacyPortal.js"
        );

        var _LegacyPortal2 = _interopRequireDefault(_LegacyPortal);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return call &&
            (_typeof(call) === "object" || typeof call === "function")
            ? call
            : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                _typeof(superClass)
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            }
          );
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass);
        }
        /**
         * The `<Portal/>` component renders its children into a new "subtree" outside of current component hierarchy.
         * You can think of it as a declarative `appendChild()`, or jQuery's `$.fn.appendTo()`.
         * The children of `<Portal/>` component will be appended to the `container` specified.
         */

        var Portal = (function(_React$Component) {
          _inherits(Portal, _React$Component);

          function Portal() {
            var _temp, _this, _ret;

            _classCallCheck(this, Portal);

            for (
              var _len = arguments.length, args = Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            return (
              (_ret = ((_temp = ((_this = _possibleConstructorReturn(
                this,
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(args)
                )
              )),
              _this)),
              (_this.setContainer = function() {
                var props =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : _this.props;
                _this._portalContainerNode = (0, _getContainer2.default)(
                  props.container,
                  (0, _ownerDocument2.default)(_this).body
                );
              }),
              (_this.getMountNode = function() {
                return _this._portalContainerNode;
              }),
              _temp)),
              _possibleConstructorReturn(_this, _ret)
            );
          }

          Portal.prototype.componentDidMount = function componentDidMount() {
            this.setContainer();
            this.forceUpdate(this.props.onRendered);
          };

          Portal.prototype.componentWillReceiveProps = function componentWillReceiveProps(
            nextProps
          ) {
            if (nextProps.container !== this.props.container) {
              this.setContainer(nextProps);
            }
          };

          Portal.prototype.componentWillUnmount = function componentWillUnmount() {
            this._portalContainerNode = null;
          };

          Portal.prototype.render = function render() {
            return this.props.children && this._portalContainerNode
              ? _reactDom2.default.createPortal(
                  this.props.children,
                  this._portalContainerNode
                )
              : null;
          };

          return Portal;
        })(_react2.default.Component);

        Portal.displayName = "Portal";
        Portal.propTypes = {
          /**
           * A Node, Component instance, or function that returns either. The `container` will have the Portal children
           * appended to it.
           */
          container: _propTypes2.default.oneOfType([
            _componentOrElement2.default,
            _propTypes2.default.func,
          ]),
          onRendered: _propTypes2.default.func,
        };
        exports.default = _reactDom2.default.createPortal
          ? Portal
          : _LegacyPortal2.default;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/Position.js":
      /*!*****************************************************!*\
  !*** ./node_modules/react-overlays/lib/Position.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        exports.__esModule = true;

        var _extends =
          Object.assign ||
          function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];

              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }

            return target;
          };

        var _classnames = __webpack_require__(
          /*! classnames */ "./node_modules/classnames/index.js"
        );

        var _classnames2 = _interopRequireDefault(_classnames);

        var _propTypes = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _componentOrElement = __webpack_require__(
          /*! prop-types-extra/lib/componentOrElement */ "./node_modules/prop-types-extra/lib/componentOrElement.js"
        );

        var _componentOrElement2 = _interopRequireDefault(_componentOrElement);

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _calculatePosition = __webpack_require__(
          /*! ./utils/calculatePosition */ "./node_modules/react-overlays/lib/utils/calculatePosition.js"
        );

        var _calculatePosition2 = _interopRequireDefault(_calculatePosition);

        var _getContainer = __webpack_require__(
          /*! ./utils/getContainer */ "./node_modules/react-overlays/lib/utils/getContainer.js"
        );

        var _getContainer2 = _interopRequireDefault(_getContainer);

        var _ownerDocument = __webpack_require__(
          /*! ./utils/ownerDocument */ "./node_modules/react-overlays/lib/utils/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _objectWithoutProperties(obj, keys) {
          var target = {};

          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }

          return target;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return call &&
            (_typeof(call) === "object" || typeof call === "function")
            ? call
            : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                _typeof(superClass)
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            }
          );
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass);
        }
        /**
         * The Position component calculates the coordinates for its child, to position
         * it relative to a `target` component or node. Useful for creating callouts
         * and tooltips, the Position component injects a `style` props with `left` and
         * `top` values for positioning your component.
         *
         * It also injects "arrow" `left`, and `top` values for styling callout arrows
         * for giving your components a sense of directionality.
         */

        var Position = (function(_React$Component) {
          _inherits(Position, _React$Component);

          function Position(props, context) {
            _classCallCheck(this, Position);

            var _this = _possibleConstructorReturn(
              this,
              _React$Component.call(this, props, context)
            );

            _this.getTarget = function() {
              var target = _this.props.target;
              var targetElement =
                typeof target === "function" ? target() : target;
              return (
                (targetElement &&
                  _reactDom2.default.findDOMNode(targetElement)) ||
                null
              );
            };

            _this.maybeUpdatePosition = function(placementChanged) {
              var target = _this.getTarget();

              if (
                !_this.props.shouldUpdatePosition &&
                target === _this._lastTarget &&
                !placementChanged
              ) {
                return;
              }

              _this.updatePosition(target);
            };

            _this.state = {
              positionLeft: 0,
              positionTop: 0,
              arrowOffsetLeft: null,
              arrowOffsetTop: null,
            };
            _this._needsFlush = false;
            _this._lastTarget = null;
            return _this;
          }

          Position.prototype.componentDidMount = function componentDidMount() {
            this.updatePosition(this.getTarget());
          };

          Position.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
            this._needsFlush = true;
          };

          Position.prototype.componentDidUpdate = function componentDidUpdate(
            prevProps
          ) {
            if (this._needsFlush) {
              this._needsFlush = false;
              this.maybeUpdatePosition(
                this.props.placement !== prevProps.placement
              );
            }
          };

          Position.prototype.render = function render() {
            var _props = this.props,
              children = _props.children,
              className = _props.className,
              props = _objectWithoutProperties(_props, [
                "children",
                "className",
              ]);

            var _state = this.state,
              positionLeft = _state.positionLeft,
              positionTop = _state.positionTop,
              arrowPosition = _objectWithoutProperties(_state, [
                "positionLeft",
                "positionTop",
              ]); // These should not be forwarded to the child.

            delete props.target;
            delete props.container;
            delete props.containerPadding;
            delete props.shouldUpdatePosition;

            var child = _react2.default.Children.only(children);

            return (0, _react.cloneElement)(
              child,
              _extends({}, props, arrowPosition, {
                // FIXME: Don't forward `positionLeft` and `positionTop` via both props
                // and `props.style`.
                positionLeft: positionLeft,
                positionTop: positionTop,
                className: (0, _classnames2.default)(
                  className,
                  child.props.className
                ),
                style: _extends({}, child.props.style, {
                  left: positionLeft,
                  top: positionTop,
                }),
              })
            );
          };

          Position.prototype.updatePosition = function updatePosition(target) {
            this._lastTarget = target;

            if (!target) {
              this.setState({
                positionLeft: 0,
                positionTop: 0,
                arrowOffsetLeft: null,
                arrowOffsetTop: null,
              });
              return;
            }

            var overlay = _reactDom2.default.findDOMNode(this);

            var container = (0, _getContainer2.default)(
              this.props.container,
              (0, _ownerDocument2.default)(this).body
            );
            this.setState(
              (0, _calculatePosition2.default)(
                this.props.placement,
                overlay,
                target,
                container,
                this.props.containerPadding
              )
            );
          };

          return Position;
        })(_react2.default.Component);

        Position.propTypes = {
          /**
           * A node, element, or function that returns either. The child will be
           * be positioned next to the `target` specified.
           */
          target: _propTypes2.default.oneOfType([
            _componentOrElement2.default,
            _propTypes2.default.func,
          ]),

          /**
           * "offsetParent" of the component
           */
          container: _propTypes2.default.oneOfType([
            _componentOrElement2.default,
            _propTypes2.default.func,
          ]),

          /**
           * Minimum spacing in pixels between container border and component border
           */
          containerPadding: _propTypes2.default.number,

          /**
           * How to position the component relative to the target
           */
          placement: _propTypes2.default.oneOf([
            "top",
            "right",
            "bottom",
            "left",
          ]),

          /**
           * Whether the position should be changed on each update
           */
          shouldUpdatePosition: _propTypes2.default.bool,
        };
        Position.displayName = "Position";
        Position.defaultProps = {
          containerPadding: 0,
          placement: "right",
          shouldUpdatePosition: false,
        };
        exports.default = Position;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/RootCloseWrapper.js":
      /*!*************************************************************!*\
  !*** ./node_modules/react-overlays/lib/RootCloseWrapper.js ***!
  \*************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        exports.__esModule = true;

        var _contains = __webpack_require__(
          /*! dom-helpers/query/contains */ "./node_modules/dom-helpers/query/contains.js"
        );

        var _contains2 = _interopRequireDefault(_contains);

        var _propTypes = __webpack_require__(
          /*! prop-types */ "./node_modules/prop-types/index.js"
        );

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _react = __webpack_require__(
          /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _react2 = _interopRequireDefault(_react);

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _addEventListener = __webpack_require__(
          /*! ./utils/addEventListener */ "./node_modules/react-overlays/lib/utils/addEventListener.js"
        );

        var _addEventListener2 = _interopRequireDefault(_addEventListener);

        var _ownerDocument = __webpack_require__(
          /*! ./utils/ownerDocument */ "./node_modules/react-overlays/lib/utils/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return call &&
            (_typeof(call) === "object" || typeof call === "function")
            ? call
            : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                _typeof(superClass)
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            }
          );
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass);
        }

        var escapeKeyCode = 27;

        function isLeftClickEvent(event) {
          return event.button === 0;
        }

        function isModifiedEvent(event) {
          return !!(
            event.metaKey ||
            event.altKey ||
            event.ctrlKey ||
            event.shiftKey
          );
        }
        /**
         * The `<RootCloseWrapper/>` component registers your callback on the document
         * when rendered. Powers the `<Overlay/>` component. This is used achieve modal
         * style behavior where your callback is triggered when the user tries to
         * interact with the rest of the document or hits the `esc` key.
         */

        var RootCloseWrapper = (function(_React$Component) {
          _inherits(RootCloseWrapper, _React$Component);

          function RootCloseWrapper(props, context) {
            _classCallCheck(this, RootCloseWrapper);

            var _this = _possibleConstructorReturn(
              this,
              _React$Component.call(this, props, context)
            );

            _this.addEventListeners = function() {
              var event = _this.props.event;
              var doc = (0, _ownerDocument2.default)(_this); // Use capture for this listener so it fires before React's listener, to
              // avoid false positives in the contains() check below if the target DOM
              // element is removed in the React mouse callback.

              _this.documentMouseCaptureListener = (0,
              _addEventListener2.default)(
                doc,
                event,
                _this.handleMouseCapture,
                true
              );
              _this.documentMouseListener = (0, _addEventListener2.default)(
                doc,
                event,
                _this.handleMouse
              );
              _this.documentKeyupListener = (0, _addEventListener2.default)(
                doc,
                "keyup",
                _this.handleKeyUp
              );
            };

            _this.removeEventListeners = function() {
              if (_this.documentMouseCaptureListener) {
                _this.documentMouseCaptureListener.remove();
              }

              if (_this.documentMouseListener) {
                _this.documentMouseListener.remove();
              }

              if (_this.documentKeyupListener) {
                _this.documentKeyupListener.remove();
              }
            };

            _this.handleMouseCapture = function(e) {
              _this.preventMouseRootClose =
                isModifiedEvent(e) ||
                !isLeftClickEvent(e) ||
                (0, _contains2.default)(
                  _reactDom2.default.findDOMNode(_this),
                  e.target
                );
            };

            _this.handleMouse = function(e) {
              if (!_this.preventMouseRootClose && _this.props.onRootClose) {
                _this.props.onRootClose(e);
              }
            };

            _this.handleKeyUp = function(e) {
              if (e.keyCode === escapeKeyCode && _this.props.onRootClose) {
                _this.props.onRootClose(e);
              }
            };

            _this.preventMouseRootClose = false;
            return _this;
          }

          RootCloseWrapper.prototype.componentDidMount = function componentDidMount() {
            if (!this.props.disabled) {
              this.addEventListeners();
            }
          };

          RootCloseWrapper.prototype.componentDidUpdate = function componentDidUpdate(
            prevProps
          ) {
            if (!this.props.disabled && prevProps.disabled) {
              this.addEventListeners();
            } else if (this.props.disabled && !prevProps.disabled) {
              this.removeEventListeners();
            }
          };

          RootCloseWrapper.prototype.componentWillUnmount = function componentWillUnmount() {
            if (!this.props.disabled) {
              this.removeEventListeners();
            }
          };

          RootCloseWrapper.prototype.render = function render() {
            return this.props.children;
          };

          return RootCloseWrapper;
        })(_react2.default.Component);

        RootCloseWrapper.displayName = "RootCloseWrapper";
        RootCloseWrapper.propTypes = {
          /**
           * Callback fired after click or mousedown. Also triggers when user hits `esc`.
           */
          onRootClose: _propTypes2.default.func,

          /**
           * Children to render.
           */
          children: _propTypes2.default.element,

          /**
           * Disable the the RootCloseWrapper, preventing it from triggering `onRootClose`.
           */
          disabled: _propTypes2.default.bool,

          /**
           * Choose which document mouse event to bind to.
           */
          event: _propTypes2.default.oneOf(["click", "mousedown"]),
        };
        RootCloseWrapper.defaultProps = {
          event: "click",
        };
        exports.default = RootCloseWrapper;
        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/utils/addEventListener.js":
      /*!*******************************************************************!*\
  !*** ./node_modules/react-overlays/lib/utils/addEventListener.js ***!
  \*******************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;

        exports.default = function(node, event, handler, capture) {
          (0, _on2.default)(node, event, handler, capture);
          return {
            remove: function remove() {
              (0, _off2.default)(node, event, handler, capture);
            },
          };
        };

        var _on = __webpack_require__(
          /*! dom-helpers/events/on */ "./node_modules/dom-helpers/events/on.js"
        );

        var _on2 = _interopRequireDefault(_on);

        var _off = __webpack_require__(
          /*! dom-helpers/events/off */ "./node_modules/dom-helpers/events/off.js"
        );

        var _off2 = _interopRequireDefault(_off);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/utils/calculatePosition.js":
      /*!********************************************************************!*\
  !*** ./node_modules/react-overlays/lib/utils/calculatePosition.js ***!
  \********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = calculatePosition;

        var _offset = __webpack_require__(
          /*! dom-helpers/query/offset */ "./node_modules/dom-helpers/query/offset.js"
        );

        var _offset2 = _interopRequireDefault(_offset);

        var _position = __webpack_require__(
          /*! dom-helpers/query/position */ "./node_modules/dom-helpers/query/position.js"
        );

        var _position2 = _interopRequireDefault(_position);

        var _scrollTop = __webpack_require__(
          /*! dom-helpers/query/scrollTop */ "./node_modules/dom-helpers/query/scrollTop.js"
        );

        var _scrollTop2 = _interopRequireDefault(_scrollTop);

        var _ownerDocument = __webpack_require__(
          /*! ./ownerDocument */ "./node_modules/react-overlays/lib/utils/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function getContainerDimensions(containerNode) {
          var width = void 0,
            height = void 0,
            scroll = void 0;

          if (containerNode.tagName === "BODY") {
            width = window.innerWidth;
            height = window.innerHeight;
            scroll =
              (0, _scrollTop2.default)(
                (0, _ownerDocument2.default)(containerNode).documentElement
              ) || (0, _scrollTop2.default)(containerNode);
          } else {
            var _getOffset = (0, _offset2.default)(containerNode);

            width = _getOffset.width;
            height = _getOffset.height;
            scroll = (0, _scrollTop2.default)(containerNode);
          }

          return {
            width: width,
            height: height,
            scroll: scroll,
          };
        }

        function getTopDelta(top, overlayHeight, container, padding) {
          var containerDimensions = getContainerDimensions(container);
          var containerScroll = containerDimensions.scroll;
          var containerHeight = containerDimensions.height;
          var topEdgeOffset = top - padding - containerScroll;
          var bottomEdgeOffset =
            top + padding - containerScroll + overlayHeight;

          if (topEdgeOffset < 0) {
            return -topEdgeOffset;
          } else if (bottomEdgeOffset > containerHeight) {
            return containerHeight - bottomEdgeOffset;
          } else {
            return 0;
          }
        }

        function getLeftDelta(left, overlayWidth, container, padding) {
          var containerDimensions = getContainerDimensions(container);
          var containerWidth = containerDimensions.width;
          var leftEdgeOffset = left - padding;
          var rightEdgeOffset = left + padding + overlayWidth;

          if (leftEdgeOffset < 0) {
            return -leftEdgeOffset;
          } else if (rightEdgeOffset > containerWidth) {
            return containerWidth - rightEdgeOffset;
          }

          return 0;
        }

        function calculatePosition(
          placement,
          overlayNode,
          target,
          container,
          padding
        ) {
          var childOffset =
            container.tagName === "BODY"
              ? (0, _offset2.default)(target)
              : (0, _position2.default)(target, container);

          var _getOffset2 = (0, _offset2.default)(overlayNode),
            overlayHeight = _getOffset2.height,
            overlayWidth = _getOffset2.width;

          var positionLeft = void 0,
            positionTop = void 0,
            arrowOffsetLeft = void 0,
            arrowOffsetTop = void 0;

          if (placement === "left" || placement === "right") {
            positionTop =
              childOffset.top + (childOffset.height - overlayHeight) / 2;

            if (placement === "left") {
              positionLeft = childOffset.left - overlayWidth;
            } else {
              positionLeft = childOffset.left + childOffset.width;
            }

            var topDelta = getTopDelta(
              positionTop,
              overlayHeight,
              container,
              padding
            );
            positionTop += topDelta;
            arrowOffsetTop = 50 * (1 - (2 * topDelta) / overlayHeight) + "%";
            arrowOffsetLeft = void 0;
          } else if (placement === "top" || placement === "bottom") {
            positionLeft =
              childOffset.left + (childOffset.width - overlayWidth) / 2;

            if (placement === "top") {
              positionTop = childOffset.top - overlayHeight;
            } else {
              positionTop = childOffset.top + childOffset.height;
            }

            var leftDelta = getLeftDelta(
              positionLeft,
              overlayWidth,
              container,
              padding
            );
            positionLeft += leftDelta;
            arrowOffsetLeft = 50 * (1 - (2 * leftDelta) / overlayWidth) + "%";
            arrowOffsetTop = void 0;
          } else {
            throw new Error(
              'calcOverlayPosition(): No such placement of "' +
                placement +
                '" found.'
            );
          }

          return {
            positionLeft: positionLeft,
            positionTop: positionTop,
            arrowOffsetLeft: arrowOffsetLeft,
            arrowOffsetTop: arrowOffsetTop,
          };
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/utils/getContainer.js":
      /*!***************************************************************!*\
  !*** ./node_modules/react-overlays/lib/utils/getContainer.js ***!
  \***************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = getContainer;

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function getContainer(container, defaultContainer) {
          container = typeof container === "function" ? container() : container;
          return _reactDom2.default.findDOMNode(container) || defaultContainer;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/react-overlays/lib/utils/ownerDocument.js":
      /*!****************************************************************!*\
  !*** ./node_modules/react-overlays/lib/utils/ownerDocument.js ***!
  \****************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;

        exports.default = function(componentOrElement) {
          return (0, _ownerDocument2.default)(
            _reactDom2.default.findDOMNode(componentOrElement)
          );
        };

        var _reactDom = __webpack_require__(
          /*! react-dom */ "./node_modules/preact-compat/dist/preact-compat.es.js"
        );

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _ownerDocument = __webpack_require__(
          /*! dom-helpers/ownerDocument */ "./node_modules/dom-helpers/ownerDocument.js"
        );

        var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/uncontrollable/index.js":
      /*!**********************************************!*\
  !*** ./node_modules/uncontrollable/index.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.default = uncontrollable;

        var _react = _interopRequireDefault(
          __webpack_require__(
            /*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js"
          )
        );

        var _invariant = _interopRequireDefault(
          __webpack_require__(
            /*! invariant */ "./node_modules/invariant/browser.js"
          )
        );

        var Utils = _interopRequireWildcard(
          __webpack_require__(
            /*! ./utils */ "./node_modules/uncontrollable/utils.js"
          )
        );

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  var desc =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(obj, key)
                      : {};

                  if (desc.get || desc.set) {
                    Object.defineProperty(newObj, key, desc);
                  } else {
                    newObj[key] = obj[key];
                  }
                }
              }
            }

            newObj.default = obj;
            return newObj;
          }
        }

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        function _extends() {
          _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];

                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }

              return target;
            };

          return _extends.apply(this, arguments);
        }

        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;

          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }

          return target;
        }

        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }

        function uncontrollable(Component, controlledValues, methods) {
          if (methods === void 0) {
            methods = [];
          }

          var displayName =
            Component.displayName || Component.name || "Component";
          var canAcceptRef = Utils.canAcceptRef(Component);
          var controlledProps = Object.keys(controlledValues);
          var PROPS_TO_OMIT = controlledProps.map(Utils.defaultKey);
          !(canAcceptRef || !methods.length)
            ? true
              ? (0, _invariant.default)(
                  false,
                  "[uncontrollable] stateless function components cannot pass through methods " +
                    "because they have no associated instances. Check component: " +
                    displayName +
                    ", " +
                    "attempting to pass through methods: " +
                    methods.join(", ")
                )
              : undefined
            : void 0;

          var UncontrolledComponent =
            /*#__PURE__*/
            (function(_React$Component) {
              _inheritsLoose(UncontrolledComponent, _React$Component);

              function UncontrolledComponent() {
                var _this;

                for (
                  var _len = arguments.length, args = new Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key];
                }

                _this =
                  _React$Component.call.apply(
                    _React$Component,
                    [this].concat(args)
                  ) || this;
                _this.handlers = Object.create(null);
                controlledProps.forEach(function(propName) {
                  var handlerName = controlledValues[propName];

                  var handleChange = function handleChange(value) {
                    if (_this.props[handlerName]) {
                      var _this$props;

                      _this._notifying = true;

                      for (
                        var _len2 = arguments.length,
                          args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                          _key2 = 1;
                        _key2 < _len2;
                        _key2++
                      ) {
                        args[_key2 - 1] = arguments[_key2];
                      }

                      (_this$props = _this.props)[handlerName].apply(
                        _this$props,
                        [value].concat(args)
                      );

                      _this._notifying = false;
                    }

                    _this._values[propName] = value;
                    if (!_this.unmounted) _this.forceUpdate();
                  };

                  _this.handlers[handlerName] = handleChange;
                });
                if (methods.length)
                  _this.attachRef = function(ref) {
                    _this.inner = ref;
                  };
                return _this;
              }

              var _proto = UncontrolledComponent.prototype;

              _proto.shouldComponentUpdate = function shouldComponentUpdate() {
                //let the forceUpdate trigger the update
                return !this._notifying;
              };

              _proto.componentWillMount = function componentWillMount() {
                var _this2 = this;

                var props = this.props;
                this._values = Object.create(null);
                controlledProps.forEach(function(key) {
                  _this2._values[key] = props[Utils.defaultKey(key)];
                });
              };

              _proto.componentWillReceiveProps = function componentWillReceiveProps(
                nextProps
              ) {
                var _this3 = this;

                var props = this.props;
                controlledProps.forEach(function(key) {
                  /**
                   * If a prop switches from controlled to Uncontrolled
                   * reset its value to the defaultValue
                   */
                  if (
                    !Utils.isProp(nextProps, key) &&
                    Utils.isProp(props, key)
                  ) {
                    _this3._values[key] = nextProps[Utils.defaultKey(key)];
                  }
                });
              };

              _proto.componentWillUnmount = function componentWillUnmount() {
                this.unmounted = true;
              };

              _proto.render = function render() {
                var _this4 = this;

                var _this$props2 = this.props,
                  innerRef = _this$props2.innerRef,
                  props = _objectWithoutPropertiesLoose(_this$props2, [
                    "innerRef",
                  ]);

                PROPS_TO_OMIT.forEach(function(prop) {
                  delete props[prop];
                });
                var newProps = {};
                controlledProps.forEach(function(propName) {
                  var propValue = _this4.props[propName];
                  newProps[propName] =
                    propValue !== undefined
                      ? propValue
                      : _this4._values[propName];
                });
                return _react.default.createElement(
                  Component,
                  _extends({}, props, newProps, this.handlers, {
                    ref: innerRef || this.attachRef,
                  })
                );
              };

              return UncontrolledComponent;
            })(_react.default.Component);

          UncontrolledComponent.displayName =
            "Uncontrolled(" + displayName + ")";
          UncontrolledComponent.propTypes = _extends(
            {
              innerRef: function innerRef() {},
            },
            Utils.uncontrolledPropTypes(controlledValues, displayName)
          );
          methods.forEach(function(method) {
            UncontrolledComponent.prototype[
              method
            ] = function $proxiedMethod() {
              var _this$inner;

              return (_this$inner = this.inner)[method].apply(
                _this$inner,
                arguments
              );
            };
          });
          var WrappedComponent = UncontrolledComponent;

          if (_react.default.forwardRef) {
            WrappedComponent = _react.default.forwardRef(function(props, ref) {
              return _react.default.createElement(
                UncontrolledComponent,
                _extends({}, props, {
                  innerRef: ref,
                })
              );
            });
            WrappedComponent.propTypes = UncontrolledComponent.propTypes;
          }

          WrappedComponent.ControlledComponent = Component;
          /**
           * useful when wrapping a Component and you want to control
           * everything
           */

          WrappedComponent.deferControlTo = function(
            newComponent,
            additions,
            nextMethods
          ) {
            if (additions === void 0) {
              additions = {};
            }

            return uncontrollable(
              newComponent,
              _extends({}, controlledValues, additions),
              nextMethods
            );
          };

          return WrappedComponent;
        }

        module.exports = exports["default"];

        /***/
      },

    /***/ "./node_modules/uncontrollable/utils.js":
      /*!**********************************************!*\
  !*** ./node_modules/uncontrollable/utils.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        "use strict";

        exports.__esModule = true;
        exports.uncontrolledPropTypes = uncontrolledPropTypes;
        exports.isProp = isProp;
        exports.defaultKey = defaultKey;
        exports.canAcceptRef = canAcceptRef;

        var _invariant = _interopRequireDefault(
          __webpack_require__(
            /*! invariant */ "./node_modules/invariant/browser.js"
          )
        );

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj,
              };
        }

        var noop = function noop() {};

        function readOnlyPropType(handler, name) {
          return function(props, propName) {
            if (props[propName] !== undefined) {
              if (!props[handler]) {
                return new Error(
                  "You have provided a `" +
                    propName +
                    "` prop to `" +
                    name +
                    "` " +
                    ("without an `" +
                      handler +
                      "` handler prop. This will render a read-only field. ") +
                    ("If the field should be mutable use `" +
                      defaultKey(propName) +
                      "`. ") +
                    ("Otherwise, set `" + handler + "`.")
                );
              }
            }
          };
        }

        function uncontrolledPropTypes(controlledValues, displayName) {
          var propTypes = {};
          Object.keys(controlledValues).forEach(function(prop) {
            // add default propTypes for folks that use runtime checks
            propTypes[defaultKey(prop)] = noop;

            if (true) {
              var handler = controlledValues[prop];
              !(typeof handler === "string" && handler.trim().length)
                ? true
                  ? (0, _invariant.default)(
                      false,
                      "Uncontrollable - [%s]: the prop `%s` needs a valid handler key name in order to make it uncontrollable",
                      displayName,
                      prop
                    )
                  : undefined
                : void 0;
              propTypes[prop] = readOnlyPropType(handler, displayName);
            }
          });
          return propTypes;
        }

        function isProp(props, prop) {
          return props[prop] !== undefined;
        }

        function defaultKey(key) {
          return "default" + key.charAt(0).toUpperCase() + key.substr(1);
        }
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         */

        function canAcceptRef(component) {
          return (
            !!component &&
            (typeof component !== "function" ||
              (component.prototype && component.prototype.isReactComponent))
          );
        }

        /***/
      },

    /***/ "./node_modules/webpack/buildin/amd-options.js":
      /*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /* WEBPACK VAR INJECTION */ (function(__webpack_amd_options__) {
          /* globals __webpack_amd_options__ */
          module.exports = __webpack_amd_options__;

          /* WEBPACK VAR INJECTION */
        }.call(this, {}));

        /***/
      },

    /***/ "./node_modules/webpack/buildin/global.js":
      /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        function _typeof(obj) {
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var g; // This works in non-strict mode

        g = (function() {
          return this;
        })();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (
            (typeof window === "undefined" ? "undefined" : _typeof(window)) ===
            "object"
          )
            g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;

        /***/
      },
  },
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9yc35wYW5lbC1jYWxlbmRhci5jaHVuay5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItbGlzdGJveC9wYXBlci1saXN0Ym94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRlLWFyaXRobWV0aWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2NsYXNzL2FkZENsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9jbGFzcy9oYXNDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvY2xhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2NsYXNzL3JlbW92ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9ldmVudHMvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2V2ZW50cy9saXN0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2V2ZW50cy9vZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2V2ZW50cy9vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvb3duZXJEb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvY2xvc2VzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3F1ZXJ5L2hlaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvaXNXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3F1ZXJ5L21hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3F1ZXJ5L29mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvb2Zmc2V0UGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9xdWVyeS9wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvcXVlcnlTZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvc2Nyb2xsTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvcXVlcnkvc2Nyb2xsVG9wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9xdWVyeS93aWR0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvc3R5bGUvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvc3R5bGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3N0eWxlL3JlbW92ZVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy90cmFuc2l0aW9uL2lzVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy90cmFuc2l0aW9uL3Byb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3V0aWwvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3V0aWwvY2FtZWxpemVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvdXRpbC9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3V0aWwvaHlwaGVuYXRlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3V0aWwvaW5ET00uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL3V0aWwvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy91dGlsL3Njcm9sbGJhclNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJhbmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVSYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jdXN0b21PbWl0Q2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3BhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jaHVuay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JhbmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc29ydEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMtZXh0cmEvbGliL2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leHRyYS9saWIvY29tcG9uZW50T3JFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzLWV4dHJhL2xpYi9lbGVtZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leHRyYS9saWIvdXRpbHMvY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1iaWctY2FsZW5kYXIvZGlzdC9yZWFjdC1iaWctY2FsZW5kYXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1iaWctY2FsZW5kYXIvbGliL3V0aWxzL2RhdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1iaWctY2FsZW5kYXIvbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2Rpc3QvbWVtb2l6ZS1vbmUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1iaWctY2FsZW5kYXIvbm9kZV9tb2R1bGVzL3dhcm5pbmcvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3ZlcmxheXMvbGliL0xlZ2FjeVBvcnRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3ZlcmxheXMvbGliL092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW92ZXJsYXlzL2xpYi9Qb3J0YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW92ZXJsYXlzL2xpYi9Qb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3ZlcmxheXMvbGliL1Jvb3RDbG9zZVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW92ZXJsYXlzL2xpYi91dGlscy9hZGRFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1vdmVybGF5cy9saWIvdXRpbHMvY2FsY3VsYXRlUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW92ZXJsYXlzL2xpYi91dGlscy9nZXRDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW92ZXJsYXlzL2xpYi91dGlscy9vd25lckRvY3VtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmNvbnRyb2xsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5jb250cm9sbGFibGUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzXG5wYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50XG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1sZWdhY3kuanMnO1xuXG5pbXBvcnQge0lyb25Gb3JtRWxlbWVudEJlaGF2aW9yfSBmcm9tICdAcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyc7XG5pbXBvcnQge0lyb25WYWxpZGF0YWJsZUJlaGF2aW9yfSBmcm9tICdAcG9seW1lci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMnO1xuXG4vKipcbiAqIFVzZSBgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JgIHRvIGltcGxlbWVudCBhIGN1c3RvbSBlbGVtZW50IHRoYXQgaGFzIGFcbiAqIGBjaGVja2VkYCBwcm9wZXJ0eSwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24gaWYgdGhlIGVsZW1lbnQgaXMgYWxzb1xuICogYHJlcXVpcmVkYC4gRWxlbWVudCBpbnN0YW5jZXMgaW1wbGVtZW50aW5nIHRoaXMgYmVoYXZpb3Igd2lsbCBhbHNvIGJlXG4gKiByZWdpc3RlcmVkIGZvciB1c2UgaW4gYW4gYGlyb24tZm9ybWAgZWxlbWVudC5cbiAqXG4gKiBAZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiAqIEBwb2x5bWVyQmVoYXZpb3IgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JcbiAqL1xuZXhwb3J0IGNvbnN0IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tY2hhbmdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHN0YXRlLCBgdHJ1ZWAgaXMgY2hlY2tlZCBhbmQgYGZhbHNlYCBpcyB1bmNoZWNrZWQuXG4gICAgICovXG4gICAgY2hlY2tlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX2NoZWNrZWRDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAqL1xuICAgIHRvZ2dsZXM6IHt0eXBlOiBCb29sZWFuLCB2YWx1ZTogdHJ1ZSwgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlfSxcblxuICAgIC8qIE92ZXJyaWRlbiBmcm9tIElyb25Gb3JtRWxlbWVudEJlaGF2aW9yICovXG4gICAgdmFsdWU6IHt0eXBlOiBTdHJpbmcsIHZhbHVlOiAnb24nLCBvYnNlcnZlcjogJ192YWx1ZUNoYW5nZWQnfVxuICB9LFxuXG4gIG9ic2VydmVyczogWydfcmVxdWlyZWRDaGFuZ2VkKHJlcXVpcmVkKSddLFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZWQgYnkgYGlyb24tZm9ybWAgdG8gaGFuZGxlIHRoZSBjYXNlIHRoYXQgYW4gZWxlbWVudCB3aXRoIHRoaXMgYmVoYXZpb3JcbiAgICAvLyBkb2Vzbid0IGhhdmUgYSByb2xlIG9mICdjaGVja2JveCcgb3IgJ3JhZGlvJywgYnV0IHNob3VsZCBzdGlsbCBvbmx5IGJlXG4gICAgLy8gaW5jbHVkZWQgd2hlbiB0aGUgZm9ybSBpcyBzZXJpYWxpemVkIGlmIGB0aGlzLmNoZWNrZWQgPT09IHRydWVgLlxuICAgIHRoaXMuX2hhc0lyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZWxlbWVudCBpcyByZXF1aXJlZCBhbmQgbm90IGNoZWNrZWQsIGFuZCB0cnVlXG4gICAqIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHsqPX0gX3ZhbHVlIElnbm9yZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYHJlcXVpcmVkYCBpcyBmYWxzZSBvciBpZiBgY2hlY2tlZGAgaXMgdHJ1ZS5cbiAgICovXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24oX3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMucmVxdWlyZWQgfHwgdGhpcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFyaWEtcmVxdWlyZWQgbGFiZWwgd2hlbiBgcmVxdWlyZWRgIGlzIGNoYW5nZWQuXG4gICAqL1xuICBfcmVxdWlyZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXF1aXJlZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnLCAndHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmlyZSBgaXJvbi1jaGFuZ2VkYCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAqL1xuICBfY2hlY2tlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5jaGVja2VkO1xuICAgIHRoaXMuZmlyZSgnaXJvbi1jaGFuZ2UnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgdmFsdWUgdG8gJ29uJyBpZiBpdCBpcyBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gICAqL1xuICBfdmFsdWVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnb24nO1xuICAgIH1cbiAgfVxufTtcblxuLyoqIEBwb2x5bWVyQmVoYXZpb3IgKi9cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IsXG4gIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWxlZ2FjeS5qcyc7XG5cbi8qKlxuICBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciBhZGRzIGEgYG5hbWVgLCBgdmFsdWVgIGFuZCBgcmVxdWlyZWRgIHByb3BlcnRpZXMgdG9cbiAgYSBjdXN0b20gZWxlbWVudC4gSXQgbW9zdGx5IGV4aXN0cyBmb3IgYmFja2NvbXBhdGliaWxpdHkgd2l0aCBQb2x5bWVyIDEueCwgYW5kXG4gIGlzIHByb2JhYmx5IG5vdCBzb21ldGhpbmcgeW91IHdhbnQgdG8gdXNlLlxuXG4gIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICBAcG9seW1lckJlaGF2aW9yXG4gKi9cbmV4cG9ydCBjb25zdCBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdmFsdWU6IHtub3RpZnk6IHRydWUsIHR5cGU6IFN0cmluZ30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtYXJrIHRoZSBpbnB1dCBhcyByZXF1aXJlZC4gSWYgdXNlZCBpbiBhIGZvcm0sIGFcbiAgICAgKiBjdXN0b20gZWxlbWVudCB0aGF0IHVzZXMgdGhpcyBiZWhhdmlvciBzaG91bGQgYWxzbyB1c2VcbiAgICAgKiBJcm9uVmFsaWRhdGFibGVCZWhhdmlvciBhbmQgZGVmaW5lIGEgY3VzdG9tIHZhbGlkYXRpb24gbWV0aG9kLlxuICAgICAqIE90aGVyd2lzZSwgYSBgcmVxdWlyZWRgIGVsZW1lbnQgd2lsbCBhbHdheXMgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgICAgKiBJdCdzIGFsc28gc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcHJvdmlkZSBhIHZpc3VhbCBzdHlsZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiB3aGVuIGl0cyB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiB7dHlwZTogQm9vbGVhbiwgdmFsdWU6IGZhbHNlfSxcbiAgfSxcblxuICAvLyBFbXB0eSBpbXBsZW1lbnRhdGlvbnMgZm9yIGJhY2tjb21wYXRpYmlsaXR5LlxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7fSxcbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge31cbn07XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWxlZ2FjeS5qcyc7XG5cbmltcG9ydCB7SXJvbk1ldGF9IGZyb20gJ0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMnO1xuXG4vKipcbiAqIFNpbmdsZXRvbiBJcm9uTWV0YSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGxldCBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgPSBudWxsO1xuXG4vKipcbiAqIGBVc2UgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JgIHRvIGltcGxlbWVudCBhbiBlbGVtZW50IHRoYXQgdmFsaWRhdGVzXG4gKiB1c2VyIGlucHV0LiBVc2UgdGhlIHJlbGF0ZWQgYElyb25WYWxpZGF0b3JCZWhhdmlvcmAgdG8gYWRkIGN1c3RvbVxuICogdmFsaWRhdGlvbiBsb2dpYyB0byBhbiBpcm9uLWlucHV0LlxuICpcbiAqIEJ5IGRlZmF1bHQsIGFuIGA8aXJvbi1mb3JtPmAgZWxlbWVudCB2YWxpZGF0ZXMgaXRzIGZpZWxkcyB3aGVuIHRoZSB1c2VyXG4gKiBwcmVzc2VzIHRoZSBzdWJtaXQgYnV0dG9uLiBUbyB2YWxpZGF0ZSBhIGZvcm0gaW1wZXJhdGl2ZWx5LCBjYWxsIHRoZSBmb3JtJ3NcbiAqIGB2YWxpZGF0ZSgpYCBtZXRob2QsIHdoaWNoIGluIHR1cm4gd2lsbCBjYWxsIGB2YWxpZGF0ZSgpYCBvbiBhbGwgaXRzXG4gKiBjaGlsZHJlbi4gQnkgdXNpbmcgYElyb25WYWxpZGF0YWJsZUJlaGF2aW9yYCwgeW91ciBjdXN0b20gZWxlbWVudFxuICogd2lsbCBnZXQgYSBwdWJsaWMgYHZhbGlkYXRlKClgLCB3aGljaCB3aWxsIHJldHVybiB0aGUgdmFsaWRpdHkgb2YgdGhlXG4gKiBlbGVtZW50LCBhbmQgYSBjb3JyZXNwb25kaW5nIGBpbnZhbGlkYCBhdHRyaWJ1dGUsIHdoaWNoIGNhbiBiZSB1c2VkIGZvclxuICogc3R5bGluZy5cbiAqXG4gKiBUbyBpbXBsZW1lbnQgdGhlIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljIG9mIHlvdXIgZWxlbWVudCwgeW91IG11c3Qgb3ZlcnJpZGVcbiAqIHRoZSBwcm90ZWN0ZWQgYF9nZXRWYWxpZGl0eSgpYCBtZXRob2Qgb2YgdGhpcyBiZWhhdmlvdXIsIHJhdGhlciB0aGFuXG4gKiBgdmFsaWRhdGUoKWAuIFNlZVxuICogW3RoaXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyRWxlbWVudHMvaXJvbi1mb3JtL2Jsb2IvbWFzdGVyL2RlbW8vc2ltcGxlLWVsZW1lbnQuaHRtbClcbiAqIGZvciBhbiBleGFtcGxlLlxuICpcbiAqICMjIyBBY2Nlc3NpYmlsaXR5XG4gKlxuICogQ2hhbmdpbmcgdGhlIGBpbnZhbGlkYCBwcm9wZXJ0eSwgZWl0aGVyIG1hbnVhbGx5IG9yIGJ5IGNhbGxpbmcgYHZhbGlkYXRlKClgXG4gKiB3aWxsIHVwZGF0ZSB0aGUgYGFyaWEtaW52YWxpZGAgYXR0cmlidXRlLlxuICpcbiAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICogQHBvbHltZXJCZWhhdmlvclxuICovXG5leHBvcnQgY29uc3QgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHZhbGlkYXRvciB0byB1c2UuXG4gICAgICovXG4gICAgdmFsaWRhdG9yOiB7dHlwZTogU3RyaW5nfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGxhc3QgY2FsbCB0byBgdmFsaWRhdGVgIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJ1xuICAgIH0sXG4gIH0sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbmV3IElyb25NZXRhKHt0eXBlOiAndmFsaWRhdG9yJ30pO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyogUmVjb21wdXRlIHRoaXMgZXZlcnkgdGltZSBpdCdzIG5lZWRlZCwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGlmIHRoZVxuICAgKiB1bmRlcmx5aW5nIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSBoYXMgY2hhbmdlZC4gKi9cbiAgZ2V0IF92YWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSAmJlxuICAgICAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEuYnlLZXkodGhpcy52YWxpZGF0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWxpZGF0b3IgYHZhbGlkYXRvcmAgZXhpc3RzLlxuICAgKi9cbiAgaGFzVmFsaWRhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCwgYW5kIHVwZGF0ZXMgYGludmFsaWRgLiBJZiB5b3Ugd2FudFxuICAgKiB5b3VyIGVsZW1lbnQgdG8gaGF2ZSBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYywgZG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kO1xuICAgKiBvdmVycmlkZSBgX2dldFZhbGlkaXR5KHZhbHVlKWAgaW5zdGVhZC5cblxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgRGVwcmVjYXRlZDogVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC4gQnkgZGVmYXVsdCxcbiAgICogaXQgaXMgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzXG4gICBzZXQuXG4gICAqIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB0aGUgZWxlbWVudCdzIGB2YWx1ZWAgcHJvcGVydHlcbiAgICogaXMgdXNlZCwgaWYgaXQgZXhpc3RzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuXG4gICAqL1xuICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIGVsZW1lbnQgdGhhdCBhbHNvIGhhcyBhIHZhbHVlIHByb3BlcnR5LCBhbmQgdGhlcmUgd2FzXG4gICAgLy8gbm8gZXhwbGljaXQgdmFsdWUgYXJndW1lbnQgcGFzc2VkLCB1c2UgdGhlIGVsZW1lbnQncyBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuaW52YWxpZCA9ICF0aGlzLl9nZXRWYWxpZGl0eSh0aGlzLnZhbHVlKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmludmFsaWQgPSAhdGhpcy5fZ2V0VmFsaWRpdHkodmFsdWUpO1xuICAgIHJldHVybiAhdGhpcy5pbnZhbGlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gIEJ5IGRlZmF1bHQsIGl0IGlzIHBhc3NlZFxuICAgKiB0byB0aGUgdmFsaWRhdG9yJ3MgYHZhbGlkYXRlKClgIGZ1bmN0aW9uLCBpZiBhIHZhbGlkYXRvciBpcyBzZXQuIFlvdVxuICAgKiBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gaW1wbGVtZW50IGN1c3RvbSB2YWxpZGl0eVxuICAgKiBsb2dpYyBmb3IgeW91ciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLlxuICAgKi9cblxuICBfZ2V0VmFsaWRpdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzVmFsaWRhdG9yKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcblxuaW1wb3J0IHtJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciwgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsfSBmcm9tICdAcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyc7XG5cbmltcG9ydCB7UGFwZXJJbmt5Rm9jdXNCZWhhdmlvcn0gZnJvbSAnLi9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7UGFwZXJSaXBwbGVCZWhhdmlvcn0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuXG4vKipcbiAqIFVzZSBgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yYCB0byBpbXBsZW1lbnQgYSBjdXN0b20gZWxlbWVudCB0aGF0IGhhcyBhXG4gKiBgY2hlY2tlZGAgcHJvcGVydHkgc2ltaWxhciB0byBgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JgIGFuZCBpcyBjb21wYXRpYmxlXG4gKiB3aXRoIGhhdmluZyBhIHJpcHBsZSBlZmZlY3QuXG4gKiBAcG9seW1lckJlaGF2aW9yIFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvclxuICovXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGNoZWNrZWQgc3RhdGUgd2l0aCBpdHMgcmlwcGxlIGVmZmVjdC5cbiAgICovXG4gIF9jaGVja2VkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsLl9jaGVja2VkQ2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yaXBwbGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIGVsZW1lbnQncyBgYWN0aXZlYCBhbmQgYGNoZWNrZWRgIHN0YXRlLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgUGFwZXJSaXBwbGVCZWhhdmlvci5fYnV0dG9uU3RhdGVDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5hY3RpdmU7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQHBvbHltZXJCZWhhdmlvciAqL1xuZXhwb3J0IGNvbnN0IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvcixcbiAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IsXG4gIFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWxlZ2FjeS5qcyc7XG5pbXBvcnQgJ0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcblxuaW1wb3J0IHtJcm9uTWVudUJlaGF2aW9yfSBmcm9tICdAcG9seW1lci9pcm9uLW1lbnUtYmVoYXZpb3IvaXJvbi1tZW51LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7UG9seW1lcn0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHtodG1sfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcyc7XG5cbi8qKlxuTWF0ZXJpYWwgZGVzaWduOlxuW01lbnVzXShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvbWVudXMuaHRtbClcblxuYDxwYXBlci1saXN0Ym94PmAgaW1wbGVtZW50cyBhbiBhY2Nlc3NpYmxlIGxpc3Rib3ggY29udHJvbCB3aXRoIE1hdGVyaWFsIERlc2lnblxuc3R5bGluZy4gVGhlIGZvY3VzZWQgaXRlbSBpcyBoaWdobGlnaHRlZCwgYW5kIHRoZSBzZWxlY3RlZCBpdGVtIGhhcyBib2xkZWQgdGV4dC5cblxuICAgIDxwYXBlci1saXN0Ym94PlxuICAgICAgPHBhcGVyLWl0ZW0+SXRlbSAxPC9wYXBlci1pdGVtPlxuICAgICAgPHBhcGVyLWl0ZW0+SXRlbSAyPC9wYXBlci1pdGVtPlxuICAgIDwvcGFwZXItbGlzdGJveD5cblxuQW4gaW5pdGlhbCBzZWxlY3Rpb24gY2FuIGJlIHNwZWNpZmllZCB3aXRoIHRoZSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZS5cblxuICAgIDxwYXBlci1saXN0Ym94IHNlbGVjdGVkPVwiMFwiPlxuICAgICAgPHBhcGVyLWl0ZW0+SXRlbSAxPC9wYXBlci1pdGVtPlxuICAgICAgPHBhcGVyLWl0ZW0+SXRlbSAyPC9wYXBlci1pdGVtPlxuICAgIDwvcGFwZXItbGlzdGJveD5cblxuTWFrZSBhIG11bHRpLXNlbGVjdCBsaXN0Ym94IHdpdGggdGhlIGBtdWx0aWAgYXR0cmlidXRlLiBJdGVtcyBpbiBhIG11bHRpLXNlbGVjdFxubGlzdGJveCBjYW4gYmUgZGVzZWxlY3RlZCwgYW5kIG11bHRpcGxlIGl0ZW0gY2FuIGJlIHNlbGVjdGVkLlxuXG4gICAgPHBhcGVyLWxpc3Rib3ggbXVsdGk+XG4gICAgICA8cGFwZXItaXRlbT5JdGVtIDE8L3BhcGVyLWl0ZW0+XG4gICAgICA8cGFwZXItaXRlbT5JdGVtIDI8L3BhcGVyLWl0ZW0+XG4gICAgPC9wYXBlci1saXN0Ym94PlxuXG4jIyMgU3R5bGluZ1xuXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFuZCBtaXhpbnMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcblxuQ3VzdG9tIHByb3BlcnR5IHwgRGVzY3JpcHRpb24gfCBEZWZhdWx0XG4tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLVxuYC0tcGFwZXItbGlzdGJveC1iYWNrZ3JvdW5kLWNvbG9yYCAgIHwgTWVudSBiYWNrZ3JvdW5kIGNvbG9yIHxcbmAtLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcmBcbmAtLXBhcGVyLWxpc3Rib3gtY29sb3JgICAgICAgICAgICAgICB8IE1lbnUgZm9yZWdyb3VuZCBjb2xvciB8XG5gLS1wcmltYXJ5LXRleHQtY29sb3JgXG5gLS1wYXBlci1saXN0Ym94YCAgICAgICAgICAgICAgICAgICAgfCBNaXhpbiBhcHBsaWVkIHRvIHRoZSBsaXN0Ym94IHwgYHt9YFxuXG4jIyMgQWNjZXNzaWJpbGl0eVxuXG5gPHBhcGVyLWxpc3Rib3g+YCBoYXMgYHJvbGU9XCJsaXN0Ym94XCJgIGJ5IGRlZmF1bHQuIEEgbXVsdGktc2VsZWN0IGxpc3Rib3ggd2lsbFxuYWxzbyBoYXZlIGBhcmlhLW11bHRpc2VsZWN0YWJsZWAgc2V0LiBJdCBpbXBsZW1lbnRzIGtleSBiaW5kaW5ncyB0byBuYXZpZ2F0ZVxudGhyb3VnaCB0aGUgbGlzdGJveCB3aXRoIHRoZSB1cCBhbmQgZG93biBhcnJvdyBrZXlzLCBlc2MgdG8gZXhpdCB0aGUgbGlzdGJveCxcbmFuZCBlbnRlciB0byBhY3RpdmF0ZSBhIGxpc3Rib3ggaXRlbS4gVHlwaW5nIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBsaXN0Ym94IGl0ZW1cbndpbGwgYWxzbyBmb2N1cyBpdC5cblxuQGdyb3VwIFBhcGVyIEVsZW1lbnRzXG5AZWxlbWVudCBwYXBlci1saXN0Ym94XG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiovXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBodG1sYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBhZGRpbmc6IDhweCAwO1xuXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXBhcGVyLWxpc3Rib3gtYmFja2dyb3VuZC1jb2xvciwgdmFyKC0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yKSk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1saXN0Ym94LWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1saXN0Ym94O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG5gLFxuXG4gIGlzOiAncGFwZXItbGlzdGJveCcsXG4gIGJlaGF2aW9yczogW0lyb25NZW51QmVoYXZpb3JdLFxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBob3N0QXR0cmlidXRlczoge3JvbGU6ICdsaXN0Ym94J31cbn0pO1xuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwidmFyIE1JTEkgICAgPSAnbWlsbGlzZWNvbmRzJ1xuICAsIFNFQ09ORFMgPSAnc2Vjb25kcydcbiAgLCBNSU5VVEVTID0gJ21pbnV0ZXMnXG4gICwgSE9VUlMgICA9ICdob3VycydcbiAgLCBEQVkgICAgID0gJ2RheSdcbiAgLCBXRUVLICAgID0gJ3dlZWsnXG4gICwgTU9OVEggICA9ICdtb250aCdcbiAgLCBZRUFSICAgID0gJ3llYXInXG4gICwgREVDQURFICA9ICdkZWNhZGUnXG4gICwgQ0VOVFVSWSA9ICdjZW50dXJ5JztcblxudmFyIGRhdGVzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYWRkOiBmdW5jdGlvbihkYXRlLCBudW0sIHVuaXQpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSlcblxuICAgIHN3aXRjaCAodW5pdCl7XG4gICAgICBjYXNlIE1JTEk6XG4gICAgICBjYXNlIFNFQ09ORFM6XG4gICAgICBjYXNlIE1JTlVURVM6XG4gICAgICBjYXNlIEhPVVJTOlxuICAgICAgY2FzZSBZRUFSOlxuICAgICAgICByZXR1cm4gZGF0ZXNbdW5pdF0oZGF0ZSwgZGF0ZXNbdW5pdF0oZGF0ZSkgKyBudW0pXG4gICAgICBjYXNlIERBWTpcbiAgICAgICAgcmV0dXJuIGRhdGVzLmRhdGUoZGF0ZSwgZGF0ZXMuZGF0ZShkYXRlKSArIG51bSlcbiAgICAgIGNhc2UgV0VFSzpcbiAgICAgICAgcmV0dXJuIGRhdGVzLmRhdGUoZGF0ZSwgZGF0ZXMuZGF0ZShkYXRlKSArICg3ICogbnVtKSkgXG4gICAgICBjYXNlIE1PTlRIOlxuICAgICAgICByZXR1cm4gbW9udGhNYXRoKGRhdGUsIG51bSlcbiAgICAgIGNhc2UgREVDQURFOlxuICAgICAgICByZXR1cm4gZGF0ZXMueWVhcihkYXRlLCBkYXRlcy55ZWFyKGRhdGUpICsgKG51bSAqIDEwKSlcbiAgICAgIGNhc2UgQ0VOVFVSWTpcbiAgICAgICAgcmV0dXJuIGRhdGVzLnllYXIoZGF0ZSwgZGF0ZXMueWVhcihkYXRlKSArIChudW0gKiAxMDApKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdW5pdHM6IFwiJyArIHVuaXQgKyAnXCInKVxuICB9LFxuXG4gIHN1YnRyYWN0OiBmdW5jdGlvbihkYXRlLCBudW0sIHVuaXQpIHtcbiAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGUsIC1udW0sIHVuaXQpXG4gIH0sXG5cbiAgc3RhcnRPZjogZnVuY3Rpb24oZGF0ZSwgdW5pdCwgZmlyc3RPZldlZWspIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSlcblxuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnY2VudHVyeSc6XG4gICAgICBjYXNlICdkZWNhZGUnOlxuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgZGF0ZSA9IGRhdGVzLm1vbnRoKGRhdGUsIDApO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGRhdGUgPSBkYXRlcy5kYXRlKGRhdGUsIDEpO1xuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGRhdGUgPSBkYXRlcy5ob3VycyhkYXRlLCAwKTtcbiAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICBkYXRlID0gZGF0ZXMubWludXRlcyhkYXRlLCAwKTtcbiAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICAgIGRhdGUgPSBkYXRlcy5zZWNvbmRzKGRhdGUsIDApO1xuICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgICAgZGF0ZSA9IGRhdGVzLm1pbGxpc2Vjb25kcyhkYXRlLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdCA9PT0gREVDQURFKSBcbiAgICAgIGRhdGUgPSBkYXRlcy5zdWJ0cmFjdChkYXRlLCBkYXRlcy55ZWFyKGRhdGUpICUgMTAsICd5ZWFyJylcbiAgICBcbiAgICBpZiAodW5pdCA9PT0gQ0VOVFVSWSkgXG4gICAgICBkYXRlID0gZGF0ZXMuc3VidHJhY3QoZGF0ZSwgZGF0ZXMueWVhcihkYXRlKSAlIDEwMCwgJ3llYXInKVxuXG4gICAgaWYgKHVuaXQgPT09IFdFRUspIFxuICAgICAgZGF0ZSA9IGRhdGVzLndlZWtkYXkoZGF0ZSwgMCwgZmlyc3RPZldlZWspO1xuXG4gICAgcmV0dXJuIGRhdGVcbiAgfSxcblxuXG4gIGVuZE9mOiBmdW5jdGlvbihkYXRlLCB1bml0LCBmaXJzdE9mV2Vlayl7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gICAgZGF0ZSA9IGRhdGVzLnN0YXJ0T2YoZGF0ZSwgdW5pdCwgZmlyc3RPZldlZWspXG4gICAgZGF0ZSA9IGRhdGVzLmFkZChkYXRlLCAxLCB1bml0KVxuICAgIGRhdGUgPSBkYXRlcy5zdWJ0cmFjdChkYXRlLCAxLCBNSUxJKVxuICAgIHJldHVybiBkYXRlXG4gIH0sXG5cbiAgZXE6ICBjcmVhdGVDb21wYXJlcihmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEgPT09IGIgfSksXG4gIG5lcTogY3JlYXRlQ29tcGFyZXIoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhICE9PSBiIH0pLFxuICBndDogIGNyZWF0ZUNvbXBhcmVyKGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYSA+IGIgfSksXG4gIGd0ZTogY3JlYXRlQ29tcGFyZXIoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhID49IGIgfSksXG4gIGx0OiAgY3JlYXRlQ29tcGFyZXIoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhIDwgYiB9KSxcbiAgbHRlOiBjcmVhdGVDb21wYXJlcihmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEgPD0gYiB9KSxcblxuICBtaW46IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3VtZW50cykpXG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLm1heC5hcHBseShNYXRoLCBhcmd1bWVudHMpKVxuICB9LFxuICBcbiAgaW5SYW5nZTogZnVuY3Rpb24oZGF5LCBtaW4sIG1heCwgdW5pdCl7XG4gICAgdW5pdCA9IHVuaXQgfHwgJ2RheSdcblxuICAgIHJldHVybiAoIW1pbiB8fCBkYXRlcy5ndGUoZGF5LCBtaW4sIHVuaXQpKVxuICAgICAgICAmJiAoIW1heCB8fCBkYXRlcy5sdGUoZGF5LCBtYXgsIHVuaXQpKVxuICB9LFxuXG4gIG1pbGxpc2Vjb25kczogICBjcmVhdGVBY2Nlc3NvcignTWlsbGlzZWNvbmRzJyksXG4gIHNlY29uZHM6ICAgICAgICBjcmVhdGVBY2Nlc3NvcignU2Vjb25kcycpLFxuICBtaW51dGVzOiAgICAgICAgY3JlYXRlQWNjZXNzb3IoJ01pbnV0ZXMnKSxcbiAgaG91cnM6ICAgICAgICAgIGNyZWF0ZUFjY2Vzc29yKCdIb3VycycpLFxuICBkYXk6ICAgICAgICAgICAgY3JlYXRlQWNjZXNzb3IoJ0RheScpLFxuICBkYXRlOiAgICAgICAgICAgY3JlYXRlQWNjZXNzb3IoJ0RhdGUnKSxcbiAgbW9udGg6ICAgICAgICAgIGNyZWF0ZUFjY2Vzc29yKCdNb250aCcpLFxuICB5ZWFyOiAgICAgICAgICAgY3JlYXRlQWNjZXNzb3IoJ0Z1bGxZZWFyJyksXG5cbiAgZGVjYWRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkIFxuICAgICAgPyBkYXRlcy55ZWFyKGRhdGVzLnN0YXJ0T2YoZGF0ZSwgREVDQURFKSlcbiAgICAgIDogZGF0ZXMuYWRkKGRhdGUsIHZhbCArIDEwLCBZRUFSKTtcbiAgfSxcblxuICBjZW50dXJ5OiBmdW5jdGlvbiAoZGF0ZSwgdmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkIFxuICAgICAgPyBkYXRlcy55ZWFyKGRhdGVzLnN0YXJ0T2YoZGF0ZSwgQ0VOVFVSWSkpXG4gICAgICA6IGRhdGVzLmFkZChkYXRlLCB2YWwgKyAxMDAsIFlFQVIpO1xuICB9LFxuXG4gIHdlZWtkYXk6IGZ1bmN0aW9uIChkYXRlLCB2YWwsIGZpcnN0RGF5KSB7XG4gICAgICB2YXIgd2Vla2RheSA9IChkYXRlcy5kYXkoZGF0ZSkgKyA3IC0gKGZpcnN0RGF5IHx8IDApICkgJSA3O1xuXG4gICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgXG4gICAgICAgID8gd2Vla2RheSBcbiAgICAgICAgOiBkYXRlcy5hZGQoZGF0ZSwgdmFsIC0gd2Vla2RheSwgREFZKTtcbiAgfSxcblxuICBkaWZmOiBmdW5jdGlvbiAoZGF0ZTEsIGRhdGUyLCB1bml0LCBhc0Zsb2F0KSB7XG4gICAgdmFyIGRpdmlkZW5kLCBkaXZpc29yLCByZXN1bHQ7XG5cbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgTUlMSTpcbiAgICAgIGNhc2UgU0VDT05EUzpcbiAgICAgIGNhc2UgTUlOVVRFUzpcbiAgICAgIGNhc2UgSE9VUlM6XG4gICAgICBjYXNlIERBWTpcbiAgICAgIGNhc2UgV0VFSzpcbiAgICAgICAgZGl2aWRlbmQgPSBkYXRlMi5nZXRUaW1lKCkgLSBkYXRlMS5nZXRUaW1lKCk7IGJyZWFrO1xuICAgICAgY2FzZSBNT05USDpcbiAgICAgIGNhc2UgWUVBUjpcbiAgICAgIGNhc2UgREVDQURFOlxuICAgICAgY2FzZSBDRU5UVVJZOlxuICAgICAgICBkaXZpZGVuZCA9IChkYXRlcy55ZWFyKGRhdGUyKSAtIGRhdGVzLnllYXIoZGF0ZTEpKSAqIDEyICsgZGF0ZXMubW9udGgoZGF0ZTIpIC0gZGF0ZXMubW9udGgoZGF0ZTEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdW5pdHM6IFwiJyArIHVuaXQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgTUlMSTpcbiAgICAgICAgICBkaXZpc29yID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIFNFQ09ORFM6XG4gICAgICAgICAgZGl2aXNvciA9IDEwMDA7IGJyZWFrO1xuICAgICAgY2FzZSBNSU5VVEVTOlxuICAgICAgICAgIGRpdmlzb3IgPSAxMDAwICogNjA7IGJyZWFrO1xuICAgICAgY2FzZSBIT1VSUzpcbiAgICAgICAgICBkaXZpc29yID0gMTAwMCAqIDYwICogNjA7IGJyZWFrO1xuICAgICAgY2FzZSBEQVk6XG4gICAgICAgICAgZGl2aXNvciA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IGJyZWFrO1xuICAgICAgY2FzZSBXRUVLOlxuICAgICAgICAgIGRpdmlzb3IgPSAxMDAwICogNjAgKiA2MCAqIDI0ICogNzsgYnJlYWs7XG4gICAgICBjYXNlIE1PTlRIOlxuICAgICAgICAgIGRpdmlzb3IgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgWUVBUjpcbiAgICAgICAgICBkaXZpc29yID0gMTI7IGJyZWFrO1xuICAgICAgY2FzZSBERUNBREU6XG4gICAgICAgICAgZGl2aXNvciA9IDEyMDsgYnJlYWs7XG4gICAgICBjYXNlIENFTlRVUlk6XG4gICAgICAgICAgZGl2aXNvciA9IDEyMDA7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB1bml0czogXCInICsgdW5pdCArICdcIicpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGRpdmlkZW5kIC8gZGl2aXNvcjtcblxuICAgIHJldHVybiBhc0Zsb2F0ID8gcmVzdWx0IDogYWJzb2x1dGVGbG9vcihyZXN1bHQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhYnNvbHV0ZUZsb29yKG51bWJlcikge1xuICByZXR1cm4gbnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBtb250aE1hdGgoZGF0ZSwgdmFsKXtcbiAgdmFyIGN1cnJlbnQgPSBkYXRlcy5tb250aChkYXRlKVxuICAgICwgbmV3TW9udGggID0gKGN1cnJlbnQgKyB2YWwpO1xuXG4gICAgZGF0ZSA9IGRhdGVzLm1vbnRoKGRhdGUsIG5ld01vbnRoKVxuXG4gICAgd2hpbGUgKG5ld01vbnRoIDwgMCApIG5ld01vbnRoID0gMTIgKyBuZXdNb250aFxuICAgICAgXG4gICAgLy9tb250aCByb2xsb3ZlclxuICAgIGlmICggZGF0ZXMubW9udGgoZGF0ZSkgIT09ICggbmV3TW9udGggJSAxMikpXG4gICAgICBkYXRlID0gZGF0ZXMuZGF0ZShkYXRlLCAwKSAvL21vdmUgdG8gbGFzdCBvZiBtb250aFxuXG4gICAgcmV0dXJuIGRhdGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWNjZXNzb3IobWV0aG9kKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIHZhbCl7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGRhdGVbJ2dldCcgKyBtZXRob2RdKClcblxuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKVxuICAgIGRhdGVbJ3NldCcgKyBtZXRob2RdKHZhbClcbiAgICByZXR1cm4gZGF0ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBhcmVyKG9wZXJhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgdW5pdCkge1xuICAgIHJldHVybiBvcGVyYXRvcigrZGF0ZXMuc3RhcnRPZihhLCB1bml0KSwgK2RhdGVzLnN0YXJ0T2YoYiwgdW5pdCkpXG4gIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcblxudmFyIF9oYXNDbGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGFzQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtlbHNlIGlmICghKDAsIF9oYXNDbGFzcy5kZWZhdWx0KShlbGVtZW50LCBjbGFzc05hbWUpKSBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVtZW50LmNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBoYXNDbGFzcztcblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7ZWxzZSByZXR1cm4gKFwiIFwiICsgKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWxlbWVudC5jbGFzc05hbWUpICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9hZGRDbGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYWRkQ2xhc3NcIikpO1xuXG5leHBvcnRzLmFkZENsYXNzID0gX2FkZENsYXNzLmRlZmF1bHQ7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlbW92ZUNsYXNzXCIpKTtcblxuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IF9yZW1vdmVDbGFzcy5kZWZhdWx0O1xuXG52YXIgX2hhc0NsYXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oYXNDbGFzc1wiKSk7XG5cbmV4cG9ydHMuaGFzQ2xhc3MgPSBfaGFzQ2xhc3MuZGVmYXVsdDtcbnZhciBfZGVmYXVsdCA9IHtcbiAgYWRkQ2xhc3M6IF9hZGRDbGFzcy5kZWZhdWx0LFxuICByZW1vdmVDbGFzczogX3JlbW92ZUNsYXNzLmRlZmF1bHQsXG4gIGhhc0NsYXNzOiBfaGFzQ2xhc3MuZGVmYXVsdFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmVwbGFjZUNsYXNzTmFtZShvcmlnQ2xhc3MsIGNsYXNzVG9SZW1vdmUpIHtcbiAgcmV0dXJuIG9yaWdDbGFzcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc1RvUmVtb3ZlICsgJyg/OlxcXFxzfCQpJywgJ2cnKSwgJyQxJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUsIGNsYXNzTmFtZSk7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgJycsIGNsYXNzTmFtZSkpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBmaWx0ZXJFdmVudHM7XG5cbnZhciBfY29udGFpbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9xdWVyeS9jb250YWluc1wiKSk7XG5cbnZhciBfcXVlcnlTZWxlY3RvckFsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3F1ZXJ5L3F1ZXJ5U2VsZWN0b3JBbGxcIikpO1xuXG5mdW5jdGlvbiBmaWx0ZXJFdmVudHMoc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpbHRlckhhbmRsZXIoZSkge1xuICAgIHZhciB0b3AgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHRhcmdldCA9IGUudGFyZ2V0LFxuICAgICAgICBtYXRjaGVzID0gKDAsIF9xdWVyeVNlbGVjdG9yQWxsLmRlZmF1bHQpKHRvcCwgc2VsZWN0b3IpO1xuICAgIGlmIChtYXRjaGVzLnNvbWUoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gKDAsIF9jb250YWlucy5kZWZhdWx0KShtYXRjaCwgdGFyZ2V0KTtcbiAgICB9KSkgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9vbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vb25cIikpO1xuXG5leHBvcnRzLm9uID0gX29uLmRlZmF1bHQ7XG5cbnZhciBfb2ZmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9vZmZcIikpO1xuXG5leHBvcnRzLm9mZiA9IF9vZmYuZGVmYXVsdDtcblxudmFyIF9maWx0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlclwiKSk7XG5cbmV4cG9ydHMuZmlsdGVyID0gX2ZpbHRlci5kZWZhdWx0O1xuXG52YXIgX2xpc3RlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGlzdGVuXCIpKTtcblxuZXhwb3J0cy5saXN0ZW4gPSBfbGlzdGVuLmRlZmF1bHQ7XG52YXIgX2RlZmF1bHQgPSB7XG4gIG9uOiBfb24uZGVmYXVsdCxcbiAgb2ZmOiBfb2ZmLmRlZmF1bHQsXG4gIGZpbHRlcjogX2ZpbHRlci5kZWZhdWx0LFxuICBsaXN0ZW46IF9saXN0ZW4uZGVmYXVsdFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9pbkRPTSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWwvaW5ET01cIikpO1xuXG52YXIgX29uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9vblwiKSk7XG5cbnZhciBfb2ZmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9vZmZcIikpO1xuXG52YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKCkge307XG5cbmlmIChfaW5ET00uZGVmYXVsdCkge1xuICBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgKDAsIF9vbi5kZWZhdWx0KShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAoMCwgX29mZi5kZWZhdWx0KShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgIH07XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IGxpc3RlbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaW5ET00gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2luRE9NXCIpKTtcblxudmFyIG9mZiA9IGZ1bmN0aW9uIG9mZigpIHt9O1xuXG5pZiAoX2luRE9NLmRlZmF1bHQpIHtcbiAgb2ZmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH07ZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHJldHVybiBmdW5jdGlvbiAobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuICB9KCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG9mZjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaW5ET00gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2luRE9NXCIpKTtcblxudmFyIG9uID0gZnVuY3Rpb24gb24oKSB7fTtcblxuaWYgKF9pbkRPTS5kZWZhdWx0KSB7XG4gIG9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH07ZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHJldHVybiBmdW5jdGlvbiAobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIGUudGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBub2RlO1xuICAgICAgICBoYW5kbGVyLmNhbGwobm9kZSwgZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gb3duZXJEb2N1bWVudDtcblxuZnVuY3Rpb24gb3duZXJEb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9zZXN0O1xuXG52YXIgX21hdGNoZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21hdGNoZXNcIikpO1xuXG52YXIgaXNEb2MgPSBmdW5jdGlvbiBpc0RvYyhvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5ub2RlVHlwZSA9PT0gb2JqLkRPQ1VNRU5UX05PREU7XG59O1xuXG5mdW5jdGlvbiBjbG9zZXN0KG5vZGUsIHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gIHdoaWxlIChub2RlICYmIChpc0RvYyhub2RlKSB8fCAhKDAsIF9tYXRjaGVzLmRlZmF1bHQpKG5vZGUsIHNlbGVjdG9yKSkpIHtcbiAgICBub2RlID0gbm9kZSAhPT0gY29udGV4dCAmJiAhaXNEb2Mobm9kZSkgPyBub2RlLnBhcmVudE5vZGUgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaW5ET00gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2luRE9NXCIpKTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBIVE1MIERPTSBhbmQgU1ZHIERPTSBtYXkgaGF2ZSBkaWZmZXJlbnQgc3VwcG9ydCBsZXZlbHMsXG4gIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgb24gY29udGV4dCBpbnN0ZWFkIG9mIGEgZG9jdW1lbnQgcm9vdCBlbGVtZW50LlxuICByZXR1cm4gX2luRE9NLmRlZmF1bHQgPyBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSkge1xuICAgIGlmIChjb250ZXh0LmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5jb250YWlucyhub2RlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBjb250ZXh0ID09PSBub2RlIHx8ICEhKGNvbnRleHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxsYmFjayhjb250ZXh0LCBub2RlKTtcbiAgICB9XG4gIH0gOiBmYWxsYmFjaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmZ1bmN0aW9uIGZhbGxiYWNrKGNvbnRleHQsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIGRvIHtcbiAgICBpZiAobm9kZSA9PT0gY29udGV4dCkgcmV0dXJuIHRydWU7XG4gIH0gd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gaGVpZ2h0O1xuXG52YXIgX29mZnNldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vb2Zmc2V0XCIpKTtcblxudmFyIF9pc1dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNXaW5kb3dcIikpO1xuXG5mdW5jdGlvbiBoZWlnaHQobm9kZSwgY2xpZW50KSB7XG4gIHZhciB3aW4gPSAoMCwgX2lzV2luZG93LmRlZmF1bHQpKG5vZGUpO1xuICByZXR1cm4gd2luID8gd2luLmlubmVySGVpZ2h0IDogY2xpZW50ID8gbm9kZS5jbGllbnRIZWlnaHQgOiAoMCwgX29mZnNldC5kZWZhdWx0KShub2RlKS5oZWlnaHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRXaW5kb3c7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBub2RlLndpbmRvdyA/IG5vZGUgOiBub2RlLm5vZGVUeXBlID09PSA5ID8gbm9kZS5kZWZhdWx0VmlldyB8fCBub2RlLnBhcmVudFdpbmRvdyA6IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXM7XG5cbnZhciBfaW5ET00gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2luRE9NXCIpKTtcblxudmFyIF9xdWVyeVNlbGVjdG9yQWxsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9xdWVyeVNlbGVjdG9yQWxsXCIpKTtcblxudmFyIG1hdGNoZXNDYWNoZTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhub2RlLCBzZWxlY3Rvcikge1xuICBpZiAoIW1hdGNoZXNDYWNoZSAmJiBfaW5ET00uZGVmYXVsdCkge1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgbmF0aXZlTWF0Y2ggPSBib2R5Lm1hdGNoZXMgfHwgYm9keS5tYXRjaGVzU2VsZWN0b3IgfHwgYm9keS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgYm9keS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgYm9keS5tc01hdGNoZXNTZWxlY3RvcjtcbiAgICBtYXRjaGVzQ2FjaGUgPSBuYXRpdmVNYXRjaCA/IGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIG5hdGl2ZU1hdGNoLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xuICAgIH0gOiBpZThNYXRjaGVzU2VsZWN0b3I7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlc0NhY2hlID8gbWF0Y2hlc0NhY2hlKG5vZGUsIHNlbGVjdG9yKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGllOE1hdGNoZXNTZWxlY3Rvcihub2RlLCBzZWxlY3Rvcikge1xuICB2YXIgbWF0Y2hlcyA9ICgwLCBfcXVlcnlTZWxlY3RvckFsbC5kZWZhdWx0KShub2RlLmRvY3VtZW50IHx8IG5vZGUub3duZXJEb2N1bWVudCwgc2VsZWN0b3IpLFxuICAgICAgaSA9IDA7XG5cbiAgd2hpbGUgKG1hdGNoZXNbaV0gJiYgbWF0Y2hlc1tpXSAhPT0gbm9kZSkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiAhIW1hdGNoZXNbaV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gb2Zmc2V0O1xuXG52YXIgX2NvbnRhaW5zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb250YWluc1wiKSk7XG5cbnZhciBfaXNXaW5kb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzV2luZG93XCIpKTtcblxudmFyIF9vd25lckRvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vb3duZXJEb2N1bWVudFwiKSk7XG5cbmZ1bmN0aW9uIG9mZnNldChub2RlKSB7XG4gIHZhciBkb2MgPSAoMCwgX293bmVyRG9jdW1lbnQuZGVmYXVsdCkobm9kZSksXG4gICAgICB3aW4gPSAoMCwgX2lzV2luZG93LmRlZmF1bHQpKGRvYyksXG4gICAgICBkb2NFbGVtID0gZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBib3ggPSB7XG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHdpZHRoOiAwXG4gIH07XG4gIGlmICghZG9jKSByZXR1cm47IC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXG4gIGlmICghKDAsIF9jb250YWlucy5kZWZhdWx0KShkb2NFbGVtLCBub2RlKSkgcmV0dXJuIGJveDtcbiAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSB1bmRlZmluZWQpIGJveCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIElFOCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZG9lc24ndCBzdXBwb3J0IHdpZHRoICYgaGVpZ2h0XG5cbiAgYm94ID0ge1xuICAgIHRvcDogYm94LnRvcCArICh3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3ApIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApLFxuICAgIGxlZnQ6IGJveC5sZWZ0ICsgKHdpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQpIC0gKGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwKSxcbiAgICB3aWR0aDogKGJveC53aWR0aCA9PSBudWxsID8gbm9kZS5vZmZzZXRXaWR0aCA6IGJveC53aWR0aCkgfHwgMCxcbiAgICBoZWlnaHQ6IChib3guaGVpZ2h0ID09IG51bGwgPyBub2RlLm9mZnNldEhlaWdodCA6IGJveC5oZWlnaHQpIHx8IDBcbiAgfTtcbiAgcmV0dXJuIGJveDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBvZmZzZXRQYXJlbnQ7XG5cbnZhciBfb3duZXJEb2N1bWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL293bmVyRG9jdW1lbnRcIikpO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc3R5bGVcIikpO1xuXG5mdW5jdGlvbiBub2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVOYW1lICYmIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0UGFyZW50KG5vZGUpIHtcbiAgdmFyIGRvYyA9ICgwLCBfb3duZXJEb2N1bWVudC5kZWZhdWx0KShub2RlKSxcbiAgICAgIG9mZnNldFBhcmVudCA9IG5vZGUgJiYgbm9kZS5vZmZzZXRQYXJlbnQ7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBub2RlTmFtZShub2RlKSAhPT0gJ2h0bWwnICYmICgwLCBfc3R5bGUuZGVmYXVsdCkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBvc2l0aW9uO1xuXG52YXIgX2V4dGVuZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpKTtcblxudmFyIF9vZmZzZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL29mZnNldFwiKSk7XG5cbnZhciBfb2Zmc2V0UGFyZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9vZmZzZXRQYXJlbnRcIikpO1xuXG52YXIgX3Njcm9sbFRvcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2Nyb2xsVG9wXCIpKTtcblxudmFyIF9zY3JvbGxMZWZ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zY3JvbGxMZWZ0XCIpKTtcblxudmFyIF9zdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3N0eWxlXCIpKTtcblxuZnVuY3Rpb24gbm9kZU5hbWUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSAmJiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUsIG9mZnNldFBhcmVudCkge1xuICB2YXIgcGFyZW50T2Zmc2V0ID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0sXG4gICAgICBvZmZzZXQ7IC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG4gIC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXG4gIGlmICgoMCwgX3N0eWxlLmRlZmF1bHQpKG5vZGUsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgb2Zmc2V0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQgfHwgKDAsIF9vZmZzZXRQYXJlbnQuZGVmYXVsdCkobm9kZSk7XG4gICAgb2Zmc2V0ID0gKDAsIF9vZmZzZXQuZGVmYXVsdCkobm9kZSk7XG4gICAgaWYgKG5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdodG1sJykgcGFyZW50T2Zmc2V0ID0gKDAsIF9vZmZzZXQuZGVmYXVsdCkob2Zmc2V0UGFyZW50KTtcbiAgICBwYXJlbnRPZmZzZXQudG9wICs9IHBhcnNlSW50KCgwLCBfc3R5bGUuZGVmYXVsdCkob2Zmc2V0UGFyZW50LCAnYm9yZGVyVG9wV2lkdGgnKSwgMTApIC0gKDAsIF9zY3JvbGxUb3AuZGVmYXVsdCkob2Zmc2V0UGFyZW50KSB8fCAwO1xuICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlSW50KCgwLCBfc3R5bGUuZGVmYXVsdCkob2Zmc2V0UGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJyksIDEwKSAtICgwLCBfc2Nyb2xsTGVmdC5kZWZhdWx0KShvZmZzZXRQYXJlbnQpIHx8IDA7XG4gIH0gLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIG5vZGUgbWFyZ2luc1xuXG5cbiAgcmV0dXJuICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe30sIG9mZnNldCwge1xuICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSAocGFyc2VJbnQoKDAsIF9zdHlsZS5kZWZhdWx0KShub2RlLCAnbWFyZ2luVG9wJyksIDEwKSB8fCAwKSxcbiAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0gKHBhcnNlSW50KCgwLCBfc3R5bGUuZGVmYXVsdCkobm9kZSwgJ21hcmdpbkxlZnQnKSwgMTApIHx8IDApXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gcXNhO1xuLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTUgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbnZhciBzaW1wbGVTZWxlY3RvclJFID0gL15bXFx3LV0qJC87XG52YXIgdG9BcnJheSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIFtdLnNsaWNlKTtcblxuZnVuY3Rpb24gcXNhKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIHZhciBtYXliZUlEID0gc2VsZWN0b3JbMF0gPT09ICcjJyxcbiAgICAgIG1heWJlQ2xhc3MgPSBzZWxlY3RvclswXSA9PT0gJy4nLFxuICAgICAgbmFtZU9ubHkgPSBtYXliZUlEIHx8IG1heWJlQ2xhc3MgPyBzZWxlY3Rvci5zbGljZSgxKSA6IHNlbGVjdG9yLFxuICAgICAgaXNTaW1wbGUgPSBzaW1wbGVTZWxlY3RvclJFLnRlc3QobmFtZU9ubHkpLFxuICAgICAgZm91bmQ7XG5cbiAgaWYgKGlzU2ltcGxlKSB7XG4gICAgaWYgKG1heWJlSUQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmdldEVsZW1lbnRCeUlkID8gZWxlbWVudCA6IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIChmb3VuZCA9IGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZU9ubHkpKSA/IFtmb3VuZF0gOiBbXTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIG1heWJlQ2xhc3MpIHJldHVybiB0b0FycmF5KGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lT25seSkpO1xuICAgIHJldHVybiB0b0FycmF5KGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcbiAgfVxuXG4gIHJldHVybiB0b0FycmF5KGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNjcm9sbFRvcDtcblxudmFyIF9pc1dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNXaW5kb3dcIikpO1xuXG5mdW5jdGlvbiBzY3JvbGxUb3Aobm9kZSwgdmFsKSB7XG4gIHZhciB3aW4gPSAoMCwgX2lzV2luZG93LmRlZmF1bHQpKG5vZGUpO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiB3aW4gPyAncGFnZVhPZmZzZXQnIGluIHdpbiA/IHdpbi5wYWdlWE9mZnNldCA6IHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG5vZGUuc2Nyb2xsTGVmdDtcbiAgaWYgKHdpbikgd2luLnNjcm9sbFRvKHZhbCwgJ3BhZ2VZT2Zmc2V0JyBpbiB3aW4gPyB3aW4ucGFnZVlPZmZzZXQgOiB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7ZWxzZSBub2RlLnNjcm9sbExlZnQgPSB2YWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gc2Nyb2xsVG9wO1xuXG52YXIgX2lzV2luZG93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1dpbmRvd1wiKSk7XG5cbmZ1bmN0aW9uIHNjcm9sbFRvcChub2RlLCB2YWwpIHtcbiAgdmFyIHdpbiA9ICgwLCBfaXNXaW5kb3cuZGVmYXVsdCkobm9kZSk7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHdpbiA/ICdwYWdlWU9mZnNldCcgaW4gd2luID8gd2luLnBhZ2VZT2Zmc2V0IDogd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBub2RlLnNjcm9sbFRvcDtcbiAgaWYgKHdpbikgd2luLnNjcm9sbFRvKCdwYWdlWE9mZnNldCcgaW4gd2luID8gd2luLnBhZ2VYT2Zmc2V0IDogd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCB2YWwpO2Vsc2Ugbm9kZS5zY3JvbGxUb3AgPSB2YWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2lkdGg7XG5cbnZhciBfb2Zmc2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9vZmZzZXRcIikpO1xuXG52YXIgX2lzV2luZG93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1dpbmRvd1wiKSk7XG5cbmZ1bmN0aW9uIHdpZHRoKG5vZGUsIGNsaWVudCkge1xuICB2YXIgd2luID0gKDAsIF9pc1dpbmRvdy5kZWZhdWx0KShub2RlKTtcbiAgcmV0dXJuIHdpbiA/IHdpbi5pbm5lcldpZHRoIDogY2xpZW50ID8gbm9kZS5jbGllbnRXaWR0aCA6ICgwLCBfb2Zmc2V0LmRlZmF1bHQpKG5vZGUpLndpZHRoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9nZXRDb21wdXRlZFN0eWxlO1xuXG52YXIgX2NhbWVsaXplU3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2NhbWVsaXplU3R5bGVcIikpO1xuXG52YXIgcnBvc2l0aW9uID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvO1xudmFyIHJudW1ub25weCA9IC9eKFsrLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KSkoPyFweClbYS16JV0rJC9pO1xuXG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSB7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gRWxlbWVudCBwYXNzZWQgdG8gYGdldENvbXB1dGVkU3R5bGUoKWAnKTtcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuICdkZWZhdWx0VmlldycgaW4gZG9jID8gZG9jLmRlZmF1bHRWaWV3Lm9wZW5lciA/IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpIDogd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkgOiB7XG4gICAgLy9pZSA4IFwibWFnaWNcIiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzEuMTEtc3RhYmxlL3NyYy9jc3MvY3VyQ1NTLmpzI0w3MlxuICAgIGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUocHJvcCkge1xuICAgICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICAgIHByb3AgPSAoMCwgX2NhbWVsaXplU3R5bGUuZGVmYXVsdCkocHJvcCk7XG4gICAgICBpZiAocHJvcCA9PSAnZmxvYXQnKSBwcm9wID0gJ3N0eWxlRmxvYXQnO1xuICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmN1cnJlbnRTdHlsZVtwcm9wXSB8fCBudWxsO1xuICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCAmJiBzdHlsZSAmJiBzdHlsZVtwcm9wXSkgY3VycmVudCA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBpZiAocm51bW5vbnB4LnRlc3QoY3VycmVudCkgJiYgIXJwb3NpdGlvbi50ZXN0KHByb3ApKSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgdmFyIGxlZnQgPSBzdHlsZS5sZWZ0O1xuICAgICAgICB2YXIgcnVuU3R5bGUgPSBub2RlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgdmFyIHJzTGVmdCA9IHJ1blN0eWxlICYmIHJ1blN0eWxlLmxlZnQ7IC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblxuICAgICAgICBpZiAocnNMZWZ0KSBydW5TdHlsZS5sZWZ0ID0gbm9kZS5jdXJyZW50U3R5bGUubGVmdDtcbiAgICAgICAgc3R5bGUubGVmdCA9IHByb3AgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IGN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQgPSBzdHlsZS5waXhlbExlZnQgKyAncHgnOyAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cbiAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGlmIChyc0xlZnQpIHJ1blN0eWxlLmxlZnQgPSByc0xlZnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBzdHlsZTtcblxudmFyIF9jYW1lbGl6ZVN0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbC9jYW1lbGl6ZVN0eWxlXCIpKTtcblxudmFyIF9oeXBoZW5hdGVTdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWwvaHlwaGVuYXRlU3R5bGVcIikpO1xuXG52YXIgX2dldENvbXB1dGVkU3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9nZXRDb21wdXRlZFN0eWxlXCIpKTtcblxudmFyIF9yZW1vdmVTdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVtb3ZlU3R5bGVcIikpO1xuXG52YXIgX3Byb3BlcnRpZXMgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi9wcm9wZXJ0aWVzXCIpO1xuXG52YXIgX2lzVHJhbnNmb3JtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi9pc1RyYW5zZm9ybVwiKSk7XG5cbmZ1bmN0aW9uIHN0eWxlKG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICB2YXIgY3NzID0gJyc7XG4gIHZhciB0cmFuc2Zvcm1zID0gJyc7XG4gIHZhciBwcm9wcyA9IHByb3BlcnR5O1xuXG4gIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBub2RlLnN0eWxlWygwLCBfY2FtZWxpemVTdHlsZS5kZWZhdWx0KShwcm9wZXJ0eSldIHx8ICgwLCBfZ2V0Q29tcHV0ZWRTdHlsZTIuZGVmYXVsdCkobm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgoMCwgX2h5cGhlbmF0ZVN0eWxlLmRlZmF1bHQpKHByb3BlcnR5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChwcm9wcyA9IHt9KVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblxuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICgwLCBfcmVtb3ZlU3R5bGUuZGVmYXVsdCkobm9kZSwgKDAsIF9oeXBoZW5hdGVTdHlsZS5kZWZhdWx0KShrZXkpKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNUcmFuc2Zvcm0uZGVmYXVsdCkoa2V5KSkge1xuICAgICAgdHJhbnNmb3JtcyArPSBrZXkgKyBcIihcIiArIHZhbHVlICsgXCIpIFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3MgKz0gKDAsIF9oeXBoZW5hdGVTdHlsZS5kZWZhdWx0KShrZXkpICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIjtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICh0cmFuc2Zvcm1zKSB7XG4gICAgY3NzICs9IF9wcm9wZXJ0aWVzLnRyYW5zZm9ybSArIFwiOiBcIiArIHRyYW5zZm9ybXMgKyBcIjtcIjtcbiAgfVxuXG4gIG5vZGUuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVTdHlsZTtcblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGUobm9kZSwga2V5KSB7XG4gIHJldHVybiAncmVtb3ZlUHJvcGVydHknIGluIG5vZGUuc3R5bGUgPyBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSkgOiBub2RlLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNUcmFuc2Zvcm07XG52YXIgc3VwcG9ydGVkVHJhbnNmb3JtcyA9IC9eKCh0cmFuc2xhdGV8cm90YXRlfHNjYWxlKShYfFl8WnwzZCk/fG1hdHJpeCgzZCk/fHBlcnNwZWN0aXZlfHNrZXcoWHxZKT8pJC9pO1xuXG5mdW5jdGlvbiBpc1RyYW5zZm9ybShwcm9wZXJ0eSkge1xuICByZXR1cm4gISEocHJvcGVydHkgJiYgc3VwcG9ydGVkVHJhbnNmb3Jtcy50ZXN0KHByb3BlcnR5KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5hbmltYXRpb25FbmQgPSBleHBvcnRzLmFuaW1hdGlvbkRlbGF5ID0gZXhwb3J0cy5hbmltYXRpb25UaW1pbmcgPSBleHBvcnRzLmFuaW1hdGlvbkR1cmF0aW9uID0gZXhwb3J0cy5hbmltYXRpb25OYW1lID0gZXhwb3J0cy50cmFuc2l0aW9uRW5kID0gZXhwb3J0cy50cmFuc2l0aW9uRHVyYXRpb24gPSBleHBvcnRzLnRyYW5zaXRpb25EZWxheSA9IGV4cG9ydHMudHJhbnNpdGlvblRpbWluZyA9IGV4cG9ydHMudHJhbnNpdGlvblByb3BlcnR5ID0gZXhwb3J0cy50cmFuc2Zvcm0gPSB2b2lkIDA7XG5cbnZhciBfaW5ET00gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2luRE9NXCIpKTtcblxudmFyIHRyYW5zZm9ybSA9ICd0cmFuc2Zvcm0nO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG52YXIgcHJlZml4LCB0cmFuc2l0aW9uRW5kLCBhbmltYXRpb25FbmQ7XG5leHBvcnRzLmFuaW1hdGlvbkVuZCA9IGFuaW1hdGlvbkVuZDtcbmV4cG9ydHMudHJhbnNpdGlvbkVuZCA9IHRyYW5zaXRpb25FbmQ7XG52YXIgdHJhbnNpdGlvblByb3BlcnR5LCB0cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25UaW1pbmcsIHRyYW5zaXRpb25EZWxheTtcbmV4cG9ydHMudHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5O1xuZXhwb3J0cy50cmFuc2l0aW9uVGltaW5nID0gdHJhbnNpdGlvblRpbWluZztcbmV4cG9ydHMudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuZXhwb3J0cy50cmFuc2l0aW9uUHJvcGVydHkgPSB0cmFuc2l0aW9uUHJvcGVydHk7XG52YXIgYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uRHVyYXRpb24sIGFuaW1hdGlvblRpbWluZywgYW5pbWF0aW9uRGVsYXk7XG5leHBvcnRzLmFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0aW9uRGVsYXk7XG5leHBvcnRzLmFuaW1hdGlvblRpbWluZyA9IGFuaW1hdGlvblRpbWluZztcbmV4cG9ydHMuYW5pbWF0aW9uRHVyYXRpb24gPSBhbmltYXRpb25EdXJhdGlvbjtcbmV4cG9ydHMuYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWU7XG5cbmlmIChfaW5ET00uZGVmYXVsdCkge1xuICB2YXIgX2dldFRyYW5zaXRpb25Qcm9wZXJ0ID0gZ2V0VHJhbnNpdGlvblByb3BlcnRpZXMoKTtcblxuICBwcmVmaXggPSBfZ2V0VHJhbnNpdGlvblByb3BlcnQucHJlZml4O1xuICBleHBvcnRzLnRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kID0gX2dldFRyYW5zaXRpb25Qcm9wZXJ0LnRyYW5zaXRpb25FbmQ7XG4gIGV4cG9ydHMuYW5pbWF0aW9uRW5kID0gYW5pbWF0aW9uRW5kID0gX2dldFRyYW5zaXRpb25Qcm9wZXJ0LmFuaW1hdGlvbkVuZDtcbiAgZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0gPSBwcmVmaXggKyBcIi1cIiArIHRyYW5zZm9ybTtcbiAgZXhwb3J0cy50cmFuc2l0aW9uUHJvcGVydHkgPSB0cmFuc2l0aW9uUHJvcGVydHkgPSBwcmVmaXggKyBcIi10cmFuc2l0aW9uLXByb3BlcnR5XCI7XG4gIGV4cG9ydHMudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uID0gcHJlZml4ICsgXCItdHJhbnNpdGlvbi1kdXJhdGlvblwiO1xuICBleHBvcnRzLnRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheSA9IHByZWZpeCArIFwiLXRyYW5zaXRpb24tZGVsYXlcIjtcbiAgZXhwb3J0cy50cmFuc2l0aW9uVGltaW5nID0gdHJhbnNpdGlvblRpbWluZyA9IHByZWZpeCArIFwiLXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXCI7XG4gIGV4cG9ydHMuYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWUgPSBwcmVmaXggKyBcIi1hbmltYXRpb24tbmFtZVwiO1xuICBleHBvcnRzLmFuaW1hdGlvbkR1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb24gPSBwcmVmaXggKyBcIi1hbmltYXRpb24tZHVyYXRpb25cIjtcbiAgZXhwb3J0cy5hbmltYXRpb25UaW1pbmcgPSBhbmltYXRpb25UaW1pbmcgPSBwcmVmaXggKyBcIi1hbmltYXRpb24tZGVsYXlcIjtcbiAgZXhwb3J0cy5hbmltYXRpb25EZWxheSA9IGFuaW1hdGlvbkRlbGF5ID0gcHJlZml4ICsgXCItYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiO1xufVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICBlbmQ6IHRyYW5zaXRpb25FbmQsXG4gIHByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHksXG4gIHRpbWluZzogdHJhbnNpdGlvblRpbWluZyxcbiAgZGVsYXk6IHRyYW5zaXRpb25EZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvblxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUHJvcGVydGllcygpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHZhciB2ZW5kb3JNYXAgPSB7XG4gICAgTzogZnVuY3Rpb24gTyhlKSB7XG4gICAgICByZXR1cm4gXCJvXCIgKyBlLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcbiAgICBNb3o6IGZ1bmN0aW9uIE1veihlKSB7XG4gICAgICByZXR1cm4gZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgV2Via2l0OiBmdW5jdGlvbiBXZWJraXQoZSkge1xuICAgICAgcmV0dXJuIFwid2Via2l0XCIgKyBlO1xuICAgIH0sXG4gICAgbXM6IGZ1bmN0aW9uIG1zKGUpIHtcbiAgICAgIHJldHVybiBcIk1TXCIgKyBlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHZlbmRvcnMgPSBPYmplY3Qua2V5cyh2ZW5kb3JNYXApO1xuICB2YXIgdHJhbnNpdGlvbkVuZCwgYW5pbWF0aW9uRW5kO1xuICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZlbmRvciA9IHZlbmRvcnNbaV07XG5cbiAgICBpZiAodmVuZG9yICsgXCJUcmFuc2l0aW9uUHJvcGVydHlcIiBpbiBzdHlsZSkge1xuICAgICAgcHJlZml4ID0gXCItXCIgKyB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSB2ZW5kb3JNYXBbdmVuZG9yXSgnVHJhbnNpdGlvbkVuZCcpO1xuICAgICAgYW5pbWF0aW9uRW5kID0gdmVuZG9yTWFwW3ZlbmRvcl0oJ0FuaW1hdGlvbkVuZCcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0cmFuc2l0aW9uRW5kICYmICd0cmFuc2l0aW9uUHJvcGVydHknIGluIHN0eWxlKSB0cmFuc2l0aW9uRW5kID0gJ3RyYW5zaXRpb25lbmQnO1xuICBpZiAoIWFuaW1hdGlvbkVuZCAmJiAnYW5pbWF0aW9uTmFtZScgaW4gc3R5bGUpIGFuaW1hdGlvbkVuZCA9ICdhbmltYXRpb25lbmQnO1xuICBzdHlsZSA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0aW9uRW5kOiBhbmltYXRpb25FbmQsXG4gICAgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCxcbiAgICBwcmVmaXg6IHByZWZpeFxuICB9O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2FtZWxpemU7XG52YXIgckh5cGhlbiA9IC8tKC4pL2c7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2Uockh5cGhlbiwgZnVuY3Rpb24gKF8sIGNocikge1xuICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cbnZhciBfY2FtZWxpemUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NhbWVsaXplXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzJhZWI4YTJhNmJlYjAwNjE3YTQyMTdmN2Y4Mjg0OTI0ZmEyYWQ4MTkvc3JjL3ZlbmRvci9jb3JlL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4gKi9cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuICgwLCBfY2FtZWxpemUuZGVmYXVsdCkoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gaHlwaGVuYXRlO1xudmFyIHJVcHBlciA9IC8oW0EtWl0pL2c7XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJVcHBlciwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG52YXIgX2h5cGhlbmF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHlwaGVuYXRlXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzJhZWI4YTJhNmJlYjAwNjE3YTQyMTdmN2Y4Mjg0OTI0ZmEyYWQ4MTkvc3JjL3ZlbmRvci9jb3JlL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuICovXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiAoMCwgX2h5cGhlbmF0ZS5kZWZhdWx0KShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2RlZmF1bHQgPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2luRE9NID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbkRPTVwiKSk7XG5cbnZhciB2ZW5kb3JzID0gWycnLCAnd2Via2l0JywgJ21veicsICdvJywgJ21zJ107XG52YXIgY2FuY2VsID0gJ2NsZWFyVGltZW91dCc7XG52YXIgcmFmID0gZmFsbGJhY2s7XG52YXIgY29tcGF0UmFmO1xuXG52YXIgZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5KHZlbmRvciwgaykge1xuICByZXR1cm4gdmVuZG9yICsgKCF2ZW5kb3IgPyBrIDoga1swXS50b1VwcGVyQ2FzZSgpICsgay5zdWJzdHIoMSkpICsgJ0FuaW1hdGlvbkZyYW1lJztcbn07XG5cbmlmIChfaW5ET00uZGVmYXVsdCkge1xuICB2ZW5kb3JzLnNvbWUoZnVuY3Rpb24gKHZlbmRvcikge1xuICAgIHZhciByYWZLZXkgPSBnZXRLZXkodmVuZG9yLCAncmVxdWVzdCcpO1xuXG4gICAgaWYgKHJhZktleSBpbiB3aW5kb3cpIHtcbiAgICAgIGNhbmNlbCA9IGdldEtleSh2ZW5kb3IsICdjYW5jZWwnKTtcbiAgICAgIHJldHVybiByYWYgPSBmdW5jdGlvbiByYWYoY2IpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvd1tyYWZLZXldKGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbi8qIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvcmFmICovXG5cblxudmFyIHByZXYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgdmFyIGN1cnIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgIG1zID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyciAtIHByZXYpKSxcbiAgICAgIHJlcSA9IHNldFRpbWVvdXQoZm4sIG1zKTtcbiAgcHJldiA9IGN1cnI7XG4gIHJldHVybiByZXE7XG59XG5cbmNvbXBhdFJhZiA9IGZ1bmN0aW9uIGNvbXBhdFJhZihjYikge1xuICByZXR1cm4gcmFmKGNiKTtcbn07XG5cbmNvbXBhdFJhZi5jYW5jZWwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgd2luZG93W2NhbmNlbF0gJiYgdHlwZW9mIHdpbmRvd1tjYW5jZWxdID09PSAnZnVuY3Rpb24nICYmIHdpbmRvd1tjYW5jZWxdKGlkKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGNvbXBhdFJhZjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBzY3JvbGxiYXJTaXplO1xuXG52YXIgX2luRE9NID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbkRPTVwiKSk7XG5cbnZhciBzaXplO1xuXG5mdW5jdGlvbiBzY3JvbGxiYXJTaXplKHJlY2FsYykge1xuICBpZiAoIXNpemUgJiYgc2l6ZSAhPT0gMCB8fCByZWNhbGMpIHtcbiAgICBpZiAoX2luRE9NLmRlZmF1bHQpIHtcbiAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcm9sbERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzY3JvbGxEaXYuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgICAgc2Nyb2xsRGl2LnN0eWxlLndpZHRoID0gJzUwcHgnO1xuICAgICAgc2Nyb2xsRGl2LnN0eWxlLmhlaWdodCA9ICc1MHB4JztcbiAgICAgIHNjcm9sbERpdi5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgc2l6ZSA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc01hcCA9IHJlcXVpcmUoJy4vaXNNYXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1NldCA9IHJlcXVpcmUoJy4vaXNTZXQnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBiYXNlU29ydEJ5ID0gcmVxdWlyZSgnLi9fYmFzZVNvcnRCeScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNvbXBhcmVNdWx0aXBsZSA9IHJlcXVpcmUoJy4vX2NvbXBhcmVNdWx0aXBsZScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlT3JkZXJCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0Qnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFzY2VuZGluZztcbiIsInZhciBjb21wYXJlQXNjZW5kaW5nID0gcmVxdWlyZSgnLi9fY29tcGFyZUFzY2VuZGluZycpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVNdWx0aXBsZTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBiYXNlUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlUmFuZ2UnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSYW5nZTtcbiIsInZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICovXG5mdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3VzdG9tT21pdENsb25lO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAqIGVsZW1lbnRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICpcbiAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gKi9cbmZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICBzaXplID0gMTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNodW5rO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgbGVuZ3RoID0gMTtcbiAgfVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKSxcbiAgICBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjdXN0b21PbWl0Q2xvbmUgPSByZXF1aXJlKCcuL19jdXN0b21PbWl0Q2xvbmUnKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgIHJldHVybiBwYXRoO1xuICB9KTtcbiAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGNyZWF0ZVJhbmdlID0gcmVxdWlyZSgnLi9fY3JlYXRlUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlT3JkZXJCeSA9IHJlcXVpcmUoJy4vX2Jhc2VPcmRlckJ5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9LCBbXSk7XG4gKiAvLyA9PiBbNCwgOV1cbiAqXG4gKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICB9XG4gIH1cbiAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm07XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsIGNsb25lRWxlbWVudCBhcyBwcmVhY3RDbG9uZUVsZW1lbnQsIGgsIENvbXBvbmVudCBhcyBQcmVhY3RDb21wb25lbnQsIG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCB2ZXJzaW9uID0gJzE1LjEuMCc7IC8vIHRyaWNrIGxpYnJhcmllcyB0byB0aGluayB3ZSBhcmUgcmVhY3RcblxuY29uc3QgRUxFTUVOVFMgPSAnYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gZGlhbG9nIGRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkIGhlYWRlciBoZ3JvdXAgaHIgaHRtbCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCBrZXlnZW4gbGFiZWwgbGVnZW5kIGxpIGxpbmsgbWFpbiBtYXAgbWFyayBtZW51IG1lbnVpdGVtIG1ldGEgbWV0ZXIgbmF2IG5vc2NyaXB0IG9iamVjdCBvbCBvcHRncm91cCBvcHRpb24gb3V0cHV0IHAgcGFyYW0gcGljdHVyZSBwcmUgcHJvZ3Jlc3MgcSBycCBydCBydWJ5IHMgc2FtcCBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc21hbGwgc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aCB0aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiciBjaXJjbGUgY2xpcFBhdGggZGVmcyBlbGxpcHNlIGcgaW1hZ2UgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lIHJhZGlhbEdyYWRpZW50IHJlY3Qgc3RvcCBzdmcgdGV4dCB0c3Bhbicuc3BsaXQoJyAnKTtcblxuY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2whPT0ndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHwgMHhlYWM3O1xuXG5jb25zdCBDT01QT05FTlRfV1JBUFBFUl9LRVkgPSAodHlwZW9mIFN5bWJvbCE9PSd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IpID8gU3ltYm9sLmZvcignX19wcmVhY3RDb21wYXRXcmFwcGVyJykgOiAnX19wcmVhY3RDb21wYXRXcmFwcGVyJztcblxuLy8gZG9uJ3QgYXV0b2JpbmQgdGhlc2UgbWV0aG9kcyBzaW5jZSB0aGV5IGFscmVhZHkgaGF2ZSBndWFyYW50ZWVkIGNvbnRleHQuXG5jb25zdCBBVVRPQklORF9CTEFDS0xJU1QgPSB7XG5cdGNvbnN0cnVjdG9yOiAxLFxuXHRyZW5kZXI6IDEsXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZTogMSxcblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogMSxcblx0Y29tcG9uZW50V2lsbFVwZGF0ZTogMSxcblx0Y29tcG9uZW50RGlkVXBkYXRlOiAxLFxuXHRjb21wb25lbnRXaWxsTW91bnQ6IDEsXG5cdGNvbXBvbmVudERpZE1vdW50OiAxLFxuXHRjb21wb25lbnRXaWxsVW5tb3VudDogMSxcblx0Y29tcG9uZW50RGlkVW5tb3VudDogMVxufTtcblxuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXB8Y29sb3J8ZmlsbHxmbG9vZHxmb250fGdseXBofGhvcml6fG1hcmtlcnxvdmVybGluZXxwYWludHxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHR8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eClbQS1aXS87XG5cblxuY29uc3QgQllQQVNTX0hPT0sgPSB7fTtcblxuLypnbG9iYWwgcHJvY2VzcyovXG5sZXQgREVWID0gZmFsc2U7XG50cnkge1xuXHRERVYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJztcbn1cbmNhdGNoIChlKSB7fVxuXG4vLyBhIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgbm90aGluZy4gVXNlZCB0byByZXBsYWNlIGNvbXBvbmVudHMgZm9yIHVubW91bnRDb21wb25lbnRBdE5vZGUuXG5mdW5jdGlvbiBFbXB0eUNvbXBvbmVudCgpIHsgcmV0dXJuIG51bGw7IH1cblxuXG5cbi8vIG1ha2UgcmVhY3QgdGhpbmsgd2UncmUgcmVhY3QuXG5sZXQgVk5vZGUgPSBoKCdhJywgbnVsbCkuY29uc3RydWN0b3I7XG5WTm9kZS5wcm90b3R5cGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5WTm9kZS5wcm90b3R5cGUucHJlYWN0Q29tcGF0VXBncmFkZWQgPSBmYWxzZTtcblZOb2RlLnByb3RvdHlwZS5wcmVhY3RDb21wYXROb3JtYWxpemVkID0gZmFsc2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsICd0eXBlJywge1xuXHRnZXQoKSB7IHJldHVybiB0aGlzLm5vZGVOYW1lOyB9LFxuXHRzZXQodikgeyB0aGlzLm5vZGVOYW1lID0gdjsgfSxcblx0Y29uZmlndXJhYmxlOnRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVk5vZGUucHJvdG90eXBlLCAncHJvcHMnLCB7XG5cdGdldCgpIHsgcmV0dXJuIHRoaXMuYXR0cmlidXRlczsgfSxcblx0c2V0KHYpIHsgdGhpcy5hdHRyaWJ1dGVzID0gdjsgfSxcblx0Y29uZmlndXJhYmxlOnRydWVcbn0pO1xuXG5cblxubGV0IG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZSA9PiB7XG5cdGlmIChvbGRFdmVudEhvb2spIGUgPSBvbGRFdmVudEhvb2soZSk7XG5cdGUucGVyc2lzdCA9IE9iamVjdDtcblx0ZS5uYXRpdmVFdmVudCA9IGU7XG5cdHJldHVybiBlO1xufTtcblxuXG5sZXQgb2xkVm5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGlmICghdm5vZGUucHJlYWN0Q29tcGF0VXBncmFkZWQpIHtcblx0XHR2bm9kZS5wcmVhY3RDb21wYXRVcGdyYWRlZCA9IHRydWU7XG5cblx0XHRsZXQgdGFnID0gdm5vZGUubm9kZU5hbWUsXG5cdFx0XHRhdHRycyA9IHZub2RlLmF0dHJpYnV0ZXMgPSB2bm9kZS5hdHRyaWJ1dGVzPT1udWxsID8ge30gOiBleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpO1xuXG5cdFx0aWYgKHR5cGVvZiB0YWc9PT0nZnVuY3Rpb24nKSB7XG5cdFx0XHRpZiAodGFnW0NPTVBPTkVOVF9XUkFQUEVSX0tFWV09PT10cnVlIHx8ICh0YWcucHJvdG90eXBlICYmICdpc1JlYWN0Q29tcG9uZW50JyBpbiB0YWcucHJvdG90eXBlKSkge1xuXHRcdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gJiYgU3RyaW5nKHZub2RlLmNoaWxkcmVuKT09PScnKSB2bm9kZS5jaGlsZHJlbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuKSBhdHRycy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGlmICghdm5vZGUucHJlYWN0Q29tcGF0Tm9ybWFsaXplZCkge1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZOb2RlKHZub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYW5kbGVDb21wb25lbnRWTm9kZSh2bm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICYmIFN0cmluZyh2bm9kZS5jaGlsZHJlbik9PT0nJykgdm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4pIGF0dHJzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0XHRcdGlmIChhdHRycy5kZWZhdWx0VmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhdHRycy52YWx1ZSAmJiBhdHRycy52YWx1ZSE9PTApIHtcblx0XHRcdFx0XHRhdHRycy52YWx1ZSA9IGF0dHJzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgYXR0cnMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVFbGVtZW50Vk5vZGUodm5vZGUsIGF0dHJzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAob2xkVm5vZGVIb29rKSBvbGRWbm9kZUhvb2sodm5vZGUpO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlQ29tcG9uZW50Vk5vZGUodm5vZGUpIHtcblx0bGV0IHRhZyA9IHZub2RlLm5vZGVOYW1lLFxuXHRcdGEgPSB2bm9kZS5hdHRyaWJ1dGVzO1xuXG5cdHZub2RlLmF0dHJpYnV0ZXMgPSB7fTtcblx0aWYgKHRhZy5kZWZhdWx0UHJvcHMpIGV4dGVuZCh2bm9kZS5hdHRyaWJ1dGVzLCB0YWcuZGVmYXVsdFByb3BzKTtcblx0aWYgKGEpIGV4dGVuZCh2bm9kZS5hdHRyaWJ1dGVzLCBhKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudFZOb2RlKHZub2RlLCBhKSB7XG5cdGxldCBzaG91bGRTYW5pdGl6ZSwgYXR0cnMsIGk7XG5cdGlmIChhKSB7XG5cdFx0Zm9yIChpIGluIGEpIGlmICgoc2hvdWxkU2FuaXRpemUgPSBDQU1FTF9QUk9QUy50ZXN0KGkpKSkgYnJlYWs7XG5cdFx0aWYgKHNob3VsZFNhbml0aXplKSB7XG5cdFx0XHRhdHRycyA9IHZub2RlLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdGZvciAoaSBpbiBhKSB7XG5cdFx0XHRcdGlmIChhLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0YXR0cnNbIENBTUVMX1BST1BTLnRlc3QoaSkgPyBpLnJlcGxhY2UoLyhbQS1aMC05XSkvLCAnLSQxJykudG9Mb3dlckNhc2UoKSA6IGkgXSA9IGFbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG5cbi8vIHByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdGxldCBwcmV2ID0gcGFyZW50ICYmIHBhcmVudC5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgJiYgcGFyZW50Ll9wcmVhY3RDb21wYXRSZW5kZXJlZC5iYXNlO1xuXG5cdC8vIGlnbm9yZSBpbXBvc3NpYmxlIHByZXZpb3VzIHJlbmRlcnNcblx0aWYgKHByZXYgJiYgcHJldi5wYXJlbnROb2RlIT09cGFyZW50KSBwcmV2ID0gbnVsbDtcblxuXHQvLyBkZWZhdWx0IHRvIGZpcnN0IEVsZW1lbnQgY2hpbGRcblx0aWYgKCFwcmV2ICYmIHBhcmVudCkgcHJldiA9IHBhcmVudC5maXJzdEVsZW1lbnRDaGlsZDtcblxuXHQvLyByZW1vdmUgdW5hZmZlY3RlZCBzaWJsaW5nc1xuXHRmb3IgKGxldCBpPXBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0hPT1wcmV2KSB7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmNoaWxkTm9kZXNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdGxldCBvdXQgPSBwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCwgcHJldik7XG5cdGlmIChwYXJlbnQpIHBhcmVudC5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgPSBvdXQgJiYgKG91dC5fY29tcG9uZW50IHx8IHsgYmFzZTogb3V0IH0pO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblx0cmV0dXJuIG91dCAmJiBvdXQuX2NvbXBvbmVudCB8fCBvdXQ7XG59XG5cblxuY2xhc3MgQ29udGV4dFByb3ZpZGVyIHtcblx0Z2V0Q2hpbGRDb250ZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLnByb3BzLmNvbnRleHQ7XG5cdH1cblx0cmVuZGVyKHByb3BzKSB7XG5cdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgdm5vZGUsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcblx0bGV0IHdyYXAgPSBoKENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBwYXJlbnRDb21wb25lbnQuY29udGV4dCB9LCB2bm9kZSk7XG5cdGxldCByZW5kZXJDb250YWluZXIgPSByZW5kZXIod3JhcCwgY29udGFpbmVyKTtcblx0bGV0IGNvbXBvbmVudCA9IHJlbmRlckNvbnRhaW5lci5fY29tcG9uZW50IHx8IHJlbmRlckNvbnRhaW5lci5iYXNlO1xuXHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50LCByZW5kZXJDb250YWluZXIpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0cmVuZGVyU3VidHJlZUludG9Db250YWluZXIodGhpcywgcHJvcHMudm5vZGUsIHByb3BzLmNvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdHJldHVybiBoKFBvcnRhbCwgeyB2bm9kZSwgY29udGFpbmVyIH0pO1xufVxuXG5cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdGxldCBleGlzdGluZyA9IGNvbnRhaW5lci5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgJiYgY29udGFpbmVyLl9wcmVhY3RDb21wYXRSZW5kZXJlZC5iYXNlO1xuXHRpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcucGFyZW50Tm9kZT09PWNvbnRhaW5lcikge1xuXHRcdHByZWFjdFJlbmRlcihoKEVtcHR5Q29tcG9uZW50KSwgY29udGFpbmVyLCBleGlzdGluZyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cblxuY29uc3QgQVJSID0gW107XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5sZXQgQ2hpbGRyZW4gPSB7XG5cdG1hcChjaGlsZHJlbiwgZm4sIGN0eCkge1xuXHRcdGlmIChjaGlsZHJlbiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRjaGlsZHJlbiA9IENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChjdHggJiYgY3R4IT09Y2hpbGRyZW4pIGZuID0gZm4uYmluZChjdHgpO1xuXHRcdHJldHVybiBjaGlsZHJlbi5tYXAoZm4pO1xuXHR9LFxuXHRmb3JFYWNoKGNoaWxkcmVuLCBmbiwgY3R4KSB7XG5cdFx0aWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBudWxsO1xuXHRcdGNoaWxkcmVuID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKGN0eCAmJiBjdHghPT1jaGlsZHJlbikgZm4gPSBmbi5iaW5kKGN0eCk7XG5cdFx0Y2hpbGRyZW4uZm9yRWFjaChmbik7XG5cdH0sXG5cdGNvdW50KGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCB8fCAwO1xuXHR9LFxuXHRvbmx5KGNoaWxkcmVuKSB7XG5cdFx0Y2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoIT09MSkgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5vbmx5KCkgZXhwZWN0cyBvbmx5IG9uZSBjaGlsZC4nKTtcblx0XHRyZXR1cm4gY2hpbGRyZW5bMF07XG5cdH0sXG5cdHRvQXJyYXkoY2hpbGRyZW4pIHtcblx0XHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIFtdO1xuXHRcdHJldHVybiBBUlIuY29uY2F0KGNoaWxkcmVuKTtcblx0fVxufTtcblxuXG4vKiogVHJhY2sgY3VycmVudCByZW5kZXIoKSBjb21wb25lbnQgZm9yIHJlZiBhc3NpZ25tZW50ICovXG5sZXQgY3VycmVudENvbXBvbmVudDtcblxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuXG5sZXQgRE9NID0ge307XG5mb3IgKGxldCBpPUVMRU1FTlRTLmxlbmd0aDsgaS0tOyApIHtcblx0RE9NW0VMRU1FTlRTW2ldXSA9IGNyZWF0ZUZhY3RvcnkoRUxFTUVOVFNbaV0pO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlVG9WTm9kZXMoYXJyLCBvZmZzZXQpIHtcblx0Zm9yIChsZXQgaT1vZmZzZXQgfHwgMDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgb2JqID0gYXJyW2ldO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHVwZ3JhZGVUb1ZOb2RlcyhvYmopO1xuXHRcdH1cblx0XHRlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaj09PSdvYmplY3QnICYmICFpc1ZhbGlkRWxlbWVudChvYmopICYmICgob2JqLnByb3BzICYmIG9iai50eXBlKSB8fCAob2JqLmF0dHJpYnV0ZXMgJiYgb2JqLm5vZGVOYW1lKSB8fCBvYmouY2hpbGRyZW4pKSB7XG5cdFx0XHRhcnJbaV0gPSBjcmVhdGVFbGVtZW50KG9iai50eXBlIHx8IG9iai5ub2RlTmFtZSwgb2JqLnByb3BzIHx8IG9iai5hdHRyaWJ1dGVzLCBvYmouY2hpbGRyZW4pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc1N0YXRlbGVzc0NvbXBvbmVudChjKSB7XG5cdHJldHVybiB0eXBlb2YgYz09PSdmdW5jdGlvbicgJiYgIShjLnByb3RvdHlwZSAmJiBjLnByb3RvdHlwZS5yZW5kZXIpO1xufVxuXG5cbi8vIHdyYXBzIHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYSBQcm9wVHlwZXMgdmFsaWRhdG9yXG5mdW5jdGlvbiB3cmFwU3RhdGVsZXNzQ29tcG9uZW50KFdyYXBwZWRDb21wb25lbnQpIHtcblx0cmV0dXJuIGNyZWF0ZUNsYXNzKHtcblx0XHRkaXNwbGF5TmFtZTogV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUsXG5cdFx0cmVuZGVyKCkge1xuXHRcdFx0cmV0dXJuIFdyYXBwZWRDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0KTtcblx0XHR9XG5cdH0pO1xufVxuXG5cbmZ1bmN0aW9uIHN0YXRlbGVzc0NvbXBvbmVudEhvb2soQ3Rvcikge1xuXHRsZXQgV3JhcHBlZCA9IEN0b3JbQ09NUE9ORU5UX1dSQVBQRVJfS0VZXTtcblx0aWYgKFdyYXBwZWQpIHJldHVybiBXcmFwcGVkPT09dHJ1ZSA/IEN0b3IgOiBXcmFwcGVkO1xuXG5cdFdyYXBwZWQgPSB3cmFwU3RhdGVsZXNzQ29tcG9uZW50KEN0b3IpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkLCBDT01QT05FTlRfV1JBUFBFUl9LRVksIHsgY29uZmlndXJhYmxlOnRydWUsIHZhbHVlOnRydWUgfSk7XG5cdFdyYXBwZWQuZGlzcGxheU5hbWUgPSBDdG9yLmRpc3BsYXlOYW1lO1xuXHRXcmFwcGVkLnByb3BUeXBlcyA9IEN0b3IucHJvcFR5cGVzO1xuXHRXcmFwcGVkLmRlZmF1bHRQcm9wcyA9IEN0b3IuZGVmYXVsdFByb3BzO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdG9yLCBDT01QT05FTlRfV1JBUFBFUl9LRVksIHsgY29uZmlndXJhYmxlOnRydWUsIHZhbHVlOldyYXBwZWQgfSk7XG5cblx0cmV0dXJuIFdyYXBwZWQ7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCguLi5hcmdzKSB7XG5cdHVwZ3JhZGVUb1ZOb2RlcyhhcmdzLCAyKTtcblx0cmV0dXJuIG5vcm1hbGl6ZVZOb2RlKGgoLi4uYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKHZub2RlKSB7XG5cdHZub2RlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQgPSB0cnVlO1xuXG5cdGFwcGx5Q2xhc3NOYW1lKHZub2RlKTtcblxuXHRpZiAoaXNTdGF0ZWxlc3NDb21wb25lbnQodm5vZGUubm9kZU5hbWUpKSB7XG5cdFx0dm5vZGUubm9kZU5hbWUgPSBzdGF0ZWxlc3NDb21wb25lbnRIb29rKHZub2RlLm5vZGVOYW1lKTtcblx0fVxuXG5cdGxldCByZWYgPSB2bm9kZS5hdHRyaWJ1dGVzLnJlZixcblx0XHR0eXBlID0gcmVmICYmIHR5cGVvZiByZWY7XG5cdGlmIChjdXJyZW50Q29tcG9uZW50ICYmICh0eXBlPT09J3N0cmluZycgfHwgdHlwZT09PSdudW1iZXInKSkge1xuXHRcdHZub2RlLmF0dHJpYnV0ZXMucmVmID0gY3JlYXRlU3RyaW5nUmVmUHJveHkocmVmLCBjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXG5cdGFwcGx5RXZlbnROb3JtYWxpemF0aW9uKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHByb3BzLCAuLi5jaGlsZHJlbikge1xuXHRpZiAoIWlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSByZXR1cm4gZWxlbWVudDtcblx0bGV0IGVsZW1lbnRQcm9wcyA9IGVsZW1lbnQuYXR0cmlidXRlcyB8fCBlbGVtZW50LnByb3BzO1xuXHRsZXQgbm9kZSA9IGgoXG5cdFx0ZWxlbWVudC5ub2RlTmFtZSB8fCBlbGVtZW50LnR5cGUsXG5cdFx0ZXh0ZW5kKHt9LCBlbGVtZW50UHJvcHMpLFxuXHRcdGVsZW1lbnQuY2hpbGRyZW4gfHwgZWxlbWVudFByb3BzICYmIGVsZW1lbnRQcm9wcy5jaGlsZHJlblxuXHQpO1xuXHQvLyBPbmx5IHByb3ZpZGUgdGhlIDNyZCBhcmd1bWVudCBpZiBuZWVkZWQuXG5cdC8vIEFyZ3VtZW50cyAzKyBvdmVyd3JpdGUgZWxlbWVudC5jaGlsZHJlbiBpbiBwcmVhY3RDbG9uZUVsZW1lbnRcblx0bGV0IGNsb25lQXJncyA9IFtub2RlLCBwcm9wc107XG5cdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRjbG9uZUFyZ3MucHVzaChjaGlsZHJlbik7XG5cdH1cblx0ZWxzZSBpZiAocHJvcHMgJiYgcHJvcHMuY2hpbGRyZW4pIHtcblx0XHRjbG9uZUFyZ3MucHVzaChwcm9wcy5jaGlsZHJlbik7XG5cdH1cblx0cmV0dXJuIG5vcm1hbGl6ZVZOb2RlKHByZWFjdENsb25lRWxlbWVudCguLi5jbG9uZUFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChlbGVtZW50KSB7XG5cdHJldHVybiBlbGVtZW50ICYmICgoZWxlbWVudCBpbnN0YW5jZW9mIFZOb2RlKSB8fCBlbGVtZW50LiQkdHlwZW9mPT09UkVBQ1RfRUxFTUVOVF9UWVBFKTtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdSZWZQcm94eShuYW1lLCBjb21wb25lbnQpIHtcblx0cmV0dXJuIGNvbXBvbmVudC5fcmVmUHJveGllc1tuYW1lXSB8fCAoY29tcG9uZW50Ll9yZWZQcm94aWVzW25hbWVdID0gcmVzb2x2ZWQgPT4ge1xuXHRcdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnJlZnMpIHtcblx0XHRcdGNvbXBvbmVudC5yZWZzW25hbWVdID0gcmVzb2x2ZWQ7XG5cdFx0XHRpZiAocmVzb2x2ZWQ9PT1udWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSBjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV07XG5cdFx0XHRcdGNvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBhcHBseUV2ZW50Tm9ybWFsaXphdGlvbih7IG5vZGVOYW1lLCBhdHRyaWJ1dGVzIH0pIHtcblx0aWYgKCFhdHRyaWJ1dGVzIHx8IHR5cGVvZiBub2RlTmFtZSE9PSdzdHJpbmcnKSByZXR1cm47XG5cdGxldCBwcm9wcyA9IHt9O1xuXHRmb3IgKGxldCBpIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRwcm9wc1tpLnRvTG93ZXJDYXNlKCldID0gaTtcblx0fVxuXHRpZiAocHJvcHMub25kb3VibGVjbGljaykge1xuXHRcdGF0dHJpYnV0ZXMub25kYmxjbGljayA9IGF0dHJpYnV0ZXNbcHJvcHMub25kb3VibGVjbGlja107XG5cdFx0ZGVsZXRlIGF0dHJpYnV0ZXNbcHJvcHMub25kb3VibGVjbGlja107XG5cdH1cblx0Ly8gZm9yICp0ZXh0dWFsIGlucHV0cyogKGluY2wgdGV4dGFyZWEpLCBub3JtYWxpemUgYG9uQ2hhbmdlYCAtPiBgb25JbnB1dGA6XG5cdGlmIChwcm9wcy5vbmNoYW5nZSAmJiAobm9kZU5hbWU9PT0ndGV4dGFyZWEnIHx8IChub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09J2lucHV0JyAmJiAhL15maWx8Y2hlfHJhZC9pLnRlc3QoYXR0cmlidXRlcy50eXBlKSkpKSB7XG5cdFx0bGV0IG5vcm1hbGl6ZWQgPSBwcm9wcy5vbmlucHV0IHx8ICdvbmlucHV0Jztcblx0XHRpZiAoIWF0dHJpYnV0ZXNbbm9ybWFsaXplZF0pIHtcblx0XHRcdGF0dHJpYnV0ZXNbbm9ybWFsaXplZF0gPSBtdWx0aWhvb2soW2F0dHJpYnV0ZXNbbm9ybWFsaXplZF0sIGF0dHJpYnV0ZXNbcHJvcHMub25jaGFuZ2VdXSk7XG5cdFx0XHRkZWxldGUgYXR0cmlidXRlc1twcm9wcy5vbmNoYW5nZV07XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gYXBwbHlDbGFzc05hbWUodm5vZGUpIHtcblx0bGV0IGEgPSB2bm9kZS5hdHRyaWJ1dGVzIHx8ICh2bm9kZS5hdHRyaWJ1dGVzID0ge30pO1xuXHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBhO1xuXHRpZiAoYS5jbGFzc05hbWUpIGEuY2xhc3MgPSBhLmNsYXNzTmFtZTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcbn1cblxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7IHJldHVybiB0aGlzLmNsYXNzOyB9LFxuXHRzZXQodikgeyB0aGlzLmNsYXNzID0gdjsgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKGJhc2UsIHByb3BzKSB7XG5cdGZvciAobGV0IGk9MSwgb2JqOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICgob2JqID0gYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iaikge1xuXHRcdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRiYXNlW2tleV0gPSBvYmpba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gYmFzZTtcbn1cblxuXG5mdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGFbaV0hPT1iW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIChjb21wb25lbnQuYmFzZSB8fCBjb21wb25lbnQubm9kZVR5cGUgPT09IDEgJiYgY29tcG9uZW50KSB8fCBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIEYoKXt9XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG9iaikge1xuXHRmdW5jdGlvbiBjbChwcm9wcywgY29udGV4dCkge1xuXHRcdGJpbmRBbGwodGhpcyk7XG5cdFx0Q29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQsIEJZUEFTU19IT09LKTtcblx0XHRuZXdDb21wb25lbnRIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR9XG5cblx0b2JqID0gZXh0ZW5kKHsgY29uc3RydWN0b3I6IGNsIH0sIG9iaik7XG5cblx0Ly8gV2UgbmVlZCB0byBhcHBseSBtaXhpbnMgaGVyZSBzbyB0aGF0IGdldERlZmF1bHRQcm9wcyBpcyBjb3JyZWN0bHkgbWl4ZWRcblx0aWYgKG9iai5taXhpbnMpIHtcblx0XHRhcHBseU1peGlucyhvYmosIGNvbGxhdGVNaXhpbnMob2JqLm1peGlucykpO1xuXHR9XG5cdGlmIChvYmouc3RhdGljcykge1xuXHRcdGV4dGVuZChjbCwgb2JqLnN0YXRpY3MpO1xuXHR9XG5cdGlmIChvYmoucHJvcFR5cGVzKSB7XG5cdFx0Y2wucHJvcFR5cGVzID0gb2JqLnByb3BUeXBlcztcblx0fVxuXHRpZiAob2JqLmRlZmF1bHRQcm9wcykge1xuXHRcdGNsLmRlZmF1bHRQcm9wcyA9IG9iai5kZWZhdWx0UHJvcHM7XG5cdH1cblx0aWYgKG9iai5nZXREZWZhdWx0UHJvcHMpIHtcblx0XHRjbC5kZWZhdWx0UHJvcHMgPSBvYmouZ2V0RGVmYXVsdFByb3BzLmNhbGwoY2wpO1xuXHR9XG5cblx0Ri5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuXHRjbC5wcm90b3R5cGUgPSBleHRlbmQobmV3IEYoKSwgb2JqKTtcblxuXHRjbC5kaXNwbGF5TmFtZSA9IG9iai5kaXNwbGF5TmFtZSB8fCAnQ29tcG9uZW50JztcblxuXHRyZXR1cm4gY2w7XG59XG5cblxuLy8gRmxhdHRlbiBhbiBBcnJheSBvZiBtaXhpbnMgdG8gYSBtYXAgb2YgbWV0aG9kIG5hbWUgdG8gbWl4aW4gaW1wbGVtZW50YXRpb25zXG5mdW5jdGlvbiBjb2xsYXRlTWl4aW5zKG1peGlucykge1xuXHRsZXQga2V5ZWQgPSB7fTtcblx0Zm9yIChsZXQgaT0wOyBpPG1peGlucy5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBtaXhpbiA9IG1peGluc1tpXTtcblx0XHRmb3IgKGxldCBrZXkgaW4gbWl4aW4pIHtcblx0XHRcdGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBtaXhpbltrZXldPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHQoa2V5ZWRba2V5XSB8fCAoa2V5ZWRba2V5XT1bXSkpLnB1c2gobWl4aW5ba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBrZXllZDtcbn1cblxuXG4vLyBhcHBseSBhIG1hcHBpbmcgb2YgQXJyYXlzIG9mIG1peGluIG1ldGhvZHMgdG8gYSBjb21wb25lbnQgcHJvdG90eXBlXG5mdW5jdGlvbiBhcHBseU1peGlucyhwcm90bywgbWl4aW5zKSB7XG5cdGZvciAobGV0IGtleSBpbiBtaXhpbnMpIGlmIChtaXhpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHByb3RvW2tleV0gPSBtdWx0aWhvb2soXG5cdFx0XHRtaXhpbnNba2V5XS5jb25jYXQocHJvdG9ba2V5XSB8fCBBUlIpLFxuXHRcdFx0a2V5PT09J2dldERlZmF1bHRQcm9wcycgfHwga2V5PT09J2dldEluaXRpYWxTdGF0ZScgfHwga2V5PT09J2dldENoaWxkQ29udGV4dCdcblx0XHQpO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gYmluZEFsbChjdHgpIHtcblx0Zm9yIChsZXQgaSBpbiBjdHgpIHtcblx0XHRsZXQgdiA9IGN0eFtpXTtcblx0XHRpZiAodHlwZW9mIHY9PT0nZnVuY3Rpb24nICYmICF2Ll9fYm91bmQgJiYgIUFVVE9CSU5EX0JMQUNLTElTVC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0KGN0eFtpXSA9IHYuYmluZChjdHgpKS5fX2JvdW5kID0gdHJ1ZTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBjYWxsTWV0aG9kKGN0eCwgbSwgYXJncykge1xuXHRpZiAodHlwZW9mIG09PT0nc3RyaW5nJykge1xuXHRcdG0gPSBjdHguY29uc3RydWN0b3IucHJvdG90eXBlW21dO1xuXHR9XG5cdGlmICh0eXBlb2YgbT09PSdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gbS5hcHBseShjdHgsIGFyZ3MpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG11bHRpaG9vayhob29rcywgc2tpcER1cGxpY2F0ZXMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGxldCByZXQ7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGhvb2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgciA9IGNhbGxNZXRob2QodGhpcywgaG9va3NbaV0sIGFyZ3VtZW50cyk7XG5cblx0XHRcdGlmIChza2lwRHVwbGljYXRlcyAmJiByIT1udWxsKSB7XG5cdFx0XHRcdGlmICghcmV0KSByZXQgPSB7fTtcblx0XHRcdFx0Zm9yIChsZXQga2V5IGluIHIpIGlmIChyLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRyZXRba2V5XSA9IHJba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIHIhPT0ndW5kZWZpbmVkJykgcmV0ID0gcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuXG5mdW5jdGlvbiBuZXdDb21wb25lbnRIb29rKHByb3BzLCBjb250ZXh0KSB7XG5cdHByb3BzSG9vay5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcblx0dGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gbXVsdGlob29rKFtwcm9wc0hvb2ssIHRoaXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB8fCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyddKTtcblx0dGhpcy5yZW5kZXIgPSBtdWx0aWhvb2soW3Byb3BzSG9vaywgYmVmb3JlUmVuZGVyLCB0aGlzLnJlbmRlciB8fCAncmVuZGVyJywgYWZ0ZXJSZW5kZXJdKTtcbn1cblxuXG5mdW5jdGlvbiBwcm9wc0hvb2socHJvcHMsIGNvbnRleHQpIHtcblx0aWYgKCFwcm9wcykgcmV0dXJuO1xuXG5cdC8vIFJlYWN0IGFubm95aW5nbHkgc3BlY2lhbC1jYXNlcyBzaW5nbGUgY2hpbGRyZW4sIGFuZCBzb21lIHJlYWN0IGNvbXBvbmVudHMgYXJlIHJpZGljdWxvdXNseSBzdHJpY3QgYWJvdXQgdGhpcy5cblx0bGV0IGMgPSBwcm9wcy5jaGlsZHJlbjtcblx0aWYgKGMgJiYgQXJyYXkuaXNBcnJheShjKSAmJiBjLmxlbmd0aD09PTEgJiYgKHR5cGVvZiBjWzBdPT09J3N0cmluZycgfHwgdHlwZW9mIGNbMF09PT0nZnVuY3Rpb24nIHx8IGNbMF0gaW5zdGFuY2VvZiBWTm9kZSkpIHtcblx0XHRwcm9wcy5jaGlsZHJlbiA9IGNbMF07XG5cblx0XHQvLyBidXQgaXRzIHRvdGFsbHkgc3RpbGwgZ29pbmcgdG8gYmUgYW4gQXJyYXkuXG5cdFx0aWYgKHByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdvYmplY3QnKSB7XG5cdFx0XHRwcm9wcy5jaGlsZHJlbi5sZW5ndGggPSAxO1xuXHRcdFx0cHJvcHMuY2hpbGRyZW5bMF0gPSBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgcHJvcHR5cGUgY2hlY2tpbmdcblx0aWYgKERFVikge1xuXHRcdGxldCBjdG9yID0gdHlwZW9mIHRoaXM9PT0nZnVuY3Rpb24nID8gdGhpcyA6IHRoaXMuY29uc3RydWN0b3IsXG5cdFx0XHRwcm9wVHlwZXMgPSB0aGlzLnByb3BUeXBlcyB8fCBjdG9yLnByb3BUeXBlcztcblx0XHRjb25zdCBkaXNwbGF5TmFtZSA9IHRoaXMuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lO1xuXG5cdFx0aWYgKHByb3BUeXBlcykge1xuXHRcdFx0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgZGlzcGxheU5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIGJlZm9yZVJlbmRlcihwcm9wcykge1xuXHRjdXJyZW50Q29tcG9uZW50ID0gdGhpcztcbn1cblxuZnVuY3Rpb24gYWZ0ZXJSZW5kZXIoKSB7XG5cdGlmIChjdXJyZW50Q29tcG9uZW50PT09dGhpcykge1xuXHRcdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHR9XG59XG5cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIG9wdHMpIHtcblx0UHJlYWN0Q29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDoge307XG5cdHRoaXMucmVmcyA9IHt9O1xuXHR0aGlzLl9yZWZQcm94aWVzID0ge307XG5cdGlmIChvcHRzIT09QllQQVNTX0hPT0spIHtcblx0XHRuZXdDb21wb25lbnRIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR9XG59XG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBQcmVhY3RDb21wb25lbnQoKSwge1xuXHRjb25zdHJ1Y3RvcjogQ29tcG9uZW50LFxuXG5cdGlzUmVhY3RDb21wb25lbnQ6IHt9LFxuXG5cdHJlcGxhY2VTdGF0ZShzdGF0ZSwgY2FsbGJhY2spIHtcblx0XHR0aGlzLnNldFN0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0Zm9yIChsZXQgaSBpbiB0aGlzLnN0YXRlKSB7XG5cdFx0XHRpZiAoIShpIGluIHN0YXRlKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5zdGF0ZVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0RE9NTm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5iYXNlO1xuXHR9LFxuXG5cdGlzTW91bnRlZCgpIHtcblx0XHRyZXR1cm4gISF0aGlzLmJhc2U7XG5cdH1cbn0pO1xuXG5cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG59XG5GLnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuXG5mdW5jdGlvbiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaykge1xuXHRjYWxsYmFjaygpO1xufVxuXG5leHBvcnQge1xuXHR2ZXJzaW9uLFxuXHRET00sXG5cdFByb3BUeXBlcyxcblx0Q2hpbGRyZW4sXG5cdHJlbmRlcixcblx0Y3JlYXRlQ2xhc3MsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y2xvbmVFbGVtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0cmVuZGVyU3VidHJlZUludG9Db250YWluZXIgYXMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsXG5cdHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuXHRleHRlbmQgYXMgX19zcHJlYWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0dmVyc2lvbixcblx0RE9NLFxuXHRQcm9wVHlwZXMsXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGNyZWF0ZUNsYXNzLFxuXHRjcmVhdGVQb3J0YWwsXG5cdGNyZWF0ZUZhY3RvcnksXG5cdGNyZWF0ZUVsZW1lbnQsXG5cdGNsb25lRWxlbWVudCxcblx0aXNWYWxpZEVsZW1lbnQsXG5cdGZpbmRET01Ob2RlLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRDb21wb25lbnQsXG5cdFB1cmVDb21wb25lbnQsXG5cdHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcixcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdF9fc3ByZWFkOiBleHRlbmRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhbGw7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyJyk7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhbGwoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWxpZGF0b3JzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsaWRhdG9yc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbFByb3BUeXBlcygpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICB2YWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcjIuZGVmYXVsdCkoYWxsUHJvcFR5cGVzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyJyk7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcFZhbHVlKTtcblxuICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIFJlYWN0RWxlbWVudCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdENvbXBvbmVudCBvciBhICcpICsgJ0RPTUVsZW1lbnQuIFlvdSBjYW4gdXN1YWxseSBvYnRhaW4gYSBSZWFjdENvbXBvbmVudCBvciBET01FbGVtZW50ICcgKyAnZnJvbSBhIFJlYWN0RWxlbWVudCBieSBhdHRhY2hpbmcgYSByZWYgdG8gaXQuJyk7XG4gIH1cblxuICBpZiAoKHByb3BUeXBlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcHJvcFZhbHVlLnJlbmRlciAhPT0gJ2Z1bmN0aW9uJykgJiYgcHJvcFZhbHVlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdENvbXBvbmVudCBvciBhICcpICsgJ0RPTUVsZW1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcjIuZGVmYXVsdCkodmFsaWRhdGUpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyJyk7XG5cbnZhciBfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlbGVtZW50VHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIFJlYWN0RWxlbWVudCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCxleHBlY3RlZCBhbiBlbGVtZW50IHR5cGUgKGEgc3RyaW5nICcpICsgJywgY29tcG9uZW50IGNsYXNzLCBvciBmdW5jdGlvbiBjb21wb25lbnQpLicpO1xuICB9XG5cbiAgaWYgKCEoMCwgX3JlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gZWxlbWVudCB0eXBlIChhIHN0cmluZyAnKSArICcsIGNvbXBvbmVudCBjbGFzcywgb3IgZnVuY3Rpb24gY29tcG9uZW50KS4nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyMi5kZWZhdWx0KShlbGVtZW50VHlwZSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbi8vIE1vc3RseSB0YWtlbiBmcm9tIFJlYWN0UHJvcFR5cGVzLlxuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWVTYWZlID0gY29tcG9uZW50TmFtZSB8fCAnPDxhbm9ueW1vdXM+Pic7XG4gICAgdmFyIHByb3BGdWxsTmFtZVNhZmUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWVTYWZlICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lU2FmZSArICdgLicpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gNiA/IF9sZW4gLSA2IDogMCksIF9rZXkgPSA2OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSA2XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGUuYXBwbHkodW5kZWZpbmVkLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lU2FmZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZVNhZmVdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdW5jb250cm9sbGFibGUgZnJvbSAndW5jb250cm9sbGFibGUnO1xuaW1wb3J0IGNuIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGVsZW1lbnRUeXBlIGZyb20gJ3Byb3AtdHlwZXMtZXh0cmEvbGliL2VsZW1lbnRUeXBlJztcbmltcG9ydCBhbGwgZnJvbSAncHJvcC10eXBlcy1leHRyYS9saWIvYWxsJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkJztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBkYXRlTWF0aCBmcm9tICdkYXRlLWFyaXRobWV0aWMnO1xuaW1wb3J0IGNodW5rIGZyb20gJ2xvZGFzaC9jaHVuayc7XG5pbXBvcnQgZ2V0UG9zaXRpb24gZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvcG9zaXRpb24nO1xuaW1wb3J0IHJhZiBmcm9tICdkb20taGVscGVycy91dGlsL3JlcXVlc3RBbmltYXRpb25GcmFtZSc7XG5pbXBvcnQgZ2V0T2Zmc2V0IGZyb20gJ2RvbS1oZWxwZXJzL3F1ZXJ5L29mZnNldCc7XG5pbXBvcnQgZ2V0U2Nyb2xsVG9wIGZyb20gJ2RvbS1oZWxwZXJzL3F1ZXJ5L3Njcm9sbFRvcCc7XG5pbXBvcnQgZ2V0U2Nyb2xsTGVmdCBmcm9tICdkb20taGVscGVycy9xdWVyeS9zY3JvbGxMZWZ0JztcbmltcG9ydCBPdmVybGF5IGZyb20gJ3JlYWN0LW92ZXJsYXlzL2xpYi9PdmVybGF5JztcbmltcG9ydCBnZXRIZWlnaHQgZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvaGVpZ2h0JztcbmltcG9ydCBxc2EgZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvcXVlcnlTZWxlY3RvckFsbCc7XG5pbXBvcnQgY29udGFpbnMgZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvY29udGFpbnMnO1xuaW1wb3J0IGNsb3Nlc3QgZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvY2xvc2VzdCc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2RvbS1oZWxwZXJzL2V2ZW50cyc7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xuaW1wb3J0IHJhbmdlIGZyb20gJ2xvZGFzaC9yYW5nZSc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzJztcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5pbXBvcnQgZ2V0V2lkdGggZnJvbSAnZG9tLWhlbHBlcnMvcXVlcnkvd2lkdGgnO1xuaW1wb3J0IHNjcm9sbGJhclNpemUgZnJvbSAnZG9tLWhlbHBlcnMvdXRpbC9zY3JvbGxiYXJTaXplJztcbmltcG9ydCBjbGFzc2VzIGZyb20gJ2RvbS1oZWxwZXJzL2NsYXNzJztcbmltcG9ydCBvbWl0IGZyb20gJ2xvZGFzaC9vbWl0JztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICdsb2Rhc2gvZGVmYXVsdHMnO1xuaW1wb3J0IHRyYW5zZm9ybSBmcm9tICdsb2Rhc2gvdHJhbnNmb3JtJztcbmltcG9ydCBtYXBWYWx1ZXMgZnJvbSAnbG9kYXNoL21hcFZhbHVlcyc7XG5cbnZhciBuYXZpZ2F0ZSA9IHtcbiAgUFJFVklPVVM6ICdQUkVWJyxcbiAgTkVYVDogJ05FWFQnLFxuICBUT0RBWTogJ1RPREFZJyxcbiAgREFURTogJ0RBVEUnXG59O1xudmFyIHZpZXdzID0ge1xuICBNT05USDogJ21vbnRoJyxcbiAgV0VFSzogJ3dlZWsnLFxuICBXT1JLX1dFRUs6ICd3b3JrX3dlZWsnLFxuICBEQVk6ICdkYXknLFxuICBBR0VOREE6ICdhZ2VuZGEnXG59O1xuXG52YXIgZXZlbnRDb21wb25lbnQgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtlbGVtZW50VHlwZSwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgbW9udGg6IGVsZW1lbnRUeXBlLFxuICB3ZWVrOiBlbGVtZW50VHlwZSxcbiAgZGF5OiBlbGVtZW50VHlwZSxcbiAgYWdlbmRhOiBlbGVtZW50VHlwZVxufSldKTtcbnZhciB2aWV3TmFtZXMgPSBPYmplY3Qua2V5cyh2aWV3cykubWFwKGZ1bmN0aW9uIChrKSB7XG4gIHJldHVybiB2aWV3c1trXTtcbn0pO1xudmFyIGFjY2Vzc29yID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKTtcbnZhciBkYXRlRm9ybWF0ID0gUHJvcFR5cGVzLmFueTtcbnZhciBkYXRlUmFuZ2VGb3JtYXQgPSBQcm9wVHlwZXMuZnVuYztcbi8qKlxuICogYWNjZXB0cyBlaXRoZXIgYW4gYXJyYXkgb2YgYnVpbHRpbiB2aWV3IG5hbWVzOlxuICpcbiAqIGBgYFxuICogdmlld3M9e1snbW9udGgnLCAnZGF5JywgJ2FnZW5kYSddfVxuICogYGBgXG4gKlxuICogb3IgYW4gb2JqZWN0IGhhc2ggb2YgdGhlIHZpZXcgbmFtZSBhbmQgdGhlIGNvbXBvbmVudCAob3IgYm9vbGVhbiBmb3IgYnVpbHRpbilcbiAqXG4gKiBgYGBcbiAqIHZpZXdzPXt7XG4gKiAgIG1vbnRoOiB0cnVlLFxuICogICB3ZWVrOiBmYWxzZSxcbiAqICAgd29ya3dlZWs6IFdvcmtXZWVrVmlld0NvbXBvbmVudCxcbiAqIH19XG4gKiBgYGBcbiAqL1xuXG52YXIgdmlld3MkMSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZih2aWV3TmFtZXMpKSwgYWxsKFByb3BUeXBlcy5vYmplY3QsIGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgcHJvcCA9IHByb3BzW25hbWVdLFxuICAgICAgZXJyO1xuICBPYmplY3Qua2V5cyhwcm9wKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGlzQnVpbHRpblZpZXcgPSB2aWV3TmFtZXMuaW5kZXhPZihrZXkpICE9PSAtMSAmJiB0eXBlb2YgcHJvcFtrZXldID09PSAnYm9vbGVhbic7XG4gICAgcmV0dXJuIGlzQnVpbHRpblZpZXcgfHwgIShlcnIgPSBlbGVtZW50VHlwZS5hcHBseSh2b2lkIDAsIFtwcm9wLCBrZXldLmNvbmNhdChhcmdzKSkpO1xuICB9KTtcbiAgcmV0dXJuIGVyciB8fCBudWxsO1xufSldKTtcblxuZnVuY3Rpb24gbm90aWZ5KGhhbmRsZXIsIGFyZ3MpIHtcbiAgaGFuZGxlciAmJiBoYW5kbGVyLmFwcGx5KG51bGwsIFtdLmNvbmNhdChhcmdzKSk7XG59XG5cbnZhciBsb2NhbGVQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSk7XG5cbmZ1bmN0aW9uIF9mb3JtYXQobG9jYWxpemVyLCBmb3JtYXR0ZXIsIHZhbHVlLCBmb3JtYXQsIGN1bHR1cmUpIHtcbiAgdmFyIHJlc3VsdCA9IHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXQodmFsdWUsIGN1bHR1cmUsIGxvY2FsaXplcikgOiBmb3JtYXR0ZXIuY2FsbChsb2NhbGl6ZXIsIHZhbHVlLCBmb3JtYXQsIGN1bHR1cmUpO1xuICAhKHJlc3VsdCA9PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2Bsb2NhbGl6ZXIgZm9ybWF0KC4uKWAgbXVzdCByZXR1cm4gYSBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIERhdGVMb2NhbGl6ZXIgPSBmdW5jdGlvbiBEYXRlTG9jYWxpemVyKHNwZWMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAhKHR5cGVvZiBzcGVjLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdkYXRlIGxvY2FsaXplciBgZm9ybWF0KC4uKWAgbXVzdCBiZSBhIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhKHR5cGVvZiBzcGVjLmZpcnN0T2ZXZWVrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2RhdGUgbG9jYWxpemVyIGBmaXJzdE9mV2VlayguLilgIG11c3QgYmUgYSBmdW5jdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdGhpcy5wcm9wVHlwZSA9IHNwZWMucHJvcFR5cGUgfHwgbG9jYWxlUHJvcFR5cGU7XG4gIHRoaXMuc3RhcnRPZldlZWsgPSBzcGVjLmZpcnN0T2ZXZWVrO1xuICB0aGlzLmZvcm1hdHMgPSBzcGVjLmZvcm1hdHM7XG5cbiAgdGhpcy5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfZm9ybWF0LmFwcGx5KHZvaWQgMCwgW190aGlzLCBzcGVjLmZvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcbn07XG5mdW5jdGlvbiBtZXJnZVdpdGhEZWZhdWx0cyhsb2NhbGl6ZXIsIGN1bHR1cmUsIGZvcm1hdE92ZXJyaWRlcywgbWVzc2FnZXMpIHtcbiAgdmFyIGZvcm1hdHMgPSBfZXh0ZW5kcyh7fSwgbG9jYWxpemVyLmZvcm1hdHMsIGZvcm1hdE92ZXJyaWRlcyk7XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhbGl6ZXIsIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgc3RhcnRPZldlZWs6IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKCkge1xuICAgICAgcmV0dXJuIGxvY2FsaXplci5zdGFydE9mV2VlayhjdWx0dXJlKTtcbiAgICB9LFxuICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCBfZm9ybWF0Mikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplci5mb3JtYXQodmFsdWUsIGZvcm1hdHNbX2Zvcm1hdDJdIHx8IF9mb3JtYXQyLCBjdWx0dXJlKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGVmYXVsdE1lc3NhZ2VzID0ge1xuICBkYXRlOiAnRGF0ZScsXG4gIHRpbWU6ICdUaW1lJyxcbiAgZXZlbnQ6ICdFdmVudCcsXG4gIGFsbERheTogJ0FsbCBEYXknLFxuICB3ZWVrOiAnV2VlaycsXG4gIHdvcmtfd2VlazogJ1dvcmsgV2VlaycsXG4gIGRheTogJ0RheScsXG4gIG1vbnRoOiAnTW9udGgnLFxuICBwcmV2aW91czogJ0JhY2snLFxuICBuZXh0OiAnTmV4dCcsXG4gIHllc3RlcmRheTogJ1llc3RlcmRheScsXG4gIHRvbW9ycm93OiAnVG9tb3Jyb3cnLFxuICB0b2RheTogJ1RvZGF5JyxcbiAgYWdlbmRhOiAnQWdlbmRhJyxcbiAgbm9FdmVudHNJblJhbmdlOiAnVGhlcmUgYXJlIG5vIGV2ZW50cyBpbiB0aGlzIHJhbmdlLicsXG4gIHNob3dNb3JlOiBmdW5jdGlvbiBzaG93TW9yZSh0b3RhbCkge1xuICAgIHJldHVybiBcIitcIiArIHRvdGFsICsgXCIgbW9yZVwiO1xuICB9XG59O1xuZnVuY3Rpb24gbWVzc2FnZXMobXNncykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRNZXNzYWdlcywgbXNncyk7XG59XG5cbnZhciBNSUxMSSA9IHtcbiAgc2Vjb25kczogMTAwMCxcbiAgbWludXRlczogMTAwMCAqIDYwLFxuICBob3VyczogMTAwMCAqIDYwICogNjAsXG4gIGRheTogMTAwMCAqIDYwICogNjAgKiAyNFxufTtcbnZhciBNT05USFMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExXTtcblxudmFyIGRhdGVzID0gX2V4dGVuZHMoe30sIGRhdGVNYXRoLCB7XG4gIG1vbnRoc0luWWVhcjogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKHllYXIpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICAgIHJldHVybiBNT05USFMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gZGF0ZXMubW9udGgoZGF0ZSwgaSk7XG4gICAgfSk7XG4gIH0sXG4gIGZpcnN0VmlzaWJsZURheTogZnVuY3Rpb24gZmlyc3RWaXNpYmxlRGF5KGRhdGUsIGxvY2FsaXplcikge1xuICAgIHZhciBmaXJzdE9mTW9udGggPSBkYXRlcy5zdGFydE9mKGRhdGUsICdtb250aCcpO1xuICAgIHJldHVybiBkYXRlcy5zdGFydE9mKGZpcnN0T2ZNb250aCwgJ3dlZWsnLCBsb2NhbGl6ZXIuc3RhcnRPZldlZWsoKSk7XG4gIH0sXG4gIGxhc3RWaXNpYmxlRGF5OiBmdW5jdGlvbiBsYXN0VmlzaWJsZURheShkYXRlLCBsb2NhbGl6ZXIpIHtcbiAgICB2YXIgZW5kT2ZNb250aCA9IGRhdGVzLmVuZE9mKGRhdGUsICdtb250aCcpO1xuICAgIHJldHVybiBkYXRlcy5lbmRPZihlbmRPZk1vbnRoLCAnd2VlaycsIGxvY2FsaXplci5zdGFydE9mV2VlaygpKTtcbiAgfSxcbiAgdmlzaWJsZURheXM6IGZ1bmN0aW9uIHZpc2libGVEYXlzKGRhdGUsIGxvY2FsaXplcikge1xuICAgIHZhciBjdXJyZW50ID0gZGF0ZXMuZmlyc3RWaXNpYmxlRGF5KGRhdGUsIGxvY2FsaXplciksXG4gICAgICAgIGxhc3QgPSBkYXRlcy5sYXN0VmlzaWJsZURheShkYXRlLCBsb2NhbGl6ZXIpLFxuICAgICAgICBkYXlzID0gW107XG5cbiAgICB3aGlsZSAoZGF0ZXMubHRlKGN1cnJlbnQsIGxhc3QsICdkYXknKSkge1xuICAgICAgZGF5cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IGRhdGVzLmFkZChjdXJyZW50LCAxLCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH0sXG4gIGNlaWw6IGZ1bmN0aW9uIGNlaWwoZGF0ZSwgdW5pdCkge1xuICAgIHZhciBmbG9vciA9IGRhdGVzLnN0YXJ0T2YoZGF0ZSwgdW5pdCk7XG4gICAgcmV0dXJuIGRhdGVzLmVxKGZsb29yLCBkYXRlKSA/IGZsb29yIDogZGF0ZXMuYWRkKGZsb29yLCAxLCB1bml0KTtcbiAgfSxcbiAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlJCQxKHN0YXJ0LCBlbmQsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB1bml0ID0gJ2RheSc7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgZGF5cyA9IFtdO1xuXG4gICAgd2hpbGUgKGRhdGVzLmx0ZShjdXJyZW50LCBlbmQsIHVuaXQpKSB7XG4gICAgICBkYXlzLnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gZGF0ZXMuYWRkKGN1cnJlbnQsIDEsIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlzO1xuICB9LFxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoZGF0ZSwgdGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwgJiYgZGF0ZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodGltZSA9PSBudWxsKSB0aW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAoZGF0ZSA9PSBudWxsKSBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlID0gZGF0ZXMuc3RhcnRPZihkYXRlLCAnZGF5Jyk7XG4gICAgZGF0ZSA9IGRhdGVzLmhvdXJzKGRhdGUsIGRhdGVzLmhvdXJzKHRpbWUpKTtcbiAgICBkYXRlID0gZGF0ZXMubWludXRlcyhkYXRlLCBkYXRlcy5taW51dGVzKHRpbWUpKTtcbiAgICBkYXRlID0gZGF0ZXMuc2Vjb25kcyhkYXRlLCBkYXRlcy5zZWNvbmRzKHRpbWUpKTtcbiAgICByZXR1cm4gZGF0ZXMubWlsbGlzZWNvbmRzKGRhdGUsIGRhdGVzLm1pbGxpc2Vjb25kcyh0aW1lKSk7XG4gIH0sXG4gIGVxVGltZTogZnVuY3Rpb24gZXFUaW1lKGRhdGVBLCBkYXRlQikge1xuICAgIHJldHVybiBkYXRlcy5ob3VycyhkYXRlQSkgPT09IGRhdGVzLmhvdXJzKGRhdGVCKSAmJiBkYXRlcy5taW51dGVzKGRhdGVBKSA9PT0gZGF0ZXMubWludXRlcyhkYXRlQikgJiYgZGF0ZXMuc2Vjb25kcyhkYXRlQSkgPT09IGRhdGVzLnNlY29uZHMoZGF0ZUIpO1xuICB9LFxuICBpc0p1c3REYXRlOiBmdW5jdGlvbiBpc0p1c3REYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZXMuaG91cnMoZGF0ZSkgPT09IDAgJiYgZGF0ZXMubWludXRlcyhkYXRlKSA9PT0gMCAmJiBkYXRlcy5zZWNvbmRzKGRhdGUpID09PSAwICYmIGRhdGVzLm1pbGxpc2Vjb25kcyhkYXRlKSA9PT0gMDtcbiAgfSxcbiAgZHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKHN0YXJ0LCBlbmQsIHVuaXQsIGZpcnN0T2ZXZWVrKSB7XG4gICAgaWYgKHVuaXQgPT09ICdkYXknKSB1bml0ID0gJ2RhdGUnO1xuICAgIHJldHVybiBNYXRoLmFicyhkYXRlc1t1bml0XShzdGFydCwgdW5kZWZpbmVkLCBmaXJzdE9mV2VlaykgLSBkYXRlc1t1bml0XShlbmQsIHVuZGVmaW5lZCwgZmlyc3RPZldlZWspKTtcbiAgfSxcbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRlQSwgZGF0ZUIsIHVuaXQpIHtcbiAgICBpZiAoIXVuaXQgfHwgdW5pdCA9PT0gJ21pbGxpc2Vjb25kcycpIHJldHVybiBNYXRoLmFicygrZGF0ZUEgLSArZGF0ZUIpOyAvLyB0aGUgLnJvdW5kKCkgaGFuZGxlcyBhbiBlZGdlIGNhc2VcbiAgICAvLyB3aXRoIERTVCB3aGVyZSB0aGUgdG90YWwgd29uJ3QgYmUgZXhhY3RcbiAgICAvLyBzaW5jZSBvbmUgZGF5IGluIHRoZSByYW5nZSBtYXkgYmUgc2hvcnRlci9sb25nZXIgYnkgYW4gaG91clxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5hYnMoK2RhdGVzLnN0YXJ0T2YoZGF0ZUEsIHVuaXQpIC8gTUlMTElbdW5pdF0gLSArZGF0ZXMuc3RhcnRPZihkYXRlQiwgdW5pdCkgLyBNSUxMSVt1bml0XSkpO1xuICB9LFxuICB0b3RhbDogZnVuY3Rpb24gdG90YWwoZGF0ZSwgdW5pdCkge1xuICAgIHZhciBtcyA9IGRhdGUuZ2V0VGltZSgpLFxuICAgICAgICBkaXYgPSAxO1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgZGl2ICo9IDc7XG5cbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGRpdiAqPSAyNDtcblxuICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICBkaXYgKj0gNjA7XG5cbiAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICBkaXYgKj0gNjA7XG5cbiAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICBkaXYgKj0gMTAwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbXMgLyBkaXY7XG4gIH0sXG4gIHdlZWs6IGZ1bmN0aW9uIHdlZWsoZGF0ZSkge1xuICAgIHZhciBkID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgZC5zZXRIb3VycygwLCAwLCAwKTtcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyA0IC0gKGQuZ2V0RGF5KCkgfHwgNykpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKChkIC0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkgLyA4LjY0ZTcgKyAxKSAvIDcpO1xuICB9LFxuICB0b2RheTogZnVuY3Rpb24gdG9kYXkoKSB7XG4gICAgcmV0dXJuIGRhdGVzLnN0YXJ0T2YobmV3IERhdGUoKSwgJ2RheScpO1xuICB9LFxuICB5ZXN0ZXJkYXk6IGZ1bmN0aW9uIHllc3RlcmRheSgpIHtcbiAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGVzLnN0YXJ0T2YobmV3IERhdGUoKSwgJ2RheScpLCAtMSwgJ2RheScpO1xuICB9LFxuICB0b21vcnJvdzogZnVuY3Rpb24gdG9tb3Jyb3coKSB7XG4gICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlcy5zdGFydE9mKG5ldyBEYXRlKCksICdkYXknKSwgMSwgJ2RheScpO1xuICB9XG59KTtcblxudmFyIEV2ZW50Q2VsbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFdmVudENlbGwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEV2ZW50Q2VsbCgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRXZlbnRDZWxsLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHMuc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgZXZlbnQgPSBfdGhpcyRwcm9wcy5ldmVudCxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgaXNBbGxEYXkgPSBfdGhpcyRwcm9wcy5pc0FsbERheSxcbiAgICAgICAgb25TZWxlY3QgPSBfdGhpcyRwcm9wcy5vblNlbGVjdCxcbiAgICAgICAgX29uRG91YmxlQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkRvdWJsZUNsaWNrLFxuICAgICAgICBsb2NhbGl6ZXIgPSBfdGhpcyRwcm9wcy5sb2NhbGl6ZXIsXG4gICAgICAgIGNvbnRpbnVlc1ByaW9yID0gX3RoaXMkcHJvcHMuY29udGludWVzUHJpb3IsXG4gICAgICAgIGNvbnRpbnVlc0FmdGVyID0gX3RoaXMkcHJvcHMuY29udGludWVzQWZ0ZXIsXG4gICAgICAgIGFjY2Vzc29ycyA9IF90aGlzJHByb3BzLmFjY2Vzc29ycyxcbiAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzLmdldHRlcnMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF90aGlzJHByb3BzJGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgIEV2ZW50ID0gX3RoaXMkcHJvcHMkY29tcG9uZW50LmV2ZW50LFxuICAgICAgICBFdmVudFdyYXBwZXIgPSBfdGhpcyRwcm9wcyRjb21wb25lbnQuZXZlbnRXcmFwcGVyLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcImV2ZW50XCIsIFwic2VsZWN0ZWRcIiwgXCJpc0FsbERheVwiLCBcIm9uU2VsZWN0XCIsIFwib25Eb3VibGVDbGlja1wiLCBcImxvY2FsaXplclwiLCBcImNvbnRpbnVlc1ByaW9yXCIsIFwiY29udGludWVzQWZ0ZXJcIiwgXCJhY2Nlc3NvcnNcIiwgXCJnZXR0ZXJzXCIsIFwiY2hpbGRyZW5cIiwgXCJjb21wb25lbnRzXCJdKTtcblxuICAgIHZhciB0aXRsZSA9IGFjY2Vzc29ycy50aXRsZShldmVudCk7XG4gICAgdmFyIHRvb2x0aXAgPSBhY2Nlc3NvcnMudG9vbHRpcChldmVudCk7XG4gICAgdmFyIGVuZCA9IGFjY2Vzc29ycy5lbmQoZXZlbnQpO1xuICAgIHZhciBzdGFydCA9IGFjY2Vzc29ycy5zdGFydChldmVudCk7XG4gICAgdmFyIGFsbERheSA9IGFjY2Vzc29ycy5hbGxEYXkoZXZlbnQpO1xuICAgIHZhciBzaG93QXNBbGxEYXkgPSBpc0FsbERheSB8fCBhbGxEYXkgfHwgZGF0ZXMuZGlmZihzdGFydCwgZGF0ZXMuY2VpbChlbmQsICdkYXknKSwgJ2RheScpID4gMTtcbiAgICB2YXIgdXNlclByb3BzID0gZ2V0dGVycy5ldmVudFByb3AoZXZlbnQsIHN0YXJ0LCBlbmQsIHNlbGVjdGVkKTtcbiAgICB2YXIgY29udGVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1ldmVudC1jb250ZW50XCIsXG4gICAgICB0aXRsZTogdG9vbHRpcCB8fCB1bmRlZmluZWRcbiAgICB9LCBFdmVudCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXZlbnQsIHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGlzQWxsRGF5OiBhbGxEYXksXG4gICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplclxuICAgIH0pIDogdGl0bGUpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50V3JhcHBlciwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHtcbiAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICB0YWJJbmRleDogMCxcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgdXNlclByb3BzLnN0eWxlLCBzdHlsZSksXG4gICAgICBjbGFzc05hbWU6IGNuKCdyYmMtZXZlbnQnLCBjbGFzc05hbWUsIHVzZXJQcm9wcy5jbGFzc05hbWUsIHtcbiAgICAgICAgJ3JiYy1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAncmJjLWV2ZW50LWFsbGRheSc6IHNob3dBc0FsbERheSxcbiAgICAgICAgJ3JiYy1ldmVudC1jb250aW51ZXMtcHJpb3InOiBjb250aW51ZXNQcmlvcixcbiAgICAgICAgJ3JiYy1ldmVudC1jb250aW51ZXMtYWZ0ZXInOiBjb250aW51ZXNBZnRlclxuICAgICAgfSksXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgcmV0dXJuIG9uU2VsZWN0ICYmIG9uU2VsZWN0KGV2ZW50LCBlKTtcbiAgICAgIH0sXG4gICAgICBvbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgcmV0dXJuIF9vbkRvdWJsZUNsaWNrICYmIF9vbkRvdWJsZUNsaWNrKGV2ZW50LCBlKTtcbiAgICAgIH1cbiAgICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oY29udGVudCkgOiBjb250ZW50KSk7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50Q2VsbDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRXZlbnRDZWxsLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZXZlbnQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgc2xvdFN0YXJ0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgc2xvdEVuZDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSksXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaXNBbGxEYXk6IFByb3BUeXBlcy5ib29sLFxuICBjb250aW51ZXNQcmlvcjogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbnRpbnVlc0FmdGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgYWNjZXNzb3JzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZ2V0dGVyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhbGl6ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Eb3VibGVDbGljazogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTtcblxuZnVuY3Rpb24gaXNTZWxlY3RlZChldmVudCwgc2VsZWN0ZWQpIHtcbiAgaWYgKCFldmVudCB8fCBzZWxlY3RlZCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBbXS5jb25jYXQoc2VsZWN0ZWQpLmluZGV4T2YoZXZlbnQpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHNsb3RXaWR0aChyb3dCb3gsIHNsb3RzKSB7XG4gIHZhciByb3dXaWR0aCA9IHJvd0JveC5yaWdodCAtIHJvd0JveC5sZWZ0O1xuICB2YXIgY2VsbFdpZHRoID0gcm93V2lkdGggLyBzbG90cztcbiAgcmV0dXJuIGNlbGxXaWR0aDtcbn1cbmZ1bmN0aW9uIGdldFNsb3RBdFgocm93Qm94LCB4LCBydGwsIHNsb3RzKSB7XG4gIHZhciBjZWxsV2lkdGggPSBzbG90V2lkdGgocm93Qm94LCBzbG90cyk7XG4gIHJldHVybiBydGwgPyBzbG90cyAtIDEgLSBNYXRoLmZsb29yKCh4IC0gcm93Qm94LmxlZnQpIC8gY2VsbFdpZHRoKSA6IE1hdGguZmxvb3IoKHggLSByb3dCb3gubGVmdCkgLyBjZWxsV2lkdGgpO1xufVxuZnVuY3Rpb24gcG9pbnRJbkJveChib3gsIF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICByZXR1cm4geSA+PSBib3gudG9wICYmIHkgPD0gYm94LmJvdHRvbSAmJiB4ID49IGJveC5sZWZ0ICYmIHggPD0gYm94LnJpZ2h0O1xufVxuZnVuY3Rpb24gZGF0ZUNlbGxTZWxlY3Rpb24oc3RhcnQsIHJvd0JveCwgYm94LCBzbG90cywgcnRsKSB7XG4gIHZhciBzdGFydElkeCA9IC0xO1xuICB2YXIgZW5kSWR4ID0gLTE7XG4gIHZhciBsYXN0U2xvdElkeCA9IHNsb3RzIC0gMTtcbiAgdmFyIGNlbGxXaWR0aCA9IHNsb3RXaWR0aChyb3dCb3gsIHNsb3RzKTsgLy8gY2VsbCB1bmRlciB0aGUgbW91c2VcblxuICB2YXIgY3VycmVudFNsb3QgPSBnZXRTbG90QXRYKHJvd0JveCwgYm94LngsIHJ0bCwgc2xvdHMpOyAvLyBJZGVudGlmeSByb3cgYXMgZWl0aGVyIHRoZSBpbml0aWFsIHJvd1xuICAvLyBvciB0aGUgcm93IHVuZGVyIHRoZSBjdXJyZW50IG1vdXNlIHBvaW50XG5cbiAgdmFyIGlzQ3VycmVudFJvdyA9IHJvd0JveC50b3AgPCBib3gueSAmJiByb3dCb3guYm90dG9tID4gYm94Lnk7XG4gIHZhciBpc1N0YXJ0Um93ID0gcm93Qm94LnRvcCA8IHN0YXJ0LnkgJiYgcm93Qm94LmJvdHRvbSA+IHN0YXJ0Lnk7IC8vIHRoaXMgcm93J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IHBvaW50XG5cbiAgdmFyIGlzQWJvdmVTdGFydCA9IHN0YXJ0LnkgPiByb3dCb3guYm90dG9tO1xuICB2YXIgaXNCZWxvd1N0YXJ0ID0gcm93Qm94LnRvcCA+IHN0YXJ0Lnk7XG4gIHZhciBpc0JldHdlZW4gPSBib3gudG9wIDwgcm93Qm94LnRvcCAmJiBib3guYm90dG9tID4gcm93Qm94LmJvdHRvbTsgLy8gdGhpcyByb3cgaXMgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgc3RhcnQgcm93cywgc28gZW50aXJlbHkgc2VsZWN0ZWRcblxuICBpZiAoaXNCZXR3ZWVuKSB7XG4gICAgc3RhcnRJZHggPSAwO1xuICAgIGVuZElkeCA9IGxhc3RTbG90SWR4O1xuICB9XG5cbiAgaWYgKGlzQ3VycmVudFJvdykge1xuICAgIGlmIChpc0JlbG93U3RhcnQpIHtcbiAgICAgIHN0YXJ0SWR4ID0gMDtcbiAgICAgIGVuZElkeCA9IGN1cnJlbnRTbG90O1xuICAgIH0gZWxzZSBpZiAoaXNBYm92ZVN0YXJ0KSB7XG4gICAgICBzdGFydElkeCA9IGN1cnJlbnRTbG90O1xuICAgICAgZW5kSWR4ID0gbGFzdFNsb3RJZHg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzU3RhcnRSb3cpIHtcbiAgICAvLyBzZWxlY3QgdGhlIGNlbGwgdW5kZXIgdGhlIGluaXRpYWwgcG9pbnRcbiAgICBzdGFydElkeCA9IGVuZElkeCA9IHJ0bCA/IGxhc3RTbG90SWR4IC0gTWF0aC5mbG9vcigoc3RhcnQueCAtIHJvd0JveC5sZWZ0KSAvIGNlbGxXaWR0aCkgOiBNYXRoLmZsb29yKChzdGFydC54IC0gcm93Qm94LmxlZnQpIC8gY2VsbFdpZHRoKTtcblxuICAgIGlmIChpc0N1cnJlbnRSb3cpIHtcbiAgICAgIGlmIChjdXJyZW50U2xvdCA8IHN0YXJ0SWR4KSBzdGFydElkeCA9IGN1cnJlbnRTbG90O2Vsc2UgZW5kSWR4ID0gY3VycmVudFNsb3Q7IC8vc2VsZWN0IGN1cnJlbnQgcmFuZ2VcbiAgICB9IGVsc2UgaWYgKHN0YXJ0LnkgPCBib3gueSkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgcm93IGlzIGJlbG93IHN0YXJ0IHJvd1xuICAgICAgLy8gc2VsZWN0IGNlbGxzIHRvIHRoZSByaWdodCBvZiB0aGUgc3RhcnQgY2VsbFxuICAgICAgZW5kSWR4ID0gbGFzdFNsb3RJZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNlbGVjdCBjZWxscyB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgY2VsbFxuICAgICAgc3RhcnRJZHggPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRJZHg6IHN0YXJ0SWR4LFxuICAgIGVuZElkeDogZW5kSWR4XG4gIH07XG59XG5cbnZhciBQb3B1cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShQb3B1cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9wdXAoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvcHVwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMkcG9wdXBPZmZzID0gdGhpcy5wcm9wcy5wb3B1cE9mZnNldCxcbiAgICAgICAgcG9wdXBPZmZzZXQgPSBfdGhpcyRwcm9wcyRwb3B1cE9mZnMgPT09IHZvaWQgMCA/IDUgOiBfdGhpcyRwcm9wcyRwb3B1cE9mZnMsXG4gICAgICAgIF9nZXRPZmZzZXQgPSBnZXRPZmZzZXQodGhpcy5yZWZzLnJvb3QpLFxuICAgICAgICB0b3AgPSBfZ2V0T2Zmc2V0LnRvcCxcbiAgICAgICAgbGVmdCA9IF9nZXRPZmZzZXQubGVmdCxcbiAgICAgICAgd2lkdGggPSBfZ2V0T2Zmc2V0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfZ2V0T2Zmc2V0LmhlaWdodCxcbiAgICAgICAgdmlld0JvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCArIGdldFNjcm9sbFRvcCh3aW5kb3cpLFxuICAgICAgICB2aWV3UmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCArIGdldFNjcm9sbExlZnQod2luZG93KSxcbiAgICAgICAgYm90dG9tID0gdG9wICsgaGVpZ2h0LFxuICAgICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcblxuICAgIGlmIChib3R0b20gPiB2aWV3Qm90dG9tIHx8IHJpZ2h0ID4gdmlld1JpZ2h0KSB7XG4gICAgICB2YXIgdG9wT2Zmc2V0LCBsZWZ0T2Zmc2V0O1xuICAgICAgaWYgKGJvdHRvbSA+IHZpZXdCb3R0b20pIHRvcE9mZnNldCA9IGJvdHRvbSAtIHZpZXdCb3R0b20gKyAocG9wdXBPZmZzZXQueSB8fCArcG9wdXBPZmZzZXQgfHwgMCk7XG4gICAgICBpZiAocmlnaHQgPiB2aWV3UmlnaHQpIGxlZnRPZmZzZXQgPSByaWdodCAtIHZpZXdSaWdodCArIChwb3B1cE9mZnNldC54IHx8ICtwb3B1cE9mZnNldCB8fCAwKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB0b3BPZmZzZXQ6IHRvcE9mZnNldCxcbiAgICAgICAgbGVmdE9mZnNldDogbGVmdE9mZnNldFxuICAgICAgfSk7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGV2ZW50cyQkMSA9IF90aGlzJHByb3BzLmV2ZW50cyxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzLmdldHRlcnMsXG4gICAgICAgIGFjY2Vzc29ycyA9IF90aGlzJHByb3BzLmFjY2Vzc29ycyxcbiAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgIG9uU2VsZWN0ID0gX3RoaXMkcHJvcHMub25TZWxlY3QsXG4gICAgICAgIG9uRG91YmxlQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkRvdWJsZUNsaWNrLFxuICAgICAgICBzbG90U3RhcnQgPSBfdGhpcyRwcm9wcy5zbG90U3RhcnQsXG4gICAgICAgIHNsb3RFbmQgPSBfdGhpcyRwcm9wcy5zbG90RW5kLFxuICAgICAgICBsb2NhbGl6ZXIgPSBfdGhpcyRwcm9wcy5sb2NhbGl6ZXI7XG4gICAgdmFyIF90aGlzJHByb3BzJHBvc2l0aW9uID0gdGhpcy5wcm9wcy5wb3NpdGlvbixcbiAgICAgICAgbGVmdCA9IF90aGlzJHByb3BzJHBvc2l0aW9uLmxlZnQsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ud2lkdGgsXG4gICAgICAgIHRvcCA9IF90aGlzJHByb3BzJHBvc2l0aW9uLnRvcCxcbiAgICAgICAgdG9wT2Zmc2V0ID0gKHRoaXMuc3RhdGUgfHwge30pLnRvcE9mZnNldCB8fCAwLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gKHRoaXMuc3RhdGUgfHwge30pLmxlZnRPZmZzZXQgfHwgMDtcbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICB0b3A6IE1hdGgubWF4KDAsIHRvcCAtIHRvcE9mZnNldCksXG4gICAgICBsZWZ0OiBsZWZ0IC0gbGVmdE9mZnNldCxcbiAgICAgIG1pbldpZHRoOiB3aWR0aCArIHdpZHRoIC8gMlxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgcmVmOiBcInJvb3RcIixcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtb3ZlcmxheVwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLW92ZXJsYXktaGVhZGVyXCJcbiAgICB9LCBsb2NhbGl6ZXIuZm9ybWF0KHNsb3RTdGFydCwgJ2RheUhlYWRlckZvcm1hdCcpKSwgZXZlbnRzJCQxLm1hcChmdW5jdGlvbiAoZXZlbnQsIGlkeCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXZlbnRDZWxsLCB7XG4gICAgICAgIGtleTogaWR4LFxuICAgICAgICB0eXBlOiBcInBvcHVwXCIsXG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgZ2V0dGVyczogZ2V0dGVycyxcbiAgICAgICAgb25TZWxlY3Q6IG9uU2VsZWN0LFxuICAgICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICAgICAgY29udGludWVzUHJpb3I6IGRhdGVzLmx0KGFjY2Vzc29ycy5lbmQoZXZlbnQpLCBzbG90U3RhcnQsICdkYXknKSxcbiAgICAgICAgY29udGludWVzQWZ0ZXI6IGRhdGVzLmd0ZShhY2Nlc3NvcnMuc3RhcnQoZXZlbnQpLCBzbG90RW5kLCAnZGF5JyksXG4gICAgICAgIHNlbGVjdGVkOiBpc1NlbGVjdGVkKGV2ZW50LCBzZWxlY3RlZClcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUG9wdXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblBvcHVwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgcG9zaXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIHBvcHVwT2Zmc2V0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgeTogUHJvcFR5cGVzLm51bWJlclxuICB9KV0pLFxuICBldmVudHM6IFByb3BUeXBlcy5hcnJheSxcbiAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5vYmplY3QsXG4gIGFjY2Vzc29yczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGdldHRlcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYWxpemVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Eb3VibGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHNsb3RTdGFydDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSksXG4gIHNsb3RFbmQ6IFByb3BUeXBlcy5udW1iZXJcbn0gOiB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQ7XG4gIH1cblxuICBldmVudHMub24odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBldmVudHMub2ZmKHRhcmdldCwgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc092ZXJDb250YWluZXIoY29udGFpbmVyLCB4LCB5KSB7XG4gIHJldHVybiAhY29udGFpbmVyIHx8IGNvbnRhaW5zKGNvbnRhaW5lciwgZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSk7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50Tm9kZUZyb21Qb2ludChub2RlLCBfcmVmKSB7XG4gIHZhciBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG4gIHJldHVybiBjbG9zZXN0KHRhcmdldCwgJy5yYmMtZXZlbnQnLCBub2RlKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnQobm9kZSwgYm91bmRzKSB7XG4gIHJldHVybiAhIWdldEV2ZW50Tm9kZUZyb21Qb2ludChub2RlLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGVzKGUpIHtcbiAgdmFyIHRhcmdldCA9IGU7XG5cbiAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgdGFyZ2V0ID0gZS50b3VjaGVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiB0YXJnZXQuY2xpZW50WCxcbiAgICBjbGllbnRZOiB0YXJnZXQuY2xpZW50WSxcbiAgICBwYWdlWDogdGFyZ2V0LnBhZ2VYLFxuICAgIHBhZ2VZOiB0YXJnZXQucGFnZVlcbiAgfTtcbn1cblxudmFyIGNsaWNrVG9sZXJhbmNlID0gNTtcbnZhciBjbGlja0ludGVydmFsID0gMjUwO1xuXG52YXIgU2VsZWN0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uKG5vZGUsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWYyID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYyJGdsb2JhbCA9IF9yZWYyLmdsb2JhbCxcbiAgICAgICAgZ2xvYmFsID0gX3JlZjIkZ2xvYmFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGdsb2JhbCxcbiAgICAgICAgX3JlZjIkbG9uZ1ByZXNzVGhyZXNoID0gX3JlZjIubG9uZ1ByZXNzVGhyZXNob2xkLFxuICAgICAgICBsb25nUHJlc3NUaHJlc2hvbGQgPSBfcmVmMiRsb25nUHJlc3NUaHJlc2ggPT09IHZvaWQgMCA/IDI1MCA6IF9yZWYyJGxvbmdQcmVzc1RocmVzaDtcblxuICAgIHRoaXMuY29udGFpbmVyID0gbm9kZTtcbiAgICB0aGlzLmdsb2JhbE1vdXNlID0gIW5vZGUgfHwgZ2xvYmFsO1xuICAgIHRoaXMubG9uZ1ByZXNzVGhyZXNob2xkID0gbG9uZ1ByZXNzVGhyZXNob2xkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5faGFuZGxlSW5pdGlhbEV2ZW50ID0gdGhpcy5faGFuZGxlSW5pdGlhbEV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlTW92ZUV2ZW50ID0gdGhpcy5faGFuZGxlTW92ZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlVGVybWluYXRpbmdFdmVudCA9IHRoaXMuX2hhbmRsZVRlcm1pbmF0aW5nRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9rZXlMaXN0ZW5lciA9IHRoaXMuX2tleUxpc3RlbmVyLmJpbmQodGhpcyk7IC8vIEZpeGVzIGFuIGlPUyAxMCBidWcgd2hlcmUgc2Nyb2xsaW5nIGNvdWxkIG5vdCBiZSBwcmV2ZW50ZWQgb24gdGhlIHdpbmRvdy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWV0YWZpenp5L2ZsaWNraXR5L2lzc3Vlcy80NTcjaXNzdWVjb21tZW50LTI1NDUwMTM1NlxuXG4gICAgdGhpcy5fb25Ub3VjaE1vdmVXaW5kb3dMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uICgpIHt9LCB3aW5kb3cpO1xuICAgIHRoaXMuX29uS2V5RG93bkxpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleUxpc3RlbmVyKTtcbiAgICB0aGlzLl9vbktleVVwTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX2tleUxpc3RlbmVyKTtcblxuICAgIHRoaXMuX2FkZEluaXRpYWxFdmVudExpc3RlbmVyKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2VsZWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8ICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHZhciBpZHggPSBoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8udGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fb25Ub3VjaE1vdmVXaW5kb3dMaXN0ZW5lciAmJiB0aGlzLl9vblRvdWNoTW92ZVdpbmRvd0xpc3RlbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMuX29uSW5pdGlhbEV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fb25Jbml0aWFsRXZlbnRMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB0aGlzLl9vbkVuZExpc3RlbmVyICYmIHRoaXMuX29uRW5kTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fb25Fc2NMaXN0ZW5lciAmJiB0aGlzLl9vbkVzY0xpc3RlbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMuX29uTW92ZUxpc3RlbmVyICYmIHRoaXMuX29uTW92ZUxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMuX29uS2V5VXBMaXN0ZW5lciAmJiB0aGlzLl9vbktleVVwTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fb25LZXlEb3duTGlzdGVuZXIgJiYgdGhpcy5fb25LZXlEb3duTGlzdGVuZXIucmVtb3ZlKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKG5vZGUpIHtcbiAgICB2YXIgYm94ID0gdGhpcy5fc2VsZWN0UmVjdDtcbiAgICBpZiAoIWJveCB8fCAhdGhpcy5zZWxlY3RpbmcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb2JqZWN0c0NvbGxpZGUoYm94LCBnZXRCb3VuZHNGb3JOb2RlKG5vZGUpKTtcbiAgfTtcblxuICBfcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW1zKSB7XG4gICAgdmFyIGJveCA9IHRoaXMuX3NlbGVjdFJlY3Q7IC8vbm90IHNlbGVjdGluZ1xuXG4gICAgaWYgKCFib3ggfHwgIXRoaXMuc2VsZWN0aW5nKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcih0aGlzLmlzU2VsZWN0ZWQsIHRoaXMpO1xuICB9OyAvLyBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGNhbGwgdGhlIGhhbmRsZXIgb25seSBhZnRlciB0aGUgdXNlciBoYXMgcHJlc3NlZCBvbiB0aGUgc2NyZWVuXG4gIC8vIHdpdGhvdXQgbW92aW5nIHRoZWlyIGZpbmdlciBmb3IgMjUwbXMuXG5cblxuICBfcHJvdG8uX2FkZExvbmdQcmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExvbmdQcmVzc0xpc3RlbmVyKGhhbmRsZXIsIGluaXRpYWxFdmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHZhciB0b3VjaE1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgdmFyIHRvdWNoRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgdmFyIGhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGluaXRpYWxFdmVudCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBoYW5kbGVyKGluaXRpYWxFdmVudCk7XG4gICAgICB9LCBfdGhpcy5sb25nUHJlc3NUaHJlc2hvbGQpO1xuICAgICAgdG91Y2hNb3ZlTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGVhbnVwKCk7XG4gICAgICB9KTtcbiAgICAgIHRvdWNoRW5kTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFudXAoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgdG91Y2hTdGFydExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoU3RhcnQpO1xuXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaE1vdmVMaXN0ZW5lcikge1xuICAgICAgICB0b3VjaE1vdmVMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdWNoRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgdG91Y2hFbmRMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgdG91Y2hNb3ZlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgdG91Y2hFbmRMaXN0ZW5lciA9IG51bGw7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsRXZlbnQpIHtcbiAgICAgIGhhbmRsZVRvdWNoU3RhcnQoaW5pdGlhbEV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgdG91Y2hTdGFydExpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH07IC8vIExpc3RlbiBmb3IgbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGV2ZW50cy4gV2hlbiBvbmUgaXMgcmVjZWl2ZWQsIGRpc2FibGUgdGhlIG90aGVyIGFuZCBzZXR1cFxuICAvLyBmdXR1cmUgZXZlbnQgaGFuZGxpbmcgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG5cblxuICBfcHJvdG8uX2FkZEluaXRpYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZEluaXRpYWxFdmVudExpc3RlbmVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG1vdXNlRG93bkxpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzMi5fb25Jbml0aWFsRXZlbnRMaXN0ZW5lci5yZW1vdmUoKTtcblxuICAgICAgX3RoaXMyLl9oYW5kbGVJbml0aWFsRXZlbnQoZSk7XG5cbiAgICAgIF90aGlzMi5fb25Jbml0aWFsRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF90aGlzMi5faGFuZGxlSW5pdGlhbEV2ZW50KTtcbiAgICB9KTtcbiAgICB2YXIgdG91Y2hTdGFydExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpczIuX29uSW5pdGlhbEV2ZW50TGlzdGVuZXIucmVtb3ZlKCk7XG5cbiAgICAgIF90aGlzMi5fb25Jbml0aWFsRXZlbnRMaXN0ZW5lciA9IF90aGlzMi5fYWRkTG9uZ1ByZXNzTGlzdGVuZXIoX3RoaXMyLl9oYW5kbGVJbml0aWFsRXZlbnQsIGUpO1xuICAgIH0pO1xuICAgIHRoaXMuX29uSW5pdGlhbEV2ZW50TGlzdGVuZXIgPSB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgbW91c2VEb3duTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIHRvdWNoU3RhcnRMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlSW5pdGlhbEV2ZW50ID0gZnVuY3Rpb24gX2hhbmRsZUluaXRpYWxFdmVudChlKSB7XG4gICAgdmFyIF9nZXRFdmVudENvb3JkaW5hdGVzID0gZ2V0RXZlbnRDb29yZGluYXRlcyhlKSxcbiAgICAgICAgY2xpZW50WCA9IF9nZXRFdmVudENvb3JkaW5hdGVzLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBfZ2V0RXZlbnRDb29yZGluYXRlcy5jbGllbnRZLFxuICAgICAgICBwYWdlWCA9IF9nZXRFdmVudENvb3JkaW5hdGVzLnBhZ2VYLFxuICAgICAgICBwYWdlWSA9IF9nZXRFdmVudENvb3JkaW5hdGVzLnBhZ2VZO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLmNvbnRhaW5lcigpLFxuICAgICAgICBjb2xsaWRlcyxcbiAgICAgICAgb2Zmc2V0RGF0YTsgLy8gUmlnaHQgY2xpY2tzXG5cbiAgICBpZiAoZS53aGljaCA9PT0gMyB8fCBlLmJ1dHRvbiA9PT0gMiB8fCAhaXNPdmVyQ29udGFpbmVyKG5vZGUsIGNsaWVudFgsIGNsaWVudFkpKSByZXR1cm47XG5cbiAgICBpZiAoIXRoaXMuZ2xvYmFsTW91c2UgJiYgbm9kZSAmJiAhY29udGFpbnMobm9kZSwgZS50YXJnZXQpKSB7XG4gICAgICB2YXIgX25vcm1hbGl6ZURpc3RhbmNlID0gbm9ybWFsaXplRGlzdGFuY2UoMCksXG4gICAgICAgICAgdG9wID0gX25vcm1hbGl6ZURpc3RhbmNlLnRvcCxcbiAgICAgICAgICBsZWZ0ID0gX25vcm1hbGl6ZURpc3RhbmNlLmxlZnQsXG4gICAgICAgICAgYm90dG9tID0gX25vcm1hbGl6ZURpc3RhbmNlLmJvdHRvbSxcbiAgICAgICAgICByaWdodCA9IF9ub3JtYWxpemVEaXN0YW5jZS5yaWdodDtcblxuICAgICAgb2Zmc2V0RGF0YSA9IGdldEJvdW5kc0Zvck5vZGUobm9kZSk7XG4gICAgICBjb2xsaWRlcyA9IG9iamVjdHNDb2xsaWRlKHtcbiAgICAgICAgdG9wOiBvZmZzZXREYXRhLnRvcCAtIHRvcCxcbiAgICAgICAgbGVmdDogb2Zmc2V0RGF0YS5sZWZ0IC0gbGVmdCxcbiAgICAgICAgYm90dG9tOiBvZmZzZXREYXRhLmJvdHRvbSArIGJvdHRvbSxcbiAgICAgICAgcmlnaHQ6IG9mZnNldERhdGEucmlnaHQgKyByaWdodFxuICAgICAgfSwge1xuICAgICAgICB0b3A6IHBhZ2VZLFxuICAgICAgICBsZWZ0OiBwYWdlWFxuICAgICAgfSk7XG4gICAgICBpZiAoIWNvbGxpZGVzKSByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZW1pdCgnYmVmb3JlU2VsZWN0JywgdGhpcy5faW5pdGlhbEV2ZW50RGF0YSA9IHtcbiAgICAgIGlzVG91Y2g6IC9edG91Y2gvLnRlc3QoZS50eXBlKSxcbiAgICAgIHg6IHBhZ2VYLFxuICAgICAgeTogcGFnZVksXG4gICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5fb25FbmRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVUZXJtaW5hdGluZ0V2ZW50KTtcbiAgICAgICAgdGhpcy5fb25Fc2NMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVUZXJtaW5hdGluZ0V2ZW50KTtcbiAgICAgICAgdGhpcy5fb25Nb3ZlTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdmVFdmVudChlKTtcblxuICAgICAgICB0aGlzLl9vbkVuZExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUZXJtaW5hdGluZ0V2ZW50KTtcbiAgICAgICAgdGhpcy5fb25Nb3ZlTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faGFuZGxlVGVybWluYXRpbmdFdmVudCA9IGZ1bmN0aW9uIF9oYW5kbGVUZXJtaW5hdGluZ0V2ZW50KGUpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXMyID0gZ2V0RXZlbnRDb29yZGluYXRlcyhlKSxcbiAgICAgICAgcGFnZVggPSBfZ2V0RXZlbnRDb29yZGluYXRlczIucGFnZVgsXG4gICAgICAgIHBhZ2VZID0gX2dldEV2ZW50Q29vcmRpbmF0ZXMyLnBhZ2VZO1xuXG4gICAgdGhpcy5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9vbkVuZExpc3RlbmVyICYmIHRoaXMuX29uRW5kTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fb25Nb3ZlTGlzdGVuZXIgJiYgdGhpcy5fb25Nb3ZlTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsRXZlbnREYXRhKSByZXR1cm47XG4gICAgdmFyIGluUm9vdCA9ICF0aGlzLmNvbnRhaW5lciB8fCBjb250YWlucyh0aGlzLmNvbnRhaW5lcigpLCBlLnRhcmdldCk7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX3NlbGVjdFJlY3Q7XG4gICAgdmFyIGNsaWNrID0gdGhpcy5pc0NsaWNrKHBhZ2VYLCBwYWdlWSk7XG4gICAgdGhpcy5faW5pdGlhbEV2ZW50RGF0YSA9IG51bGw7XG5cbiAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdyZXNldCcpO1xuICAgIH1cblxuICAgIGlmICghaW5Sb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdyZXNldCcpO1xuICAgIH1cblxuICAgIGlmIChjbGljayAmJiBpblJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDbGlja0V2ZW50KGUpO1xuICAgIH0gLy8gVXNlciBkcmFnLWNsaWNrZWQgaW4gdGhlIFNlbGVjdGFibGUgYXJlYVxuXG5cbiAgICBpZiAoIWNsaWNrKSByZXR1cm4gdGhpcy5lbWl0KCdzZWxlY3QnLCBib3VuZHMpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIF9oYW5kbGVDbGlja0V2ZW50KGUpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXMzID0gZ2V0RXZlbnRDb29yZGluYXRlcyhlKSxcbiAgICAgICAgcGFnZVggPSBfZ2V0RXZlbnRDb29yZGluYXRlczMucGFnZVgsXG4gICAgICAgIHBhZ2VZID0gX2dldEV2ZW50Q29vcmRpbmF0ZXMzLnBhZ2VZLFxuICAgICAgICBjbGllbnRYID0gX2dldEV2ZW50Q29vcmRpbmF0ZXMzLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBfZ2V0RXZlbnRDb29yZGluYXRlczMuY2xpZW50WTtcblxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIGlmICh0aGlzLl9sYXN0Q2xpY2tEYXRhICYmIG5vdyAtIHRoaXMuX2xhc3RDbGlja0RhdGEudGltZXN0YW1wIDwgY2xpY2tJbnRlcnZhbCkge1xuICAgICAgLy8gRG91YmxlIGNsaWNrIGV2ZW50XG4gICAgICB0aGlzLl9sYXN0Q2xpY2tEYXRhID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2RvdWJsZUNsaWNrJywge1xuICAgICAgICB4OiBwYWdlWCxcbiAgICAgICAgeTogcGFnZVksXG4gICAgICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGNsaWVudFlcbiAgICAgIH0pO1xuICAgIH0gLy8gQ2xpY2sgZXZlbnRcblxuXG4gICAgdGhpcy5fbGFzdENsaWNrRGF0YSA9IHtcbiAgICAgIHRpbWVzdGFtcDogbm93XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdjbGljaycsIHtcbiAgICAgIHg6IHBhZ2VYLFxuICAgICAgeTogcGFnZVksXG4gICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlTW92ZUV2ZW50ID0gZnVuY3Rpb24gX2hhbmRsZU1vdmVFdmVudChlKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxFdmVudERhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkX2luaXRpYWxFdmVudERhID0gdGhpcy5faW5pdGlhbEV2ZW50RGF0YSxcbiAgICAgICAgeCA9IF90aGlzJF9pbml0aWFsRXZlbnREYS54LFxuICAgICAgICB5ID0gX3RoaXMkX2luaXRpYWxFdmVudERhLnk7XG5cbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXM0ID0gZ2V0RXZlbnRDb29yZGluYXRlcyhlKSxcbiAgICAgICAgcGFnZVggPSBfZ2V0RXZlbnRDb29yZGluYXRlczQucGFnZVgsXG4gICAgICAgIHBhZ2VZID0gX2dldEV2ZW50Q29vcmRpbmF0ZXM0LnBhZ2VZO1xuXG4gICAgdmFyIHcgPSBNYXRoLmFicyh4IC0gcGFnZVgpO1xuICAgIHZhciBoID0gTWF0aC5hYnMoeSAtIHBhZ2VZKTtcbiAgICB2YXIgbGVmdCA9IE1hdGgubWluKHBhZ2VYLCB4KSxcbiAgICAgICAgdG9wID0gTWF0aC5taW4ocGFnZVksIHkpLFxuICAgICAgICBvbGQgPSB0aGlzLnNlbGVjdGluZzsgLy8gUHJldmVudCBlbWl0dGluZyBzZWxlY3RTdGFydCBldmVudCB1bnRpbCBtb3VzZSBpcyBtb3ZlZC5cbiAgICAvLyBpbiBDaHJvbWUgb24gV2luZG93cywgbW91c2VNb3ZlIGV2ZW50IG1heSBiZSBmaXJlZCBqdXN0IGFmdGVyIG1vdXNlRG93biBldmVudC5cblxuICAgIGlmICh0aGlzLmlzQ2xpY2socGFnZVgsIHBhZ2VZKSAmJiAhb2xkICYmICEodyB8fCBoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3RSZWN0ID0ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgeDogcGFnZVgsXG4gICAgICB5OiBwYWdlWSxcbiAgICAgIHJpZ2h0OiBsZWZ0ICsgdyxcbiAgICAgIGJvdHRvbTogdG9wICsgaFxuICAgIH07XG5cbiAgICBpZiAoIW9sZCkge1xuICAgICAgdGhpcy5lbWl0KCdzZWxlY3RTdGFydCcsIHRoaXMuX2luaXRpYWxFdmVudERhdGEpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NsaWNrKHBhZ2VYLCBwYWdlWSkpIHRoaXMuZW1pdCgnc2VsZWN0aW5nJywgdGhpcy5fc2VsZWN0UmVjdCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIF9wcm90by5fa2V5TGlzdGVuZXIgPSBmdW5jdGlvbiBfa2V5TGlzdGVuZXIoZSkge1xuICAgIHRoaXMuY3RybCA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQ2xpY2sgPSBmdW5jdGlvbiBpc0NsaWNrKHBhZ2VYLCBwYWdlWSkge1xuICAgIHZhciBfdGhpcyRfaW5pdGlhbEV2ZW50RGEyID0gdGhpcy5faW5pdGlhbEV2ZW50RGF0YSxcbiAgICAgICAgeCA9IF90aGlzJF9pbml0aWFsRXZlbnREYTIueCxcbiAgICAgICAgeSA9IF90aGlzJF9pbml0aWFsRXZlbnREYTIueSxcbiAgICAgICAgaXNUb3VjaCA9IF90aGlzJF9pbml0aWFsRXZlbnREYTIuaXNUb3VjaDtcbiAgICByZXR1cm4gIWlzVG91Y2ggJiYgTWF0aC5hYnMocGFnZVggLSB4KSA8PSBjbGlja1RvbGVyYW5jZSAmJiBNYXRoLmFicyhwYWdlWSAtIHkpIDw9IGNsaWNrVG9sZXJhbmNlO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3Rpb247XG59KCk7XG4vKipcbiAqIFJlc29sdmUgdGhlIGRpc2FuY2UgcHJvcCBmcm9tIGVpdGhlciBhbiBJbnQgb3IgYW4gT2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVEaXN0YW5jZShkaXN0YW5jZSkge1xuICBpZiAoZGlzdGFuY2UgPT09IHZvaWQgMCkge1xuICAgIGRpc3RhbmNlID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGlzdGFuY2UgIT09ICdvYmplY3QnKSBkaXN0YW5jZSA9IHtcbiAgICB0b3A6IGRpc3RhbmNlLFxuICAgIGxlZnQ6IGRpc3RhbmNlLFxuICAgIHJpZ2h0OiBkaXN0YW5jZSxcbiAgICBib3R0b206IGRpc3RhbmNlXG4gIH07XG4gIHJldHVybiBkaXN0YW5jZTtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIG9iamVjdHMgY29udGFpbmluZyBcInRvcFwiLCBcImxlZnRcIiwgXCJvZmZzZXRXaWR0aFwiIGFuZCBcIm9mZnNldEhlaWdodFwiXG4gKiBwcm9wZXJ0aWVzLCBkZXRlcm1pbmUgaWYgdGhleSBjb2xsaWRlLlxuICogQHBhcmFtICB7T2JqZWN0fEhUTUxFbGVtZW50fSBhXG4gKiBAcGFyYW0gIHtPYmplY3R8SFRNTEVsZW1lbnR9IGJcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxuXG5mdW5jdGlvbiBvYmplY3RzQ29sbGlkZShub2RlQSwgbm9kZUIsIHRvbGVyYW5jZSkge1xuICBpZiAodG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICB0b2xlcmFuY2UgPSAwO1xuICB9XG5cbiAgdmFyIF9nZXRCb3VuZHNGb3JOb2RlID0gZ2V0Qm91bmRzRm9yTm9kZShub2RlQSksXG4gICAgICBhVG9wID0gX2dldEJvdW5kc0Zvck5vZGUudG9wLFxuICAgICAgYUxlZnQgPSBfZ2V0Qm91bmRzRm9yTm9kZS5sZWZ0LFxuICAgICAgX2dldEJvdW5kc0Zvck5vZGUkcmlnID0gX2dldEJvdW5kc0Zvck5vZGUucmlnaHQsXG4gICAgICBhUmlnaHQgPSBfZ2V0Qm91bmRzRm9yTm9kZSRyaWcgPT09IHZvaWQgMCA/IGFMZWZ0IDogX2dldEJvdW5kc0Zvck5vZGUkcmlnLFxuICAgICAgX2dldEJvdW5kc0Zvck5vZGUkYm90ID0gX2dldEJvdW5kc0Zvck5vZGUuYm90dG9tLFxuICAgICAgYUJvdHRvbSA9IF9nZXRCb3VuZHNGb3JOb2RlJGJvdCA9PT0gdm9pZCAwID8gYVRvcCA6IF9nZXRCb3VuZHNGb3JOb2RlJGJvdDtcblxuICB2YXIgX2dldEJvdW5kc0Zvck5vZGUyID0gZ2V0Qm91bmRzRm9yTm9kZShub2RlQiksXG4gICAgICBiVG9wID0gX2dldEJvdW5kc0Zvck5vZGUyLnRvcCxcbiAgICAgIGJMZWZ0ID0gX2dldEJvdW5kc0Zvck5vZGUyLmxlZnQsXG4gICAgICBfZ2V0Qm91bmRzRm9yTm9kZTIkcmkgPSBfZ2V0Qm91bmRzRm9yTm9kZTIucmlnaHQsXG4gICAgICBiUmlnaHQgPSBfZ2V0Qm91bmRzRm9yTm9kZTIkcmkgPT09IHZvaWQgMCA/IGJMZWZ0IDogX2dldEJvdW5kc0Zvck5vZGUyJHJpLFxuICAgICAgX2dldEJvdW5kc0Zvck5vZGUyJGJvID0gX2dldEJvdW5kc0Zvck5vZGUyLmJvdHRvbSxcbiAgICAgIGJCb3R0b20gPSBfZ2V0Qm91bmRzRm9yTm9kZTIkYm8gPT09IHZvaWQgMCA/IGJUb3AgOiBfZ2V0Qm91bmRzRm9yTm9kZTIkYm87XG5cbiAgcmV0dXJuICEoIC8vICdhJyBib3R0b20gZG9lc24ndCB0b3VjaCAnYicgdG9wXG4gIGFCb3R0b20gLSB0b2xlcmFuY2UgPCBiVG9wIHx8IC8vICdhJyB0b3AgZG9lc24ndCB0b3VjaCAnYicgYm90dG9tXG4gIGFUb3AgKyB0b2xlcmFuY2UgPiBiQm90dG9tIHx8IC8vICdhJyByaWdodCBkb2Vzbid0IHRvdWNoICdiJyBsZWZ0XG4gIGFSaWdodCAtIHRvbGVyYW5jZSA8IGJMZWZ0IHx8IC8vICdhJyBsZWZ0IGRvZXNuJ3QgdG91Y2ggJ2InIHJpZ2h0XG4gIGFMZWZ0ICsgdG9sZXJhbmNlID4gYlJpZ2h0KTtcbn1cbi8qKlxuICogR2l2ZW4gYSBub2RlLCBnZXQgZXZlcnl0aGluZyBuZWVkZWQgdG8gY2FsY3VsYXRlIGl0cyBib3VuZGFyaWVzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldEJvdW5kc0Zvck5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gbm9kZTtcbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgbGVmdCA9IHJlY3QubGVmdCArIHBhZ2VPZmZzZXQoJ2xlZnQnKSxcbiAgICAgIHRvcCA9IHJlY3QudG9wICsgcGFnZU9mZnNldCgndG9wJyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogKG5vZGUub2Zmc2V0V2lkdGggfHwgMCkgKyBsZWZ0LFxuICAgIGJvdHRvbTogKG5vZGUub2Zmc2V0SGVpZ2h0IHx8IDApICsgdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhZ2VPZmZzZXQoZGlyKSB7XG4gIGlmIChkaXIgPT09ICdsZWZ0JykgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbiAgaWYgKGRpciA9PT0gJ3RvcCcpIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcbn1cblxudmFyIEJhY2tncm91bmRDZWxscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShCYWNrZ3JvdW5kQ2VsbHMsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJhY2tncm91bmRDZWxscyhwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc2VsZWN0aW5nOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJhY2tncm91bmRDZWxscy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5wcm9wcy5zZWxlY3RhYmxlICYmIHRoaXMuX3NlbGVjdGFibGUoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl90ZWFyZG93blNlbGVjdGFibGUoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5zZWxlY3RhYmxlICYmICF0aGlzLnByb3BzLnNlbGVjdGFibGUpIHRoaXMuX3NlbGVjdGFibGUoKTtcbiAgICBpZiAoIW5leHRQcm9wcy5zZWxlY3RhYmxlICYmIHRoaXMucHJvcHMuc2VsZWN0YWJsZSkgdGhpcy5fdGVhcmRvd25TZWxlY3RhYmxlKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByYW5nZSQkMSA9IF90aGlzJHByb3BzLnJhbmdlLFxuICAgICAgICBnZXROb3cgPSBfdGhpcyRwcm9wcy5nZXROb3csXG4gICAgICAgIGdldHRlcnMgPSBfdGhpcyRwcm9wcy5nZXR0ZXJzLFxuICAgICAgICBjdXJyZW50RGF0ZSA9IF90aGlzJHByb3BzLmRhdGUsXG4gICAgICAgIFdyYXBwZXIgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLmRhdGVDZWxsV3JhcHBlcjtcbiAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzZWxlY3RpbmcgPSBfdGhpcyRzdGF0ZS5zZWxlY3RpbmcsXG4gICAgICAgIHN0YXJ0SWR4ID0gX3RoaXMkc3RhdGUuc3RhcnRJZHgsXG4gICAgICAgIGVuZElkeCA9IF90aGlzJHN0YXRlLmVuZElkeDtcbiAgICB2YXIgY3VycmVudCA9IGdldE5vdygpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtcm93LWJnXCJcbiAgICB9LCByYW5nZSQkMS5tYXAoZnVuY3Rpb24gKGRhdGUsIGluZGV4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RpbmcgJiYgaW5kZXggPj0gc3RhcnRJZHggJiYgaW5kZXggPD0gZW5kSWR4O1xuXG4gICAgICB2YXIgX2dldHRlcnMkZGF5UHJvcCA9IGdldHRlcnMuZGF5UHJvcChkYXRlKSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfZ2V0dGVycyRkYXlQcm9wLmNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZSA9IF9nZXR0ZXJzJGRheVByb3Auc3R5bGU7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXIsIHtcbiAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgdmFsdWU6IGRhdGUsXG4gICAgICAgIHJhbmdlOiByYW5nZSQkMVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbigncmJjLWRheS1iZycsIGNsYXNzTmFtZSwgc2VsZWN0ZWQgJiYgJ3JiYy1zZWxlY3RlZC1jZWxsJywgZGF0ZXMuZXEoZGF0ZSwgY3VycmVudCwgJ2RheScpICYmICdyYmMtdG9kYXknLCBjdXJyZW50RGF0ZSAmJiBkYXRlcy5tb250aChjdXJyZW50RGF0ZSkgIT09IGRhdGVzLm1vbnRoKGRhdGUpICYmICdyYmMtb2ZmLXJhbmdlLWJnJylcbiAgICAgIH0pKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLl9zZWxlY3RhYmxlID0gZnVuY3Rpb24gX3NlbGVjdGFibGUoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuX3NlbGVjdG9yID0gbmV3IFNlbGVjdGlvbih0aGlzLnByb3BzLmNvbnRhaW5lciwge1xuICAgICAgbG9uZ1ByZXNzVGhyZXNob2xkOiB0aGlzLnByb3BzLmxvbmdQcmVzc1RocmVzaG9sZFxuICAgIH0pO1xuXG4gICAgdmFyIHNlbGVjdG9yQ2xpY2tzSGFuZGxlciA9IGZ1bmN0aW9uIHNlbGVjdG9yQ2xpY2tzSGFuZGxlcihwb2ludCwgYWN0aW9uVHlwZSkge1xuICAgICAgaWYgKCFpc0V2ZW50KGZpbmRET01Ob2RlKF90aGlzMiksIHBvaW50KSkge1xuICAgICAgICB2YXIgcm93Qm94ID0gZ2V0Qm91bmRzRm9yTm9kZShub2RlKTtcbiAgICAgICAgdmFyIF90aGlzMiRwcm9wcyA9IF90aGlzMi5wcm9wcyxcbiAgICAgICAgICAgIHJhbmdlJCQxID0gX3RoaXMyJHByb3BzLnJhbmdlLFxuICAgICAgICAgICAgcnRsID0gX3RoaXMyJHByb3BzLnJ0bDtcblxuICAgICAgICBpZiAocG9pbnRJbkJveChyb3dCb3gsIHBvaW50KSkge1xuICAgICAgICAgIHZhciBjdXJyZW50Q2VsbCA9IGdldFNsb3RBdFgocm93Qm94LCBwb2ludC54LCBydGwsIHJhbmdlJCQxLmxlbmd0aCk7XG5cbiAgICAgICAgICBfdGhpczIuX3NlbGVjdFNsb3Qoe1xuICAgICAgICAgICAgc3RhcnRJZHg6IGN1cnJlbnRDZWxsLFxuICAgICAgICAgICAgZW5kSWR4OiBjdXJyZW50Q2VsbCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uVHlwZSxcbiAgICAgICAgICAgIGJveDogcG9pbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpczIuX2luaXRpYWwgPSB7fTtcblxuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgc2VsZWN0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbGVjdG9yLm9uKCdzZWxlY3RpbmcnLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICB2YXIgX3RoaXMyJHByb3BzMiA9IF90aGlzMi5wcm9wcyxcbiAgICAgICAgICByYW5nZSQkMSA9IF90aGlzMiRwcm9wczIucmFuZ2UsXG4gICAgICAgICAgcnRsID0gX3RoaXMyJHByb3BzMi5ydGw7XG4gICAgICB2YXIgc3RhcnRJZHggPSAtMTtcbiAgICAgIHZhciBlbmRJZHggPSAtMTtcblxuICAgICAgaWYgKCFfdGhpczIuc3RhdGUuc2VsZWN0aW5nKSB7XG4gICAgICAgIG5vdGlmeShfdGhpczIucHJvcHMub25TZWxlY3RTdGFydCwgW2JveF0pO1xuICAgICAgICBfdGhpczIuX2luaXRpYWwgPSB7XG4gICAgICAgICAgeDogYm94LngsXG4gICAgICAgICAgeTogYm94LnlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yLmlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgdmFyIG5vZGVCb3ggPSBnZXRCb3VuZHNGb3JOb2RlKG5vZGUpO1xuXG4gICAgICAgIHZhciBfZGF0ZUNlbGxTZWxlY3Rpb24gPSBkYXRlQ2VsbFNlbGVjdGlvbihfdGhpczIuX2luaXRpYWwsIG5vZGVCb3gsIGJveCwgcmFuZ2UkJDEubGVuZ3RoLCBydGwpO1xuXG4gICAgICAgIHN0YXJ0SWR4ID0gX2RhdGVDZWxsU2VsZWN0aW9uLnN0YXJ0SWR4O1xuICAgICAgICBlbmRJZHggPSBfZGF0ZUNlbGxTZWxlY3Rpb24uZW5kSWR4O1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgIHN0YXJ0SWR4OiBzdGFydElkeCxcbiAgICAgICAgZW5kSWR4OiBlbmRJZHhcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNlbGVjdG9yLm9uKCdiZWZvcmVTZWxlY3QnLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICBpZiAoX3RoaXMyLnByb3BzLnNlbGVjdGFibGUgIT09ICdpZ25vcmVFdmVudHMnKSByZXR1cm47XG4gICAgICByZXR1cm4gIWlzRXZlbnQoZmluZERPTU5vZGUoX3RoaXMyKSwgYm94KTtcbiAgICB9KTtcbiAgICBzZWxlY3Rvci5vbignY2xpY2snLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckNsaWNrc0hhbmRsZXIocG9pbnQsICdjbGljaycpO1xuICAgIH0pO1xuICAgIHNlbGVjdG9yLm9uKCdkb3VibGVDbGljaycsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yQ2xpY2tzSGFuZGxlcihwb2ludCwgJ2RvdWJsZUNsaWNrJyk7XG4gICAgfSk7XG4gICAgc2VsZWN0b3Iub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgIF90aGlzMi5fc2VsZWN0U2xvdChfZXh0ZW5kcyh7fSwgX3RoaXMyLnN0YXRlLCB7XG4gICAgICAgIGFjdGlvbjogJ3NlbGVjdCcsXG4gICAgICAgIGJvdW5kczogYm91bmRzXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzMi5faW5pdGlhbCA9IHt9O1xuXG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3Rpbmc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgbm90aWZ5KF90aGlzMi5wcm9wcy5vblNlbGVjdEVuZCwgW190aGlzMi5zdGF0ZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fdGVhcmRvd25TZWxlY3RhYmxlID0gZnVuY3Rpb24gX3RlYXJkb3duU2VsZWN0YWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdG9yKSByZXR1cm47XG5cbiAgICB0aGlzLl9zZWxlY3Rvci50ZWFyZG93bigpO1xuXG4gICAgdGhpcy5fc2VsZWN0b3IgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fc2VsZWN0U2xvdCA9IGZ1bmN0aW9uIF9zZWxlY3RTbG90KF9yZWYpIHtcbiAgICB2YXIgZW5kSWR4ID0gX3JlZi5lbmRJZHgsXG4gICAgICAgIHN0YXJ0SWR4ID0gX3JlZi5zdGFydElkeCxcbiAgICAgICAgYWN0aW9uID0gX3JlZi5hY3Rpb24sXG4gICAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgICBib3ggPSBfcmVmLmJveDtcbiAgICBpZiAoZW5kSWR4ICE9PSAtMSAmJiBzdGFydElkeCAhPT0gLTEpIHRoaXMucHJvcHMub25TZWxlY3RTbG90ICYmIHRoaXMucHJvcHMub25TZWxlY3RTbG90KHtcbiAgICAgIHN0YXJ0OiBzdGFydElkeCxcbiAgICAgIGVuZDogZW5kSWR4LFxuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgIGJveDogYm94XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJhY2tncm91bmRDZWxscztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQmFja2dyb3VuZENlbGxzLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZGF0ZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSksXG4gIGdldE5vdzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0dGVyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGRheVByb3BHZXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBzZWxlY3RhYmxlOiBQcm9wVHlwZXMub25lT2YoW3RydWUsIGZhbHNlLCAnaWdub3JlRXZlbnRzJ10pLFxuICBsb25nUHJlc3NUaHJlc2hvbGQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uU2VsZWN0U2xvdDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25TZWxlY3RFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcmFuZ2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpKSxcbiAgcnRsOiBQcm9wVHlwZXMuYm9vbCxcbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZ1xufSA6IHt9O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG5cbnZhciBFdmVudFJvd01peGluID0ge1xuICBwcm9wVHlwZXM6IHtcbiAgICBzbG90TWV0cmljczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGlzQWxsRGF5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhY2Nlc3NvcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBsb2NhbGl6ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgZ2V0dGVyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRvdWJsZUNsaWNrOiBQcm9wVHlwZXMuZnVuY1xuICB9LFxuICBkZWZhdWx0UHJvcHM6IHtcbiAgICBzZWdtZW50czogW10sXG4gICAgc2VsZWN0ZWQ6IHt9XG4gIH0sXG4gIHJlbmRlckV2ZW50OiBmdW5jdGlvbiByZW5kZXJFdmVudChwcm9wcywgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgXyA9IHByb3BzLmlzQWxsRGF5LFxuICAgICAgICBhY2Nlc3NvcnMgPSBwcm9wcy5hY2Nlc3NvcnMsXG4gICAgICAgIGdldHRlcnMgPSBwcm9wcy5nZXR0ZXJzLFxuICAgICAgICBvblNlbGVjdCA9IHByb3BzLm9uU2VsZWN0LFxuICAgICAgICBvbkRvdWJsZUNsaWNrID0gcHJvcHMub25Eb3VibGVDbGljayxcbiAgICAgICAgbG9jYWxpemVyID0gcHJvcHMubG9jYWxpemVyLFxuICAgICAgICBzbG90TWV0cmljcyA9IHByb3BzLnNsb3RNZXRyaWNzLFxuICAgICAgICBjb21wb25lbnRzID0gcHJvcHMuY29tcG9uZW50cztcbiAgICB2YXIgY29udGludWVzUHJpb3IgPSBzbG90TWV0cmljcy5jb250aW51ZXNQcmlvcihldmVudCk7XG4gICAgdmFyIGNvbnRpbnVlc0FmdGVyID0gc2xvdE1ldHJpY3MuY29udGludWVzQWZ0ZXIoZXZlbnQpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50Q2VsbCwge1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgZ2V0dGVyczogZ2V0dGVycyxcbiAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgb25TZWxlY3Q6IG9uU2VsZWN0LFxuICAgICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICAgIGNvbnRpbnVlc1ByaW9yOiBjb250aW51ZXNQcmlvcixcbiAgICAgIGNvbnRpbnVlc0FmdGVyOiBjb250aW51ZXNBZnRlcixcbiAgICAgIHNlbGVjdGVkOiBpc1NlbGVjdGVkKGV2ZW50LCBzZWxlY3RlZClcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyU3BhbjogZnVuY3Rpb24gcmVuZGVyU3BhbihzbG90cywgbGVuLCBrZXksIGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250ZW50ID0gJyAnO1xuICAgIH1cblxuICAgIHZhciBwZXIgPSBNYXRoLmFicyhsZW4pIC8gc2xvdHMgKiAxMDAgKyAnJSc7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBrZXksXG4gICAgICBjbGFzc05hbWU6IFwicmJjLXJvdy1zZWdtZW50XCIgLy8gSUUxMC8xMSBuZWVkIG1heC13aWR0aC4gZmxleC1iYXNpcyBkb2Vzbid0IHJlc3BlY3QgYm94LXNpemluZ1xuICAgICAgLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgV2Via2l0RmxleEJhc2lzOiBwZXIsXG4gICAgICAgIGZsZXhCYXNpczogcGVyLFxuICAgICAgICBtYXhXaWR0aDogcGVyXG4gICAgICB9XG4gICAgfSwgY29udGVudCk7XG4gIH1cbn07XG5cbnZhciBFdmVudFJvdyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFdmVudFJvdywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXZlbnRSb3coKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV2ZW50Um93LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzZWdtZW50cyA9IF90aGlzJHByb3BzLnNlZ21lbnRzLFxuICAgICAgICBzbG90cyA9IF90aGlzJHByb3BzLnNsb3RNZXRyaWNzLnNsb3RzLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWU7XG4gICAgdmFyIGxhc3RFbmQgPSAxO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY24oY2xhc3NOYW1lLCAncmJjLXJvdycpXG4gICAgfSwgc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChyb3csIF9yZWYsIGxpKSB7XG4gICAgICB2YXIgZXZlbnQgPSBfcmVmLmV2ZW50LFxuICAgICAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICAgICAgcmlnaHQgPSBfcmVmLnJpZ2h0LFxuICAgICAgICAgIHNwYW4gPSBfcmVmLnNwYW47XG4gICAgICB2YXIga2V5ID0gJ19sdmxfJyArIGxpO1xuICAgICAgdmFyIGdhcCA9IGxlZnQgLSBsYXN0RW5kO1xuICAgICAgdmFyIGNvbnRlbnQgPSBFdmVudFJvd01peGluLnJlbmRlckV2ZW50KF90aGlzLnByb3BzLCBldmVudCk7XG4gICAgICBpZiAoZ2FwKSByb3cucHVzaChFdmVudFJvd01peGluLnJlbmRlclNwYW4oc2xvdHMsIGdhcCwga2V5ICsgXCJfZ2FwXCIpKTtcbiAgICAgIHJvdy5wdXNoKEV2ZW50Um93TWl4aW4ucmVuZGVyU3BhbihzbG90cywgc3Bhbiwga2V5LCBjb250ZW50KSk7XG4gICAgICBsYXN0RW5kID0gcmlnaHQgKyAxO1xuICAgICAgcmV0dXJuIHJvdztcbiAgICB9LCBbXSkpO1xuICB9O1xuXG4gIHJldHVybiBFdmVudFJvdztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRXZlbnRSb3cucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gX2V4dGVuZHMoe1xuICBzZWdtZW50czogUHJvcFR5cGVzLmFycmF5XG59LCBFdmVudFJvd01peGluLnByb3BUeXBlcykgOiB7fTtcbkV2ZW50Um93LmRlZmF1bHRQcm9wcyA9IF9leHRlbmRzKHt9LCBFdmVudFJvd01peGluLmRlZmF1bHRQcm9wcyk7XG5cbmZ1bmN0aW9uIGVuZE9mUmFuZ2UoZGF0ZVJhbmdlLCB1bml0KSB7XG4gIGlmICh1bml0ID09PSB2b2lkIDApIHtcbiAgICB1bml0ID0gJ2RheSc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpcnN0OiBkYXRlUmFuZ2VbMF0sXG4gICAgbGFzdDogZGF0ZXMuYWRkKGRhdGVSYW5nZVtkYXRlUmFuZ2UubGVuZ3RoIC0gMV0sIDEsIHVuaXQpXG4gIH07XG59XG5mdW5jdGlvbiBldmVudFNlZ21lbnRzKGV2ZW50LCByYW5nZSQkMSwgYWNjZXNzb3JzKSB7XG4gIHZhciBfZW5kT2ZSYW5nZSA9IGVuZE9mUmFuZ2UocmFuZ2UkJDEpLFxuICAgICAgZmlyc3QgPSBfZW5kT2ZSYW5nZS5maXJzdCxcbiAgICAgIGxhc3QgPSBfZW5kT2ZSYW5nZS5sYXN0O1xuXG4gIHZhciBzbG90cyA9IGRhdGVzLmRpZmYoZmlyc3QsIGxhc3QsICdkYXknKTtcbiAgdmFyIHN0YXJ0ID0gZGF0ZXMubWF4KGRhdGVzLnN0YXJ0T2YoYWNjZXNzb3JzLnN0YXJ0KGV2ZW50KSwgJ2RheScpLCBmaXJzdCk7XG4gIHZhciBlbmQgPSBkYXRlcy5taW4oZGF0ZXMuY2VpbChhY2Nlc3NvcnMuZW5kKGV2ZW50KSwgJ2RheScpLCBsYXN0KTtcbiAgdmFyIHBhZGRpbmcgPSBmaW5kSW5kZXgocmFuZ2UkJDEsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGRhdGVzLmVxKHgsIHN0YXJ0LCAnZGF5Jyk7XG4gIH0pO1xuICB2YXIgc3BhbiA9IGRhdGVzLmRpZmYoc3RhcnQsIGVuZCwgJ2RheScpO1xuICBzcGFuID0gTWF0aC5taW4oc3Bhbiwgc2xvdHMpO1xuICBzcGFuID0gTWF0aC5tYXgoc3BhbiwgMSk7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIHNwYW46IHNwYW4sXG4gICAgbGVmdDogcGFkZGluZyArIDEsXG4gICAgcmlnaHQ6IE1hdGgubWF4KHBhZGRpbmcgKyBzcGFuLCAxKVxuICB9O1xufVxuZnVuY3Rpb24gZXZlbnRMZXZlbHMocm93U2VnbWVudHMsIGxpbWl0KSB7XG4gIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgbGltaXQgPSBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBpLFxuICAgICAgaixcbiAgICAgIHNlZyxcbiAgICAgIGxldmVscyA9IFtdLFxuICAgICAgZXh0cmEgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcm93U2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBzZWcgPSByb3dTZWdtZW50c1tpXTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICghc2Vnc092ZXJsYXAoc2VnLCBsZXZlbHNbal0pKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaiA+PSBsaW1pdCkge1xuICAgICAgZXh0cmEucHVzaChzZWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV2ZWxzW2ldLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XG4gICAgfSk7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZXZlbHM6IGxldmVscyxcbiAgICBleHRyYTogZXh0cmFcbiAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoZSwgc3RhcnQsIGVuZCwgYWNjZXNzb3JzKSB7XG4gIHZhciBlU3RhcnQgPSBkYXRlcy5zdGFydE9mKGFjY2Vzc29ycy5zdGFydChlKSwgJ2RheScpO1xuICB2YXIgZUVuZCA9IGFjY2Vzc29ycy5lbmQoZSk7XG4gIHZhciBzdGFydHNCZWZvcmVFbmQgPSBkYXRlcy5sdGUoZVN0YXJ0LCBlbmQsICdkYXknKTsgLy8gd2hlbiB0aGUgZXZlbnQgaXMgemVybyBkdXJhdGlvbiB3ZSBuZWVkIHRvIGhhbmRsZSBhIGJpdCBkaWZmZXJlbnRseVxuXG4gIHZhciBlbmRzQWZ0ZXJTdGFydCA9ICFkYXRlcy5lcShlU3RhcnQsIGVFbmQsICdtaW51dGVzJykgPyBkYXRlcy5ndChlRW5kLCBzdGFydCwgJ21pbnV0ZXMnKSA6IGRhdGVzLmd0ZShlRW5kLCBzdGFydCwgJ21pbnV0ZXMnKTtcbiAgcmV0dXJuIHN0YXJ0c0JlZm9yZUVuZCAmJiBlbmRzQWZ0ZXJTdGFydDtcbn1cbmZ1bmN0aW9uIHNlZ3NPdmVybGFwKHNlZywgb3RoZXJTZWdzKSB7XG4gIHJldHVybiBvdGhlclNlZ3Muc29tZShmdW5jdGlvbiAob3RoZXJTZWcpIHtcbiAgICByZXR1cm4gb3RoZXJTZWcubGVmdCA8PSBzZWcucmlnaHQgJiYgb3RoZXJTZWcucmlnaHQgPj0gc2VnLmxlZnQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50cyhldnRBLCBldnRCLCBhY2Nlc3NvcnMpIHtcbiAgdmFyIHN0YXJ0U29ydCA9ICtkYXRlcy5zdGFydE9mKGFjY2Vzc29ycy5zdGFydChldnRBKSwgJ2RheScpIC0gK2RhdGVzLnN0YXJ0T2YoYWNjZXNzb3JzLnN0YXJ0KGV2dEIpLCAnZGF5Jyk7XG4gIHZhciBkdXJBID0gZGF0ZXMuZGlmZihhY2Nlc3NvcnMuc3RhcnQoZXZ0QSksIGRhdGVzLmNlaWwoYWNjZXNzb3JzLmVuZChldnRBKSwgJ2RheScpLCAnZGF5Jyk7XG4gIHZhciBkdXJCID0gZGF0ZXMuZGlmZihhY2Nlc3NvcnMuc3RhcnQoZXZ0QiksIGRhdGVzLmNlaWwoYWNjZXNzb3JzLmVuZChldnRCKSwgJ2RheScpLCAnZGF5Jyk7XG4gIHJldHVybiBzdGFydFNvcnQgfHwgLy8gc29ydCBieSBzdGFydCBEYXkgZmlyc3RcbiAgTWF0aC5tYXgoZHVyQiwgMSkgLSBNYXRoLm1heChkdXJBLCAxKSB8fCAvLyBldmVudHMgc3Bhbm5pbmcgbXVsdGlwbGUgZGF5cyBnbyBmaXJzdFxuICAhIWFjY2Vzc29ycy5hbGxEYXkoZXZ0QikgLSAhIWFjY2Vzc29ycy5hbGxEYXkoZXZ0QSkgfHwgLy8gdGhlbiBhbGxEYXkgc2luZ2xlIGRheSBldmVudHNcbiAgK2FjY2Vzc29ycy5zdGFydChldnRBKSAtICthY2Nlc3NvcnMuc3RhcnQoZXZ0Qik7IC8vIHRoZW4gc29ydCBieSBzdGFydCB0aW1lXG59XG5cbnZhciBpc1NlZ21lbnRJblNsb3QgPSBmdW5jdGlvbiBpc1NlZ21lbnRJblNsb3Qoc2VnLCBzbG90KSB7XG4gIHJldHVybiBzZWcubGVmdCA8PSBzbG90ICYmIHNlZy5yaWdodCA+PSBzbG90O1xufTtcblxudmFyIGV2ZW50c0luU2xvdCA9IGZ1bmN0aW9uIGV2ZW50c0luU2xvdChzZWdtZW50cywgc2xvdCkge1xuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcbiAgICByZXR1cm4gaXNTZWdtZW50SW5TbG90KHNlZywgc2xvdCk7XG4gIH0pLmxlbmd0aDtcbn07XG5cbnZhciBFdmVudEVuZGluZ1JvdyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFdmVudEVuZGluZ1JvdywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXZlbnRFbmRpbmdSb3coKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV2ZW50RW5kaW5nUm93LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHNlZ21lbnRzID0gX3RoaXMkcHJvcHMuc2VnbWVudHMsXG4gICAgICAgIHNsb3RzID0gX3RoaXMkcHJvcHMuc2xvdE1ldHJpY3Muc2xvdHM7XG4gICAgdmFyIHJvd1NlZ21lbnRzID0gZXZlbnRMZXZlbHMoc2VnbWVudHMpLmxldmVsc1swXTtcbiAgICB2YXIgY3VycmVudCA9IDEsXG4gICAgICAgIGxhc3RFbmQgPSAxLFxuICAgICAgICByb3cgPSBbXTtcblxuICAgIHdoaWxlIChjdXJyZW50IDw9IHNsb3RzKSB7XG4gICAgICB2YXIga2V5ID0gJ19sdmxfJyArIGN1cnJlbnQ7XG5cbiAgICAgIHZhciBfcmVmID0gcm93U2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgcmV0dXJuIGlzU2VnbWVudEluU2xvdChzZWcsIGN1cnJlbnQpO1xuICAgICAgfSlbMF0gfHwge30sXG4gICAgICAgICAgZXZlbnQgPSBfcmVmLmV2ZW50LFxuICAgICAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICAgICAgcmlnaHQgPSBfcmVmLnJpZ2h0LFxuICAgICAgICAgIHNwYW4gPSBfcmVmLnNwYW47IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgY3VycmVudCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdhcCA9IE1hdGgubWF4KDAsIGxlZnQgLSBsYXN0RW5kKTtcblxuICAgICAgaWYgKHRoaXMuY2FuUmVuZGVyU2xvdEV2ZW50KGxlZnQsIHNwYW4pKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gRXZlbnRSb3dNaXhpbi5yZW5kZXJFdmVudCh0aGlzLnByb3BzLCBldmVudCk7XG5cbiAgICAgICAgaWYgKGdhcCkge1xuICAgICAgICAgIHJvdy5wdXNoKEV2ZW50Um93TWl4aW4ucmVuZGVyU3BhbihzbG90cywgZ2FwLCBrZXkgKyAnX2dhcCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvdy5wdXNoKEV2ZW50Um93TWl4aW4ucmVuZGVyU3BhbihzbG90cywgc3Bhbiwga2V5LCBjb250ZW50KSk7XG4gICAgICAgIGxhc3RFbmQgPSBjdXJyZW50ID0gcmlnaHQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdhcCkge1xuICAgICAgICAgIHJvdy5wdXNoKEV2ZW50Um93TWl4aW4ucmVuZGVyU3BhbihzbG90cywgZ2FwLCBrZXkgKyAnX2dhcCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvdy5wdXNoKEV2ZW50Um93TWl4aW4ucmVuZGVyU3BhbihzbG90cywgMSwga2V5LCB0aGlzLnJlbmRlclNob3dNb3JlKHNlZ21lbnRzLCBjdXJyZW50KSkpO1xuICAgICAgICBsYXN0RW5kID0gY3VycmVudCA9IGN1cnJlbnQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtcm93XCJcbiAgICB9LCByb3cpO1xuICB9O1xuXG4gIF9wcm90by5jYW5SZW5kZXJTbG90RXZlbnQgPSBmdW5jdGlvbiBjYW5SZW5kZXJTbG90RXZlbnQoc2xvdCwgc3Bhbikge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMucHJvcHMuc2VnbWVudHM7XG4gICAgcmV0dXJuIHJhbmdlKHNsb3QsIHNsb3QgKyBzcGFuKS5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgdmFyIGNvdW50ID0gZXZlbnRzSW5TbG90KHNlZ21lbnRzLCBzKTtcbiAgICAgIHJldHVybiBjb3VudCA9PT0gMTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyU2hvd01vcmUgPSBmdW5jdGlvbiByZW5kZXJTaG93TW9yZShzZWdtZW50cywgc2xvdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbG9jYWxpemVyID0gdGhpcy5wcm9wcy5sb2NhbGl6ZXI7XG4gICAgdmFyIGNvdW50ID0gZXZlbnRzSW5TbG90KHNlZ21lbnRzLCBzbG90KTtcbiAgICByZXR1cm4gY291bnQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICBrZXk6ICdzbV8nICsgc2xvdCxcbiAgICAgIGhyZWY6IFwiI1wiLFxuICAgICAgY2xhc3NOYW1lOiAncmJjLXNob3ctbW9yZScsXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNob3dNb3JlKHNsb3QsIGUpO1xuICAgICAgfVxuICAgIH0sIGxvY2FsaXplci5tZXNzYWdlcy5zaG93TW9yZShjb3VudCkpIDogZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnNob3dNb3JlID0gZnVuY3Rpb24gc2hvd01vcmUoc2xvdCwgZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnByb3BzLm9uU2hvd01vcmUoc2xvdCk7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RW5kaW5nUm93O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5FdmVudEVuZGluZ1Jvdy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfZXh0ZW5kcyh7XG4gIHNlZ21lbnRzOiBQcm9wVHlwZXMuYXJyYXksXG4gIHNsb3RzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvblNob3dNb3JlOiBQcm9wVHlwZXMuZnVuY1xufSwgRXZlbnRSb3dNaXhpbi5wcm9wVHlwZXMpIDoge307XG5FdmVudEVuZGluZ1Jvdy5kZWZhdWx0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgRXZlbnRSb3dNaXhpbi5kZWZhdWx0UHJvcHMpO1xuXG52YXIgaXNTZWdtZW50SW5TbG90JDEgPSBmdW5jdGlvbiBpc1NlZ21lbnRJblNsb3Qoc2VnLCBzbG90KSB7XG4gIHJldHVybiBzZWcubGVmdCA8PSBzbG90ICYmIHNlZy5yaWdodCA+PSBzbG90O1xufTtcblxudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucmFuZ2UgPT09IGIucmFuZ2UgJiYgYS5ldmVudHMgPT09IGIuZXZlbnRzO1xufTtcblxuZnVuY3Rpb24gZ2V0U2xvdE1ldHJpY3MoKSB7XG4gIHJldHVybiBtZW1vaXplKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHJhbmdlJCQxID0gb3B0aW9ucy5yYW5nZSxcbiAgICAgICAgZXZlbnRzJCQxID0gb3B0aW9ucy5ldmVudHMsXG4gICAgICAgIG1heFJvd3MgPSBvcHRpb25zLm1heFJvd3MsXG4gICAgICAgIG1pblJvd3MgPSBvcHRpb25zLm1pblJvd3MsXG4gICAgICAgIGFjY2Vzc29ycyA9IG9wdGlvbnMuYWNjZXNzb3JzO1xuXG4gICAgdmFyIF9lbmRPZlJhbmdlID0gZW5kT2ZSYW5nZShyYW5nZSQkMSksXG4gICAgICAgIGZpcnN0ID0gX2VuZE9mUmFuZ2UuZmlyc3QsXG4gICAgICAgIGxhc3QgPSBfZW5kT2ZSYW5nZS5sYXN0O1xuXG4gICAgdmFyIHNlZ21lbnRzID0gZXZlbnRzJCQxLm1hcChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICByZXR1cm4gZXZlbnRTZWdtZW50cyhldnQsIHJhbmdlJCQxLCBhY2Nlc3NvcnMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9ldmVudExldmVscyA9IGV2ZW50TGV2ZWxzKHNlZ21lbnRzLCBNYXRoLm1heChtYXhSb3dzIC0gMSwgMSkpLFxuICAgICAgICBsZXZlbHMgPSBfZXZlbnRMZXZlbHMubGV2ZWxzLFxuICAgICAgICBleHRyYSA9IF9ldmVudExldmVscy5leHRyYTtcblxuICAgIHdoaWxlIChsZXZlbHMubGVuZ3RoIDwgbWluUm93cykge1xuICAgICAgbGV2ZWxzLnB1c2goW10pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogZmlyc3QsXG4gICAgICBsYXN0OiBsYXN0LFxuICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICBleHRyYTogZXh0cmEsXG4gICAgICByYW5nZTogcmFuZ2UkJDEsXG4gICAgICBzbG90czogcmFuZ2UkJDEubGVuZ3RoLFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGFyZ3MpIHtcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBnZXRTbG90TWV0cmljcygpO1xuICAgICAgICByZXR1cm4gbWV0cmljcyhfZXh0ZW5kcyh7fSwgb3B0aW9ucywgYXJncykpO1xuICAgICAgfSxcbiAgICAgIGdldERhdGVGb3JTbG90OiBmdW5jdGlvbiBnZXREYXRlRm9yU2xvdChzbG90TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiByYW5nZSQkMVtzbG90TnVtYmVyXTtcbiAgICAgIH0sXG4gICAgICBnZXRTbG90Rm9yRGF0ZTogZnVuY3Rpb24gZ2V0U2xvdEZvckRhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UkJDEuZmluZChmdW5jdGlvbiAocikge1xuICAgICAgICAgIHJldHVybiBkYXRlcy5lcShyLCBkYXRlLCAnZGF5Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldEV2ZW50c0ZvclNsb3Q6IGZ1bmN0aW9uIGdldEV2ZW50c0ZvclNsb3Qoc2xvdCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICByZXR1cm4gaXNTZWdtZW50SW5TbG90JDEoc2VnLCBzbG90KTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICByZXR1cm4gc2VnLmV2ZW50O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjb250aW51ZXNQcmlvcjogZnVuY3Rpb24gY29udGludWVzUHJpb3IoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVzLmx0KGFjY2Vzc29ycy5zdGFydChldmVudCksIGZpcnN0LCAnZGF5Jyk7XG4gICAgICB9LFxuICAgICAgY29udGludWVzQWZ0ZXI6IGZ1bmN0aW9uIGNvbnRpbnVlc0FmdGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudEVuZCA9IGFjY2Vzc29ycy5lbmQoZXZlbnQpO1xuICAgICAgICB2YXIgc2luZ2xlRGF5RHVyYXRpb24gPSBkYXRlcy5lcShhY2Nlc3NvcnMuc3RhcnQoZXZlbnQpLCBldmVudEVuZCwgJ21pbnV0ZXMnKTtcbiAgICAgICAgcmV0dXJuIHNpbmdsZURheUR1cmF0aW9uID8gZGF0ZXMuZ3RlKGV2ZW50RW5kLCBsYXN0LCAnbWludXRlcycpIDogZGF0ZXMuZ3QoZXZlbnRFbmQsIGxhc3QsICdtaW51dGVzJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgaXNFcXVhbCk7XG59XG5cbnZhciBEYXRlQ29udGVudFJvdyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShEYXRlQ29udGVudFJvdywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGF0ZUNvbnRlbnRSb3coKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVTZWxlY3RTbG90ID0gZnVuY3Rpb24gKHNsb3QpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHJhbmdlJCQxID0gX3RoaXMkcHJvcHMucmFuZ2UsXG4gICAgICAgICAgb25TZWxlY3RTbG90ID0gX3RoaXMkcHJvcHMub25TZWxlY3RTbG90O1xuICAgICAgb25TZWxlY3RTbG90KHJhbmdlJCQxLnNsaWNlKHNsb3Quc3RhcnQsIHNsb3QuZW5kICsgMSksIHNsb3QpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVTaG93TW9yZSA9IGZ1bmN0aW9uIChzbG90KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgcmFuZ2UkJDEgPSBfdGhpcyRwcm9wczIucmFuZ2UsXG4gICAgICAgICAgb25TaG93TW9yZSA9IF90aGlzJHByb3BzMi5vblNob3dNb3JlO1xuXG4gICAgICB2YXIgbWV0cmljcyA9IF90aGlzLnNsb3RNZXRyaWNzKF90aGlzLnByb3BzKTtcblxuICAgICAgdmFyIHJvdyA9IHFzYShmaW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSksICcucmJjLXJvdy1iZycpWzBdO1xuICAgICAgdmFyIGNlbGw7XG4gICAgICBpZiAocm93KSBjZWxsID0gcm93LmNoaWxkcmVuW3Nsb3QgLSAxXTtcbiAgICAgIHZhciBldmVudHMkJDEgPSBtZXRyaWNzLmdldEV2ZW50c0ZvclNsb3Qoc2xvdCk7XG4gICAgICBvblNob3dNb3JlKGV2ZW50cyQkMSwgcmFuZ2UkJDFbc2xvdCAtIDFdLCBjZWxsLCBzbG90KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlSGVhZGluZ1JlZiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICBfdGhpcy5oZWFkaW5nUm93ID0gcjtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlRXZlbnRSZWYgPSBmdW5jdGlvbiAocikge1xuICAgICAgX3RoaXMuZXZlbnRSb3cgPSByO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMucHJvcHMuY29udGFpbmVyO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lciA/IGNvbnRhaW5lcigpIDogZmluZERPTU5vZGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJIZWFkaW5nQ2VsbCA9IGZ1bmN0aW9uIChkYXRlLCBpbmRleCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHJlbmRlckhlYWRlciA9IF90aGlzJHByb3BzMy5yZW5kZXJIZWFkZXIsXG4gICAgICAgICAgZ2V0Tm93ID0gX3RoaXMkcHJvcHMzLmdldE5vdztcbiAgICAgIHJldHVybiByZW5kZXJIZWFkZXIoe1xuICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICBrZXk6IFwiaGVhZGVyX1wiICsgaW5kZXgsXG4gICAgICAgIGNsYXNzTmFtZTogY24oJ3JiYy1kYXRlLWNlbGwnLCBkYXRlcy5lcShkYXRlLCBnZXROb3coKSwgJ2RheScpICYmICdyYmMtbm93JylcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJEdW1teSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczQuY2xhc3NOYW1lLFxuICAgICAgICAgIHJhbmdlJCQxID0gX3RoaXMkcHJvcHM0LnJhbmdlLFxuICAgICAgICAgIHJlbmRlckhlYWRlciA9IF90aGlzJHByb3BzNC5yZW5kZXJIZWFkZXI7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3ctY29udGVudFwiXG4gICAgICB9LCByZW5kZXJIZWFkZXIgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyYmMtcm93XCIsXG4gICAgICAgIHJlZjogX3RoaXMuY3JlYXRlSGVhZGluZ1JlZlxuICAgICAgfSwgcmFuZ2UkJDEubWFwKF90aGlzLnJlbmRlckhlYWRpbmdDZWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmJjLXJvd1wiLFxuICAgICAgICByZWY6IF90aGlzLmNyZWF0ZUV2ZW50UmVmXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3ctc2VnbWVudFwiXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1ldmVudFwiXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1ldmVudC1jb250ZW50XCJcbiAgICAgIH0sIFwiXFx4QTBcIikpKSkpKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2xvdE1ldHJpY3MgPSBnZXRTbG90TWV0cmljcygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXRlQ29udGVudFJvdy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJvd0xpbWl0ID0gZnVuY3Rpb24gZ2V0Um93TGltaXQoKSB7XG4gICAgdmFyIGV2ZW50SGVpZ2h0ID0gZ2V0SGVpZ2h0KHRoaXMuZXZlbnRSb3cpO1xuICAgIHZhciBoZWFkaW5nSGVpZ2h0ID0gdGhpcy5oZWFkaW5nUm93ID8gZ2V0SGVpZ2h0KHRoaXMuaGVhZGluZ1JvdykgOiAwO1xuICAgIHZhciBldmVudFNwYWNlID0gZ2V0SGVpZ2h0KGZpbmRET01Ob2RlKHRoaXMpKSAtIGhlYWRpbmdIZWlnaHQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IoZXZlbnRTcGFjZSAvIGV2ZW50SGVpZ2h0KSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZGF0ZSA9IF90aGlzJHByb3BzNS5kYXRlLFxuICAgICAgICBydGwgPSBfdGhpcyRwcm9wczUucnRsLFxuICAgICAgICByYW5nZSQkMSA9IF90aGlzJHByb3BzNS5yYW5nZSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM1LmNsYXNzTmFtZSxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wczUuc2VsZWN0ZWQsXG4gICAgICAgIHNlbGVjdGFibGUgPSBfdGhpcyRwcm9wczUuc2VsZWN0YWJsZSxcbiAgICAgICAgcmVuZGVyRm9yTWVhc3VyZSA9IF90aGlzJHByb3BzNS5yZW5kZXJGb3JNZWFzdXJlLFxuICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wczUuYWNjZXNzb3JzLFxuICAgICAgICBnZXR0ZXJzID0gX3RoaXMkcHJvcHM1LmdldHRlcnMsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wczUuY29tcG9uZW50cyxcbiAgICAgICAgZ2V0Tm93ID0gX3RoaXMkcHJvcHM1LmdldE5vdyxcbiAgICAgICAgcmVuZGVySGVhZGVyID0gX3RoaXMkcHJvcHM1LnJlbmRlckhlYWRlcixcbiAgICAgICAgb25TZWxlY3QgPSBfdGhpcyRwcm9wczUub25TZWxlY3QsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzNS5sb2NhbGl6ZXIsXG4gICAgICAgIG9uU2VsZWN0U3RhcnQgPSBfdGhpcyRwcm9wczUub25TZWxlY3RTdGFydCxcbiAgICAgICAgb25TZWxlY3RFbmQgPSBfdGhpcyRwcm9wczUub25TZWxlY3RFbmQsXG4gICAgICAgIG9uRG91YmxlQ2xpY2sgPSBfdGhpcyRwcm9wczUub25Eb3VibGVDbGljayxcbiAgICAgICAgcmVzb3VyY2VJZCA9IF90aGlzJHByb3BzNS5yZXNvdXJjZUlkLFxuICAgICAgICBsb25nUHJlc3NUaHJlc2hvbGQgPSBfdGhpcyRwcm9wczUubG9uZ1ByZXNzVGhyZXNob2xkLFxuICAgICAgICBpc0FsbERheSA9IF90aGlzJHByb3BzNS5pc0FsbERheTtcbiAgICBpZiAocmVuZGVyRm9yTWVhc3VyZSkgcmV0dXJuIHRoaXMucmVuZGVyRHVtbXkoKTtcbiAgICB2YXIgbWV0cmljcyA9IHRoaXMuc2xvdE1ldHJpY3ModGhpcy5wcm9wcyk7XG4gICAgdmFyIGxldmVscyA9IG1ldHJpY3MubGV2ZWxzLFxuICAgICAgICBleHRyYSA9IG1ldHJpY3MuZXh0cmE7XG4gICAgdmFyIFdlZWtXcmFwcGVyID0gY29tcG9uZW50cy53ZWVrV3JhcHBlcjtcbiAgICB2YXIgZXZlbnRSb3dQcm9wcyA9IHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzLFxuICAgICAgZ2V0dGVyczogZ2V0dGVycyxcbiAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIG9uU2VsZWN0OiBvblNlbGVjdCxcbiAgICAgIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2ssXG4gICAgICByZXNvdXJjZUlkOiByZXNvdXJjZUlkLFxuICAgICAgc2xvdE1ldHJpY3M6IG1ldHJpY3NcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChCYWNrZ3JvdW5kQ2VsbHMsIHtcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBnZXROb3c6IGdldE5vdyxcbiAgICAgIHJ0bDogcnRsLFxuICAgICAgcmFuZ2U6IHJhbmdlJCQxLFxuICAgICAgc2VsZWN0YWJsZTogc2VsZWN0YWJsZSxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXIsXG4gICAgICBnZXR0ZXJzOiBnZXR0ZXJzLFxuICAgICAgb25TZWxlY3RTdGFydDogb25TZWxlY3RTdGFydCxcbiAgICAgIG9uU2VsZWN0RW5kOiBvblNlbGVjdEVuZCxcbiAgICAgIG9uU2VsZWN0U2xvdDogdGhpcy5oYW5kbGVTZWxlY3RTbG90LFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIGxvbmdQcmVzc1RocmVzaG9sZDogbG9uZ1ByZXNzVGhyZXNob2xkXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3ctY29udGVudFwiXG4gICAgfSwgcmVuZGVySGVhZGVyICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3cgXCIsXG4gICAgICByZWY6IHRoaXMuY3JlYXRlSGVhZGluZ1JlZlxuICAgIH0sIHJhbmdlJCQxLm1hcCh0aGlzLnJlbmRlckhlYWRpbmdDZWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2Vla1dyYXBwZXIsIF9leHRlbmRzKHtcbiAgICAgIGlzQWxsRGF5OiBpc0FsbERheVxuICAgIH0sIGV2ZW50Um93UHJvcHMpLCBsZXZlbHMubWFwKGZ1bmN0aW9uIChzZWdzLCBpZHgpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50Um93LCBfZXh0ZW5kcyh7XG4gICAgICAgIGtleTogaWR4LFxuICAgICAgICBzZWdtZW50czogc2Vnc1xuICAgICAgfSwgZXZlbnRSb3dQcm9wcykpO1xuICAgIH0pLCAhIWV4dHJhLmxlbmd0aCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50RW5kaW5nUm93LCBfZXh0ZW5kcyh7XG4gICAgICBzZWdtZW50czogZXh0cmEsXG4gICAgICBvblNob3dNb3JlOiB0aGlzLmhhbmRsZVNob3dNb3JlXG4gICAgfSwgZXZlbnRSb3dQcm9wcykpKSkpO1xuICB9O1xuXG4gIHJldHVybiBEYXRlQ29udGVudFJvdztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRGF0ZUNvbnRlbnRSb3cucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBkYXRlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgcmFuZ2U6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBydGw6IFByb3BUeXBlcy5ib29sLFxuICByZXNvdXJjZUlkOiBQcm9wVHlwZXMuYW55LFxuICByZW5kZXJGb3JNZWFzdXJlOiBQcm9wVHlwZXMuYm9vbCxcbiAgcmVuZGVySGVhZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29udGFpbmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdGFibGU6IFByb3BUeXBlcy5vbmVPZihbdHJ1ZSwgZmFsc2UsICdpZ25vcmVFdmVudHMnXSksXG4gIGxvbmdQcmVzc1RocmVzaG9sZDogUHJvcFR5cGVzLm51bWJlcixcbiAgb25TaG93TW9yZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU2VsZWN0U2xvdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Eb3VibGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIGRheVByb3BHZXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBnZXROb3c6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGlzQWxsRGF5OiBQcm9wVHlwZXMuYm9vbCxcbiAgYWNjZXNzb3JzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZ2V0dGVyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhbGl6ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWluUm93czogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBtYXhSb3dzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn0gOiB7fTtcbkRhdGVDb250ZW50Um93LmRlZmF1bHRQcm9wcyA9IHtcbiAgbWluUm93czogMCxcbiAgbWF4Um93czogSW5maW5pdHlcbn07XG5cbnZhciBIZWFkZXIgPSBmdW5jdGlvbiBIZWFkZXIoX3JlZikge1xuICB2YXIgbGFiZWwgPSBfcmVmLmxhYmVsO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgbGFiZWwpO1xufTtcblxuSGVhZGVyLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlXG59IDoge307XG5cbnZhciBEYXRlSGVhZGVyID0gZnVuY3Rpb24gRGF0ZUhlYWRlcihfcmVmKSB7XG4gIHZhciBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBkcmlsbGRvd25WaWV3ID0gX3JlZi5kcmlsbGRvd25WaWV3LFxuICAgICAgb25EcmlsbERvd24gPSBfcmVmLm9uRHJpbGxEb3duO1xuXG4gIGlmICghZHJpbGxkb3duVmlldykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBsYWJlbCk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgIGhyZWY6IFwiI1wiLFxuICAgIG9uQ2xpY2s6IG9uRHJpbGxEb3duXG4gIH0sIGxhYmVsKTtcbn07XG5cbkRhdGVIZWFkZXIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gIGRhdGU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICBkcmlsbGRvd25WaWV3OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvbkRyaWxsRG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gIGlzT2ZmUmFuZ2U6IFByb3BUeXBlcy5ib29sXG59IDoge307XG5cbnZhciBldmVudHNGb3JXZWVrID0gZnVuY3Rpb24gZXZlbnRzRm9yV2VlayhldnRzLCBzdGFydCwgZW5kLCBhY2Nlc3NvcnMpIHtcbiAgcmV0dXJuIGV2dHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UoZSwgc3RhcnQsIGVuZCwgYWNjZXNzb3JzKTtcbiAgfSk7XG59O1xuXG52YXIgTW9udGhWaWV3ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKE1vbnRoVmlldywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9udGhWaWV3KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmRET01Ob2RlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyV2VlayA9IGZ1bmN0aW9uICh3ZWVrLCB3ZWVrSWR4KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBldmVudHMkJDEgPSBfdGhpcyRwcm9wcy5ldmVudHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgICAgc2VsZWN0YWJsZSA9IF90aGlzJHByb3BzLnNlbGVjdGFibGUsXG4gICAgICAgICAgZ2V0Tm93ID0gX3RoaXMkcHJvcHMuZ2V0Tm93LFxuICAgICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgICAgZGF0ZSA9IF90aGlzJHByb3BzLmRhdGUsXG4gICAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkcHJvcHMubG9jYWxpemVyLFxuICAgICAgICAgIGxvbmdQcmVzc1RocmVzaG9sZCA9IF90aGlzJHByb3BzLmxvbmdQcmVzc1RocmVzaG9sZCxcbiAgICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wcy5hY2Nlc3NvcnMsXG4gICAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzLmdldHRlcnM7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBuZWVkTGltaXRNZWFzdXJlID0gX3RoaXMkc3RhdGUubmVlZExpbWl0TWVhc3VyZSxcbiAgICAgICAgICByb3dMaW1pdCA9IF90aGlzJHN0YXRlLnJvd0xpbWl0O1xuICAgICAgZXZlbnRzJCQxID0gZXZlbnRzRm9yV2VlayhldmVudHMkJDEsIHdlZWtbMF0sIHdlZWtbd2Vlay5sZW5ndGggLSAxXSwgYWNjZXNzb3JzKTtcbiAgICAgIGV2ZW50cyQkMS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0RXZlbnRzKGEsIGIsIGFjY2Vzc29ycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVDb250ZW50Um93LCB7XG4gICAgICAgIGtleTogd2Vla0lkeCxcbiAgICAgICAgcmVmOiB3ZWVrSWR4ID09PSAwID8gJ3Nsb3RSb3cnIDogdW5kZWZpbmVkLFxuICAgICAgICBjb250YWluZXI6IF90aGlzLmdldENvbnRhaW5lcixcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1tb250aC1yb3dcIixcbiAgICAgICAgZ2V0Tm93OiBnZXROb3csXG4gICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIHJhbmdlOiB3ZWVrLFxuICAgICAgICBldmVudHM6IGV2ZW50cyQkMSxcbiAgICAgICAgbWF4Um93czogcm93TGltaXQsXG4gICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgc2VsZWN0YWJsZTogc2VsZWN0YWJsZSxcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICAgIGdldHRlcnM6IGdldHRlcnMsXG4gICAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgICByZW5kZXJIZWFkZXI6IF90aGlzLnJlYWRlckRhdGVIZWFkaW5nLFxuICAgICAgICByZW5kZXJGb3JNZWFzdXJlOiBuZWVkTGltaXRNZWFzdXJlLFxuICAgICAgICBvblNob3dNb3JlOiBfdGhpcy5oYW5kbGVTaG93TW9yZSxcbiAgICAgICAgb25TZWxlY3Q6IF90aGlzLmhhbmRsZVNlbGVjdEV2ZW50LFxuICAgICAgICBvbkRvdWJsZUNsaWNrOiBfdGhpcy5oYW5kbGVEb3VibGVDbGlja0V2ZW50LFxuICAgICAgICBvblNlbGVjdFNsb3Q6IF90aGlzLmhhbmRsZVNlbGVjdFNsb3QsXG4gICAgICAgIGxvbmdQcmVzc1RocmVzaG9sZDogbG9uZ1ByZXNzVGhyZXNob2xkLFxuICAgICAgICBydGw6IF90aGlzLnByb3BzLnJ0bFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlYWRlckRhdGVIZWFkaW5nID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBkYXRlID0gX3JlZi5kYXRlLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiZGF0ZVwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjdXJyZW50RGF0ZSA9IF90aGlzJHByb3BzMi5kYXRlLFxuICAgICAgICAgIGdldERyaWxsZG93blZpZXcgPSBfdGhpcyRwcm9wczIuZ2V0RHJpbGxkb3duVmlldyxcbiAgICAgICAgICBsb2NhbGl6ZXIgPSBfdGhpcyRwcm9wczIubG9jYWxpemVyO1xuICAgICAgdmFyIGlzT2ZmUmFuZ2UgPSBkYXRlcy5tb250aChkYXRlKSAhPT0gZGF0ZXMubW9udGgoY3VycmVudERhdGUpO1xuICAgICAgdmFyIGlzQ3VycmVudCA9IGRhdGVzLmVxKGRhdGUsIGN1cnJlbnREYXRlLCAnZGF5Jyk7XG4gICAgICB2YXIgZHJpbGxkb3duVmlldyA9IGdldERyaWxsZG93blZpZXcoZGF0ZSk7XG4gICAgICB2YXIgbGFiZWwgPSBsb2NhbGl6ZXIuZm9ybWF0KGRhdGUsICdkYXRlRm9ybWF0Jyk7XG4gICAgICB2YXIgRGF0ZUhlYWRlckNvbXBvbmVudCA9IF90aGlzLnByb3BzLmNvbXBvbmVudHMuZGF0ZUhlYWRlciB8fCBEYXRlSGVhZGVyO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY24oY2xhc3NOYW1lLCBpc09mZlJhbmdlICYmICdyYmMtb2ZmLXJhbmdlJywgaXNDdXJyZW50ICYmICdyYmMtY3VycmVudCcpXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChEYXRlSGVhZGVyQ29tcG9uZW50LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgZHJpbGxkb3duVmlldzogZHJpbGxkb3duVmlldyxcbiAgICAgICAgaXNPZmZSYW5nZTogaXNPZmZSYW5nZSxcbiAgICAgICAgb25EcmlsbERvd246IGZ1bmN0aW9uIG9uRHJpbGxEb3duKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlSGVhZGluZ0NsaWNrKGRhdGUsIGRyaWxsZG93blZpZXcsIGUpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVNlbGVjdFNsb3QgPSBmdW5jdGlvbiAocmFuZ2UkJDEsIHNsb3RJbmZvKSB7XG4gICAgICBfdGhpcy5fcGVuZGluZ1NlbGVjdGlvbiA9IF90aGlzLl9wZW5kaW5nU2VsZWN0aW9uLmNvbmNhdChyYW5nZSQkMSk7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3NlbGVjdFRpbWVyKTtcbiAgICAgIF90aGlzLl9zZWxlY3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VsZWN0RGF0ZXMoc2xvdEluZm8pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUhlYWRpbmdDbGljayA9IGZ1bmN0aW9uIChkYXRlLCB2aWV3LCBlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgICAgIG5vdGlmeShfdGhpcy5wcm9wcy5vbkRyaWxsRG93biwgW2RhdGUsIHZpZXddKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU2VsZWN0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBub3RpZnkoX3RoaXMucHJvcHMub25TZWxlY3RFdmVudCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZURvdWJsZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICBub3RpZnkoX3RoaXMucHJvcHMub25Eb3VibGVDbGlja0V2ZW50LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU2hvd01vcmUgPSBmdW5jdGlvbiAoZXZlbnRzJCQxLCBkYXRlLCBjZWxsLCBzbG90KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgcG9wdXAgPSBfdGhpcyRwcm9wczMucG9wdXAsXG4gICAgICAgICAgb25EcmlsbERvd24gPSBfdGhpcyRwcm9wczMub25EcmlsbERvd24sXG4gICAgICAgICAgb25TaG93TW9yZSA9IF90aGlzJHByb3BzMy5vblNob3dNb3JlLFxuICAgICAgICAgIGdldERyaWxsZG93blZpZXcgPSBfdGhpcyRwcm9wczMuZ2V0RHJpbGxkb3duVmlldzsgLy9jYW5jZWwgYW55IHBlbmRpbmcgc2VsZWN0aW9ucyBzbyBvbmx5IHRoZSBldmVudCBjbGljayBnb2VzIHRocm91Z2guXG5cbiAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihjZWxsLCBmaW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSkpO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBvdmVybGF5OiB7XG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgZXZlbnRzOiBldmVudHMkJDEsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90aWZ5KG9uRHJpbGxEb3duLCBbZGF0ZSwgZ2V0RHJpbGxkb3duVmlldyhkYXRlKSB8fCB2aWV3cy5EQVldKTtcbiAgICAgIH1cblxuICAgICAgbm90aWZ5KG9uU2hvd01vcmUsIFtldmVudHMkJDEsIGRhdGUsIHNsb3RdKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2JnUm93cyA9IFtdO1xuICAgIF90aGlzLl9wZW5kaW5nU2VsZWN0aW9uID0gW107XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICByb3dMaW1pdDogNSxcbiAgICAgIG5lZWRMaW1pdE1lYXN1cmU6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNb250aFZpZXcucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhfcmVmMikge1xuICAgIHZhciBkYXRlID0gX3JlZjIuZGF0ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG5lZWRMaW1pdE1lYXN1cmU6ICFkYXRlcy5lcShkYXRlLCB0aGlzLnByb3BzLmRhdGUpXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgcnVubmluZztcbiAgICBpZiAodGhpcy5zdGF0ZS5uZWVkTGltaXRNZWFzdXJlKSB0aGlzLm1lYXN1cmVSb3dMaW1pdCh0aGlzLnByb3BzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbmVlZExpbWl0TWVhc3VyZTogdHJ1ZVxuICAgICAgICAgIH0pOyAvL2VzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5uZWVkTGltaXRNZWFzdXJlKSB0aGlzLm1lYXN1cmVSb3dMaW1pdCh0aGlzLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplTGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRlID0gX3RoaXMkcHJvcHM0LmRhdGUsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzNC5sb2NhbGl6ZXIsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNC5jbGFzc05hbWUsXG4gICAgICAgIG1vbnRoID0gZGF0ZXMudmlzaWJsZURheXMoZGF0ZSwgbG9jYWxpemVyKSxcbiAgICAgICAgd2Vla3MgPSBjaHVuayhtb250aCwgNyk7XG4gICAgdGhpcy5fd2Vla0NvdW50ID0gd2Vla3MubGVuZ3RoO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY24oJ3JiYy1tb250aC12aWV3JywgY2xhc3NOYW1lKVxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3cgcmJjLW1vbnRoLWhlYWRlclwiXG4gICAgfSwgdGhpcy5yZW5kZXJIZWFkZXJzKHdlZWtzWzBdKSksIHdlZWtzLm1hcCh0aGlzLnJlbmRlcldlZWspLCB0aGlzLnByb3BzLnBvcHVwICYmIHRoaXMucmVuZGVyT3ZlcmxheSgpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVySGVhZGVycyA9IGZ1bmN0aW9uIHJlbmRlckhlYWRlcnMocm93KSB7XG4gICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzNS5sb2NhbGl6ZXIsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wczUuY29tcG9uZW50cztcbiAgICB2YXIgZmlyc3QgPSByb3dbMF07XG4gICAgdmFyIGxhc3QgPSByb3dbcm93Lmxlbmd0aCAtIDFdO1xuICAgIHZhciBIZWFkZXJDb21wb25lbnQgPSBjb21wb25lbnRzLmhlYWRlciB8fCBIZWFkZXI7XG4gICAgcmV0dXJuIGRhdGVzLnJhbmdlKGZpcnN0LCBsYXN0LCAnZGF5JykubWFwKGZ1bmN0aW9uIChkYXksIGlkeCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6ICdoZWFkZXJfJyArIGlkeCxcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1oZWFkZXJcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXJDb21wb25lbnQsIHtcbiAgICAgICAgZGF0ZTogZGF5LFxuICAgICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplcixcbiAgICAgICAgbGFiZWw6IGxvY2FsaXplci5mb3JtYXQoZGF5LCAnd2Vla2RheUZvcm1hdCcpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlck92ZXJsYXkgPSBmdW5jdGlvbiByZW5kZXJPdmVybGF5KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIG92ZXJsYXkgPSB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUub3ZlcmxheSB8fCB7fTtcbiAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3RoaXMkcHJvcHM2LmFjY2Vzc29ycyxcbiAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkcHJvcHM2LmxvY2FsaXplcixcbiAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzNi5jb21wb25lbnRzLFxuICAgICAgICBnZXR0ZXJzID0gX3RoaXMkcHJvcHM2LmdldHRlcnMsXG4gICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHM2LnNlbGVjdGVkO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXksIHtcbiAgICAgIHJvb3RDbG9zZTogdHJ1ZSxcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIGNvbnRhaW5lcjogdGhpcyxcbiAgICAgIHNob3c6ICEhb3ZlcmxheS5wb3NpdGlvbixcbiAgICAgIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnNldFN0YXRlKHtcbiAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wdXAsIHtcbiAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzLFxuICAgICAgZ2V0dGVyczogZ2V0dGVycyxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplcixcbiAgICAgIHBvc2l0aW9uOiBvdmVybGF5LnBvc2l0aW9uLFxuICAgICAgZXZlbnRzOiBvdmVybGF5LmV2ZW50cyxcbiAgICAgIHNsb3RTdGFydDogb3ZlcmxheS5kYXRlLFxuICAgICAgc2xvdEVuZDogb3ZlcmxheS5lbmQsXG4gICAgICBvblNlbGVjdDogdGhpcy5oYW5kbGVTZWxlY3RFdmVudCxcbiAgICAgIG9uRG91YmxlQ2xpY2s6IHRoaXMuaGFuZGxlRG91YmxlQ2xpY2tFdmVudFxuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8ubWVhc3VyZVJvd0xpbWl0ID0gZnVuY3Rpb24gbWVhc3VyZVJvd0xpbWl0KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbmVlZExpbWl0TWVhc3VyZTogZmFsc2UsXG4gICAgICByb3dMaW1pdDogdGhpcy5yZWZzLnNsb3RSb3cuZ2V0Um93TGltaXQoKVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5zZWxlY3REYXRlcyA9IGZ1bmN0aW9uIHNlbGVjdERhdGVzKHNsb3RJbmZvKSB7XG4gICAgdmFyIHNsb3RzID0gdGhpcy5fcGVuZGluZ1NlbGVjdGlvbi5zbGljZSgpO1xuXG4gICAgdGhpcy5fcGVuZGluZ1NlbGVjdGlvbiA9IFtdO1xuICAgIHNsb3RzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiArYSAtICtiO1xuICAgIH0pO1xuICAgIG5vdGlmeSh0aGlzLnByb3BzLm9uU2VsZWN0U2xvdCwge1xuICAgICAgc2xvdHM6IHNsb3RzLFxuICAgICAgc3RhcnQ6IHNsb3RzWzBdLFxuICAgICAgZW5kOiBzbG90c1tzbG90cy5sZW5ndGggLSAxXSxcbiAgICAgIGFjdGlvbjogc2xvdEluZm8uYWN0aW9uLFxuICAgICAgYm91bmRzOiBzbG90SW5mby5ib3VuZHMsXG4gICAgICBib3g6IHNsb3RJbmZvLmJveFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zZWxlY3RUaW1lcik7XG4gICAgdGhpcy5fcGVuZGluZ1NlbGVjdGlvbiA9IFtdO1xuICB9O1xuXG4gIHJldHVybiBNb250aFZpZXc7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1vbnRoVmlldy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGV2ZW50czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGRhdGU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICBtaW46IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICBtYXg6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxuICBnZXROb3c6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHNjcm9sbFRvVGltZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSksXG4gIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBhY2Nlc3NvcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBnZXR0ZXJzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2FsaXplcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLm9uZU9mKFt0cnVlLCBmYWxzZSwgJ2lnbm9yZUV2ZW50cyddKSxcbiAgbG9uZ1ByZXNzVGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvbk5hdmlnYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RTbG90OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RFdmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRG91YmxlQ2xpY2tFdmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU2hvd01vcmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRyaWxsRG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gIGdldERyaWxsZG93blZpZXc6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBvcHVwOiBQcm9wVHlwZXMuYm9vbCxcbiAgcG9wdXBPZmZzZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB5OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSlcbn0gOiB7fTtcblxuTW9udGhWaWV3LnJhbmdlID0gZnVuY3Rpb24gKGRhdGUsIF9yZWYzKSB7XG4gIHZhciBsb2NhbGl6ZXIgPSBfcmVmMy5sb2NhbGl6ZXI7XG4gIHZhciBzdGFydCA9IGRhdGVzLmZpcnN0VmlzaWJsZURheShkYXRlLCBsb2NhbGl6ZXIpO1xuICB2YXIgZW5kID0gZGF0ZXMubGFzdFZpc2libGVEYXkoZGF0ZSwgbG9jYWxpemVyKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn07XG5cbk1vbnRoVmlldy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChkYXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIG5hdmlnYXRlLlBSRVZJT1VTOlxuICAgICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlLCAtMSwgJ21vbnRoJyk7XG5cbiAgICBjYXNlIG5hdmlnYXRlLk5FWFQ6XG4gICAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGUsIDEsICdtb250aCcpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlO1xuICB9XG59O1xuXG5Nb250aFZpZXcudGl0bGUgPSBmdW5jdGlvbiAoZGF0ZSwgX3JlZjQpIHtcbiAgdmFyIGxvY2FsaXplciA9IF9yZWY0LmxvY2FsaXplcjtcbiAgcmV0dXJuIGxvY2FsaXplci5mb3JtYXQoZGF0ZSwgJ21vbnRoSGVhZGVyRm9ybWF0Jyk7XG59O1xuXG52YXIgZ2V0RHN0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RHN0T2Zmc2V0KHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkgLSBlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkobWluLCBtYXgsIHN0ZXAsIHNsb3RzKSB7XG4gIHJldHVybiBcIlwiICsgK2RhdGVzLnN0YXJ0T2YobWluLCAnbWludXRlcycpICsgKFwiXCIgKyArZGF0ZXMuc3RhcnRPZihtYXgsICdtaW51dGVzJykpICsgKHN0ZXAgKyBcIi1cIiArIHNsb3RzKTtcbn07XG5cbmZ1bmN0aW9uIGdldFNsb3RNZXRyaWNzJDEoX3JlZikge1xuICB2YXIgc3RhcnQgPSBfcmVmLm1pbixcbiAgICAgIGVuZCA9IF9yZWYubWF4LFxuICAgICAgc3RlcCA9IF9yZWYuc3RlcCxcbiAgICAgIHRpbWVzbG90cyA9IF9yZWYudGltZXNsb3RzO1xuICB2YXIga2V5ID0gZ2V0S2V5KHN0YXJ0LCBlbmQsIHN0ZXAsIHRpbWVzbG90cyk7XG4gIHZhciB0b3RhbE1pbiA9IDEgKyBkYXRlcy5kaWZmKHN0YXJ0LCBlbmQsICdtaW51dGVzJykgKyBnZXREc3RPZmZzZXQoc3RhcnQsIGVuZCk7XG4gIHZhciBtaW51dGVzRnJvbU1pZG5pZ2h0ID0gZGF0ZXMuZGlmZihkYXRlcy5zdGFydE9mKHN0YXJ0LCAnZGF5JyksIHN0YXJ0LCAnbWludXRlcycpO1xuICB2YXIgbnVtR3JvdXBzID0gTWF0aC5jZWlsKHRvdGFsTWluIC8gKHN0ZXAgKiB0aW1lc2xvdHMpKTtcbiAgdmFyIG51bVNsb3RzID0gbnVtR3JvdXBzICogdGltZXNsb3RzO1xuICB2YXIgZ3JvdXBzID0gbmV3IEFycmF5KG51bUdyb3Vwcyk7XG4gIHZhciBzbG90cyA9IG5ldyBBcnJheShudW1TbG90cyk7IC8vIEVhY2ggc2xvdCBkYXRlIGlzIGNyZWF0ZWQgZnJvbSBcInplcm9cIiwgaW5zdGVhZCBvZiBhZGRpbmcgYHN0ZXBgIHRvXG4gIC8vIHRoZSBwcmV2aW91cyBvbmUsIGluIG9yZGVyIHRvIGF2b2lkIERTVCBvZGRpdGllc1xuXG4gIGZvciAodmFyIGdycCA9IDA7IGdycCA8IG51bUdyb3VwczsgZ3JwKyspIHtcbiAgICBncm91cHNbZ3JwXSA9IG5ldyBBcnJheSh0aW1lc2xvdHMpO1xuXG4gICAgZm9yICh2YXIgc2xvdCA9IDA7IHNsb3QgPCB0aW1lc2xvdHM7IHNsb3QrKykge1xuICAgICAgdmFyIHNsb3RJZHggPSBncnAgKiB0aW1lc2xvdHMgKyBzbG90O1xuICAgICAgdmFyIG1pbkZyb21TdGFydCA9IHNsb3RJZHggKiBzdGVwOyAvLyBBIGRhdGUgd2l0aCB0b3RhbCBtaW51dGVzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRheVxuXG4gICAgICBzbG90c1tzbG90SWR4XSA9IGdyb3Vwc1tncnBdW3Nsb3RdID0gbmV3IERhdGUoc3RhcnQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgc3RhcnQuZ2V0RGF0ZSgpLCAwLCBtaW51dGVzRnJvbU1pZG5pZ2h0ICsgbWluRnJvbVN0YXJ0LCAwLCAwKTtcbiAgICB9XG4gIH0gLy8gTmVjZXNzYXJ5IHRvIGJlIGFibGUgdG8gc2VsZWN0IHVwIHVudGlsIHRoZSBsYXN0IHRpbWVzbG90IGluIGEgZGF5XG5cblxuICB2YXIgbGFzdFNsb3RNaW5Gcm9tU3RhcnQgPSBzbG90cy5sZW5ndGggKiBzdGVwO1xuICBzbG90cy5wdXNoKG5ldyBEYXRlKHN0YXJ0LmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSwgMCwgbWludXRlc0Zyb21NaWRuaWdodCArIGxhc3RTbG90TWluRnJvbVN0YXJ0LCAwLCAwKSk7XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Gcm9tRGF0ZShkYXRlKSB7XG4gICAgdmFyIGRpZmYgPSBkYXRlcy5kaWZmKHN0YXJ0LCBkYXRlLCAnbWludXRlcycpICsgZ2V0RHN0T2Zmc2V0KHN0YXJ0LCBkYXRlKTtcbiAgICByZXR1cm4gTWF0aC5taW4oZGlmZiwgdG90YWxNaW4pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGdyb3VwcyxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShhcmdzKSB7XG4gICAgICBpZiAoZ2V0S2V5KGFyZ3MpICE9PSBrZXkpIHJldHVybiBnZXRTbG90TWV0cmljcyQxKGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkYXRlSXNJbkdyb3VwOiBmdW5jdGlvbiBkYXRlSXNJbkdyb3VwKGRhdGUsIGdyb3VwSW5kZXgpIHtcbiAgICAgIHZhciBuZXh0R3JvdXAgPSBncm91cHNbZ3JvdXBJbmRleCArIDFdO1xuICAgICAgcmV0dXJuIGRhdGVzLmluUmFuZ2UoZGF0ZSwgZ3JvdXBzW2dyb3VwSW5kZXhdWzBdLCBuZXh0R3JvdXAgPyBuZXh0R3JvdXBbMF0gOiBlbmQsICdtaW51dGVzJyk7XG4gICAgfSxcbiAgICBuZXh0U2xvdDogZnVuY3Rpb24gbmV4dFNsb3Qoc2xvdCkge1xuICAgICAgdmFyIG5leHQgPSBzbG90c1tNYXRoLm1pbihzbG90cy5pbmRleE9mKHNsb3QpICsgMSwgc2xvdHMubGVuZ3RoIC0gMSldOyAvLyBpbiB0aGUgY2FzZSBvZiB0aGUgbGFzdCBzbG90IHdlIHdvbid0IGEgbG9uZyBlbm91Z2ggcmFuZ2Ugc28gbWFudWFsbHkgZ2V0IGl0XG5cbiAgICAgIGlmIChuZXh0ID09PSBzbG90KSBuZXh0ID0gZGF0ZXMuYWRkKHNsb3QsIHN0ZXAsICdtaW51dGVzJyk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIGNsb3Nlc3RTbG90VG9Qb3NpdGlvbjogZnVuY3Rpb24gY2xvc2VzdFNsb3RUb1Bvc2l0aW9uKHBlcmNlbnQpIHtcbiAgICAgIHZhciBzbG90ID0gTWF0aC5taW4oc2xvdHMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihwZXJjZW50ICogbnVtU2xvdHMpKSk7XG4gICAgICByZXR1cm4gc2xvdHNbc2xvdF07XG4gICAgfSxcbiAgICBjbG9zZXN0U2xvdEZyb21Qb2ludDogZnVuY3Rpb24gY2xvc2VzdFNsb3RGcm9tUG9pbnQocG9pbnQsIGJvdW5kYXJ5UmVjdCkge1xuICAgICAgdmFyIHJhbmdlJCQxID0gTWF0aC5hYnMoYm91bmRhcnlSZWN0LnRvcCAtIGJvdW5kYXJ5UmVjdC5ib3R0b20pO1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdFNsb3RUb1Bvc2l0aW9uKChwb2ludC55IC0gYm91bmRhcnlSZWN0LnRvcCkgLyByYW5nZSQkMSk7XG4gICAgfSxcbiAgICBjbG9zZXN0U2xvdEZyb21EYXRlOiBmdW5jdGlvbiBjbG9zZXN0U2xvdEZyb21EYXRlKGRhdGUsIG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRlcy5sdChkYXRlLCBzdGFydCwgJ21pbnV0ZXMnKSkgcmV0dXJuIHNsb3RzWzBdO1xuICAgICAgdmFyIGRpZmZNaW5zID0gZGF0ZXMuZGlmZihzdGFydCwgZGF0ZSwgJ21pbnV0ZXMnKTtcbiAgICAgIHJldHVybiBzbG90c1soZGlmZk1pbnMgLSBkaWZmTWlucyAlIHN0ZXApIC8gc3RlcCArIG9mZnNldF07XG4gICAgfSxcbiAgICBzdGFydHNCZWZvcmVEYXk6IGZ1bmN0aW9uIHN0YXJ0c0JlZm9yZURheShkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZXMubHQoZGF0ZSwgc3RhcnQsICdkYXknKTtcbiAgICB9LFxuICAgIHN0YXJ0c0FmdGVyRGF5OiBmdW5jdGlvbiBzdGFydHNBZnRlckRheShkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZXMuZ3QoZGF0ZSwgZW5kLCAnZGF5Jyk7XG4gICAgfSxcbiAgICBzdGFydHNCZWZvcmU6IGZ1bmN0aW9uIHN0YXJ0c0JlZm9yZShkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZXMubHQoZGF0ZXMubWVyZ2Uoc3RhcnQsIGRhdGUpLCBzdGFydCwgJ21pbnV0ZXMnKTtcbiAgICB9LFxuICAgIHN0YXJ0c0FmdGVyOiBmdW5jdGlvbiBzdGFydHNBZnRlcihkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZXMuZ3QoZGF0ZXMubWVyZ2UoZW5kLCBkYXRlKSwgZW5kLCAnbWludXRlcycpO1xuICAgIH0sXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uIGdldFJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgICByYW5nZVN0YXJ0ID0gZGF0ZXMubWluKGVuZCwgZGF0ZXMubWF4KHN0YXJ0LCByYW5nZVN0YXJ0KSk7XG4gICAgICByYW5nZUVuZCA9IGRhdGVzLm1pbihlbmQsIGRhdGVzLm1heChzdGFydCwgcmFuZ2VFbmQpKTtcbiAgICAgIHZhciByYW5nZVN0YXJ0TWluID0gcG9zaXRpb25Gcm9tRGF0ZShyYW5nZVN0YXJ0KTtcbiAgICAgIHZhciByYW5nZUVuZE1pbiA9IHBvc2l0aW9uRnJvbURhdGUocmFuZ2VFbmQpO1xuICAgICAgdmFyIHRvcCA9IHJhbmdlU3RhcnRNaW4gLyAoc3RlcCAqIG51bVNsb3RzKSAqIDEwMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBoZWlnaHQ6IHJhbmdlRW5kTWluIC8gKHN0ZXAgKiBudW1TbG90cykgKiAxMDAgLSB0b3AsXG4gICAgICAgIHN0YXJ0OiBwb3NpdGlvbkZyb21EYXRlKHJhbmdlU3RhcnQpLFxuICAgICAgICBzdGFydERhdGU6IHJhbmdlU3RhcnQsXG4gICAgICAgIGVuZDogcG9zaXRpb25Gcm9tRGF0ZShyYW5nZUVuZCksXG4gICAgICAgIGVuZERhdGU6IHJhbmdlRW5kXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIEV2ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnQoZGF0YSwgX3JlZikge1xuICAgIHZhciBhY2Nlc3NvcnMgPSBfcmVmLmFjY2Vzc29ycyxcbiAgICAgICAgc2xvdE1ldHJpY3MgPSBfcmVmLnNsb3RNZXRyaWNzO1xuXG4gICAgdmFyIF9zbG90TWV0cmljcyRnZXRSYW5nZSA9IHNsb3RNZXRyaWNzLmdldFJhbmdlKGFjY2Vzc29ycy5zdGFydChkYXRhKSwgYWNjZXNzb3JzLmVuZChkYXRhKSksXG4gICAgICAgIHN0YXJ0ID0gX3Nsb3RNZXRyaWNzJGdldFJhbmdlLnN0YXJ0LFxuICAgICAgICBzdGFydERhdGUgPSBfc2xvdE1ldHJpY3MkZ2V0UmFuZ2Uuc3RhcnREYXRlLFxuICAgICAgICBlbmQgPSBfc2xvdE1ldHJpY3MkZ2V0UmFuZ2UuZW5kLFxuICAgICAgICBlbmREYXRlID0gX3Nsb3RNZXRyaWNzJGdldFJhbmdlLmVuZERhdGUsXG4gICAgICAgIHRvcCA9IF9zbG90TWV0cmljcyRnZXRSYW5nZS50b3AsXG4gICAgICAgIGhlaWdodCA9IF9zbG90TWV0cmljcyRnZXRSYW5nZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5zdGFydE1zID0gK3N0YXJ0RGF0ZTtcbiAgICB0aGlzLmVuZE1zID0gK2VuZERhdGU7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICAvKipcbiAgICogVGhlIGV2ZW50J3Mgd2lkdGggd2l0aG91dCBhbnkgb3ZlcmxhcC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnQsIFt7XG4gICAga2V5OiBcIl93aWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gVGhlIGNvbnRhaW5lciBldmVudCdzIHdpZHRoIGlzIGRldGVybWluZWQgYnkgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICAgICAvLyBldmVudHMgaW4gYW55IG9mIGl0cyByb3dzLlxuICAgICAgaWYgKHRoaXMucm93cykge1xuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMucm93cy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgcm93KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgcm93LmxlYXZlcy5sZW5ndGggKyAxKTtcbiAgICAgICAgfSwgLy8gYWRkIGl0c2VsZlxuICAgICAgICAwKSArIDE7IC8vIGFkZCB0aGUgY29udGFpbmVyXG5cbiAgICAgICAgcmV0dXJuIDEwMCAvIGNvbHVtbnM7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IDEwMCAtIHRoaXMuY29udGFpbmVyLl93aWR0aDsgLy8gVGhlIHJvdyBldmVudCdzIHdpZHRoIGlzIHRoZSBzcGFjZSBsZWZ0IGJ5IHRoZSBjb250YWluZXIsIGRpdmlkZWRcbiAgICAgIC8vIGFtb25nIGl0c2VsZiBhbmQgaXRzIGxlYXZlcy5cblxuICAgICAgaWYgKHRoaXMubGVhdmVzKSB7XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVXaWR0aCAvICh0aGlzLmxlYXZlcy5sZW5ndGggKyAxKTtcbiAgICAgIH0gLy8gVGhlIGxlYWYgZXZlbnQncyB3aWR0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyByb3cncyB3aWR0aFxuXG5cbiAgICAgIHJldHVybiB0aGlzLnJvdy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCdzIGNhbGN1bGF0ZWQgd2lkdGgsIHBvc3NpYmx5IHdpdGggZXh0cmEgd2lkdGggYWRkZWQgZm9yXG4gICAgICogb3ZlcmxhcHBpbmcgZWZmZWN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBub092ZXJsYXAgPSB0aGlzLl93aWR0aDtcbiAgICAgIHZhciBvdmVybGFwID0gTWF0aC5taW4oMTAwLCB0aGlzLl93aWR0aCAqIDEuNyk7IC8vIENvbnRhaW5lcnMgY2FuIGFsd2F5cyBncm93LlxuXG4gICAgICBpZiAodGhpcy5yb3dzKSB7XG4gICAgICAgIHJldHVybiBvdmVybGFwO1xuICAgICAgfSAvLyBSb3dzIGNhbiBncm93IGlmIHRoZXkgaGF2ZSBsZWF2ZXMuXG5cblxuICAgICAgaWYgKHRoaXMubGVhdmVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlcy5sZW5ndGggPiAwID8gb3ZlcmxhcCA6IG5vT3ZlcmxhcDtcbiAgICAgIH0gLy8gTGVhdmVzIGNhbiBncm93IHVubGVzcyB0aGV5J3JlIHRoZSBsYXN0IGl0ZW0gaW4gYSByb3cuXG5cblxuICAgICAgdmFyIGxlYXZlcyA9IHRoaXMucm93LmxlYXZlcztcbiAgICAgIHZhciBpbmRleCA9IGxlYXZlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgcmV0dXJuIGluZGV4ID09PSBsZWF2ZXMubGVuZ3RoIC0gMSA/IG5vT3ZlcmxhcCA6IG92ZXJsYXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInhPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIENvbnRhaW5lcnMgaGF2ZSBubyBvZmZzZXQuXG4gICAgICBpZiAodGhpcy5yb3dzKSByZXR1cm4gMDsgLy8gUm93cyBhbHdheXMgc3RhcnQgd2hlcmUgdGhlaXIgY29udGFpbmVyIGVuZHMuXG5cbiAgICAgIGlmICh0aGlzLmxlYXZlcykgcmV0dXJuIHRoaXMuY29udGFpbmVyLl93aWR0aDsgLy8gTGVhdmVzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSBvbiB0aGUgc3BhY2UgbGVmdCBieSBpdHMgcm93LlxuXG4gICAgICB2YXIgX3RoaXMkcm93ID0gdGhpcy5yb3csXG4gICAgICAgICAgbGVhdmVzID0gX3RoaXMkcm93LmxlYXZlcyxcbiAgICAgICAgICB4T2Zmc2V0ID0gX3RoaXMkcm93LnhPZmZzZXQsXG4gICAgICAgICAgX3dpZHRoID0gX3RoaXMkcm93Ll93aWR0aDtcbiAgICAgIHZhciBpbmRleCA9IGxlYXZlcy5pbmRleE9mKHRoaXMpICsgMTtcbiAgICAgIHJldHVybiB4T2Zmc2V0ICsgaW5kZXggKiBfd2lkdGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50O1xufSgpO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBldmVudCBhIGFuZCBiIGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHNhbWUgcm93LlxuICovXG5cblxuZnVuY3Rpb24gb25TYW1lUm93KGEsIGIsIG1pbmltdW1TdGFydERpZmZlcmVuY2UpIHtcbiAgcmV0dXJuICgvLyBPY2N1cGllcyB0aGUgc2FtZSBzdGFydCBzbG90LlxuICAgIE1hdGguYWJzKGIuc3RhcnQgLSBhLnN0YXJ0KSA8IG1pbmltdW1TdGFydERpZmZlcmVuY2UgfHwgLy8gQSdzIHN0YXJ0IHNsb3Qgb3ZlcmxhcHMgd2l0aCBiJ3MgZW5kIHNsb3QuXG4gICAgYi5zdGFydCA+IGEuc3RhcnQgJiYgYi5zdGFydCA8IGEuZW5kXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVJlbmRlcihldmVudHMkJDEpIHtcbiAgdmFyIHNvcnRlZEJ5VGltZSA9IHNvcnRCeShldmVudHMkJDEsIFsnc3RhcnRNcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIC1lLmVuZE1zO1xuICB9XSk7XG4gIHZhciBzb3J0ZWQgPSBbXTtcblxuICB3aGlsZSAoc29ydGVkQnlUaW1lLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBzb3J0ZWRCeVRpbWUuc2hpZnQoKTtcbiAgICBzb3J0ZWQucHVzaChldmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZEJ5VGltZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlc3QgPSBzb3J0ZWRCeVRpbWVbaV07IC8vIFN0aWxsIGluc2lkZSB0aGlzIGV2ZW50LCBsb29rIGZvciBuZXh0LlxuXG4gICAgICBpZiAoZXZlbnQuZW5kTXMgPiB0ZXN0LnN0YXJ0TXMpIGNvbnRpbnVlOyAvLyBXZSd2ZSBmb3VuZCB0aGUgZmlyc3QgZXZlbnQgb2YgdGhlIG5leHQgZXZlbnQgZ3JvdXAuXG4gICAgICAvLyBJZiB0aGF0IGV2ZW50IGlzIG5vdCByaWdodCBuZXh0IHRvIG91ciBjdXJyZW50IGV2ZW50LCB3ZSBoYXZlIHRvXG4gICAgICAvLyBtb3ZlIGl0IGhlcmUuXG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB2YXIgX2V2ZW50ID0gc29ydGVkQnlUaW1lLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgc29ydGVkLnB1c2goX2V2ZW50KTtcbiAgICAgIH0gLy8gV2UndmUgYWxyZWFkeSBmb3VuZCB0aGUgbmV4dCBldmVudCBncm91cCwgc28gc3RvcCBsb29raW5nLlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlZEV2ZW50cyhfcmVmMikge1xuICB2YXIgZXZlbnRzJCQxID0gX3JlZjIuZXZlbnRzLFxuICAgICAgbWluaW11bVN0YXJ0RGlmZmVyZW5jZSA9IF9yZWYyLm1pbmltdW1TdGFydERpZmZlcmVuY2UsXG4gICAgICBzbG90TWV0cmljcyA9IF9yZWYyLnNsb3RNZXRyaWNzLFxuICAgICAgYWNjZXNzb3JzID0gX3JlZjIuYWNjZXNzb3JzO1xuICAvLyBDcmVhdGUgcHJveHkgZXZlbnRzIGFuZCBvcmRlciB0aGVtIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuICAvLyB0byBmaWRkbGUgd2l0aCB6LWluZGV4ZXMuXG4gIHZhciBwcm94aWVzID0gZXZlbnRzJCQxLm1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KGV2ZW50LCB7XG4gICAgICBzbG90TWV0cmljczogc2xvdE1ldHJpY3MsXG4gICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29yc1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIGV2ZW50c0luUmVuZGVyT3JkZXIgPSBzb3J0QnlSZW5kZXIocHJveGllcyk7IC8vIEdyb3VwIG92ZXJsYXBwaW5nIGV2ZW50cywgd2hpbGUga2VlcGluZyBvcmRlci5cbiAgLy8gRXZlcnkgZXZlbnQgaXMgYWx3YXlzIG9uZSBvZjogY29udGFpbmVyLCByb3cgb3IgbGVhZi5cbiAgLy8gQ29udGFpbmVycyBjYW4gY29udGFpbiByb3dzLCBhbmQgcm93cyBjYW4gY29udGFpbiBsZWF2ZXMuXG5cbiAgdmFyIGNvbnRhaW5lckV2ZW50cyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgZXZlbnQgPSBldmVudHNJblJlbmRlck9yZGVyW2ldOyAvLyBDaGVjayBpZiB0aGlzIGV2ZW50IGNhbiBnbyBpbnRvIGEgY29udGFpbmVyIGV2ZW50LlxuXG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lckV2ZW50cy5maW5kKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5lbmQgPiBldmVudC5zdGFydCB8fCBNYXRoLmFicyhldmVudC5zdGFydCAtIGMuc3RhcnQpIDwgbWluaW11bVN0YXJ0RGlmZmVyZW5jZTtcbiAgICB9KTsgLy8gQ291bGRuJ3QgZmluZCBhIGNvbnRhaW5lciDigJQgdGhhdCBtZWFucyB0aGlzIGV2ZW50IGlzIGEgY29udGFpbmVyLlxuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIGV2ZW50LnJvd3MgPSBbXTtcbiAgICAgIGNvbnRhaW5lckV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgfSAvLyBGb3VuZCBhIGNvbnRhaW5lciBmb3IgdGhlIGV2ZW50LlxuXG5cbiAgICBldmVudC5jb250YWluZXIgPSBjb250YWluZXI7IC8vIENoZWNrIGlmIHRoZSBldmVudCBjYW4gYmUgcGxhY2VkIGluIGFuIGV4aXN0aW5nIHJvdy5cbiAgICAvLyBTdGFydCBsb29raW5nIGZyb20gYmVoaW5kLlxuXG4gICAgdmFyIHJvdyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBqID0gY29udGFpbmVyLnJvd3MubGVuZ3RoIC0gMTsgIXJvdyAmJiBqID49IDA7IGotLSkge1xuICAgICAgaWYgKG9uU2FtZVJvdyhjb250YWluZXIucm93c1tqXSwgZXZlbnQsIG1pbmltdW1TdGFydERpZmZlcmVuY2UpKSB7XG4gICAgICAgIHJvdyA9IGNvbnRhaW5lci5yb3dzW2pdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyb3cpIHtcbiAgICAgIC8vIEZvdW5kIGEgcm93LCBzbyBhZGQgaXQuXG4gICAgICByb3cubGVhdmVzLnB1c2goZXZlbnQpO1xuICAgICAgZXZlbnQucm93ID0gcm93O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb3VsZG4ndCBmaW5kIGEgcm93IOKAkyB0aGF0IG1lYW5zIHRoaXMgZXZlbnQgaXMgYSByb3cuXG4gICAgICBldmVudC5sZWF2ZXMgPSBbXTtcbiAgICAgIGNvbnRhaW5lci5yb3dzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50c0luUmVuZGVyT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3JldCA9IF9sb29wKGkpO1xuXG4gICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gIH0gLy8gUmV0dXJuIHRoZSBvcmlnaW5hbCBldmVudHMsIGFsb25nIHdpdGggdGhlaXIgc3R5bGVzLlxuXG5cbiAgcmV0dXJuIGV2ZW50c0luUmVuZGVyT3JkZXIubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudDogZXZlbnQuZGF0YSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRvcDogZXZlbnQudG9wLFxuICAgICAgICBoZWlnaHQ6IGV2ZW50LmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICB4T2Zmc2V0OiBldmVudC54T2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE5vb3BXcmFwcGVyKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxudmFyIFRpbWVTbG90R3JvdXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZVNsb3RHcm91cCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGltZVNsb3RHcm91cCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGltZVNsb3RHcm91cC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByZW5kZXJTbG90ID0gX3RoaXMkcHJvcHMucmVuZGVyU2xvdCxcbiAgICAgICAgcmVzb3VyY2UgPSBfdGhpcyRwcm9wcy5yZXNvdXJjZSxcbiAgICAgICAgZ3JvdXAgPSBfdGhpcyRwcm9wcy5ncm91cCxcbiAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzLmdldHRlcnMsXG4gICAgICAgIF90aGlzJHByb3BzJGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudHM7XG4gICAgX3RoaXMkcHJvcHMkY29tcG9uZW50ID0gX3RoaXMkcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyB7fSA6IF90aGlzJHByb3BzJGNvbXBvbmVudDtcbiAgICB2YXIgX3RoaXMkcHJvcHMkY29tcG9uZW50MiA9IF90aGlzJHByb3BzJGNvbXBvbmVudC50aW1lU2xvdFdyYXBwZXIsXG4gICAgICAgIFdyYXBwZXIgPSBfdGhpcyRwcm9wcyRjb21wb25lbnQyID09PSB2b2lkIDAgPyBOb29wV3JhcHBlciA6IF90aGlzJHByb3BzJGNvbXBvbmVudDI7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy10aW1lc2xvdC1ncm91cFwiXG4gICAgfSwgZ3JvdXAubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICB2YXIgc2xvdFByb3BzID0gZ2V0dGVycyA/IGdldHRlcnMuc2xvdFByb3AodmFsdWUsIHJlc291cmNlKSA6IHt9O1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwge1xuICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICByZXNvdXJjZTogcmVzb3VyY2VcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHNsb3RQcm9wcywge1xuICAgICAgICBjbGFzc05hbWU6IGNuKCdyYmMtdGltZS1zbG90Jywgc2xvdFByb3BzLmNsYXNzTmFtZSlcbiAgICAgIH0pLCByZW5kZXJTbG90ICYmIHJlbmRlclNsb3QodmFsdWUsIGlkeCkpKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVTbG90R3JvdXA7XG59KENvbXBvbmVudCk7XG5UaW1lU2xvdEdyb3VwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgcmVuZGVyU2xvdDogUHJvcFR5cGVzLmZ1bmMsXG4gIGdyb3VwOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgcmVzb3VyY2U6IFByb3BUeXBlcy5hbnksXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdldHRlcnM6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB7fTtcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuXG5mdW5jdGlvbiBUaW1lR3JpZEV2ZW50KHByb3BzKSB7XG4gIHZhciBfZXh0ZW5kczI7XG5cbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBldmVudCA9IHByb3BzLmV2ZW50LFxuICAgICAgYWNjZXNzb3JzID0gcHJvcHMuYWNjZXNzb3JzLFxuICAgICAgaXNSdGwgPSBwcm9wcy5pc1J0bCxcbiAgICAgIHNlbGVjdGVkID0gcHJvcHMuc2VsZWN0ZWQsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgY29udGludWVzRWFybGllciA9IHByb3BzLmNvbnRpbnVlc0VhcmxpZXIsXG4gICAgICBjb250aW51ZXNMYXRlciA9IHByb3BzLmNvbnRpbnVlc0xhdGVyLFxuICAgICAgZ2V0dGVycyA9IHByb3BzLmdldHRlcnMsXG4gICAgICBvbkNsaWNrID0gcHJvcHMub25DbGljayxcbiAgICAgIG9uRG91YmxlQ2xpY2sgPSBwcm9wcy5vbkRvdWJsZUNsaWNrLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudHMgPSBwcm9wcy5jb21wb25lbnRzLFxuICAgICAgRXZlbnQgPSBfcHJvcHMkY29tcG9uZW50cy5ldmVudCxcbiAgICAgIEV2ZW50V3JhcHBlciA9IF9wcm9wcyRjb21wb25lbnRzLmV2ZW50V3JhcHBlcjtcbiAgdmFyIHRpdGxlID0gYWNjZXNzb3JzLnRpdGxlKGV2ZW50KTtcbiAgdmFyIHRvb2x0aXAgPSBhY2Nlc3NvcnMudG9vbHRpcChldmVudCk7XG4gIHZhciBlbmQgPSBhY2Nlc3NvcnMuZW5kKGV2ZW50KTtcbiAgdmFyIHN0YXJ0ID0gYWNjZXNzb3JzLnN0YXJ0KGV2ZW50KTtcbiAgdmFyIHVzZXJQcm9wcyA9IGdldHRlcnMuZXZlbnRQcm9wKGV2ZW50LCBzdGFydCwgZW5kLCBzZWxlY3RlZCk7XG4gIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQsXG4gICAgICB0b3AgPSBzdHlsZS50b3AsXG4gICAgICB3aWR0aCA9IHN0eWxlLndpZHRoLFxuICAgICAgeE9mZnNldCA9IHN0eWxlLnhPZmZzZXQ7XG4gIHZhciBpbm5lciA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwiMVwiLFxuICAgIGNsYXNzTmFtZTogXCJyYmMtZXZlbnQtbGFiZWxcIlxuICB9LCBsYWJlbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCIyXCIsXG4gICAgY2xhc3NOYW1lOiBcInJiYy1ldmVudC1jb250ZW50XCJcbiAgfSwgRXZlbnQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50LCB7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIHRpdGxlOiB0aXRsZVxuICB9KSA6IHRpdGxlKV07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50V3JhcHBlciwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IFwidGltZVwiXG4gIH0sIHByb3BzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgb25DbGljazogb25DbGljayxcbiAgICBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrLFxuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgdXNlclByb3BzLnN0eWxlLCAoX2V4dGVuZHMyID0ge1xuICAgICAgdG9wOiB0b3AgKyBcIiVcIixcbiAgICAgIGhlaWdodDogaGVpZ2h0ICsgXCIlXCJcbiAgICB9LCBfZXh0ZW5kczJbaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnXSA9IE1hdGgubWF4KDAsIHhPZmZzZXQpICsgXCIlXCIsIF9leHRlbmRzMi53aWR0aCA9IHdpZHRoICsgXCIlXCIsIF9leHRlbmRzMikpLFxuICAgIHRpdGxlOiB0b29sdGlwID8gKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycgPyBsYWJlbCArICc6ICcgOiAnJykgKyB0b29sdGlwIDogdW5kZWZpbmVkLFxuICAgIGNsYXNzTmFtZTogY24oJ3JiYy1ldmVudCcsIGNsYXNzTmFtZSwgdXNlclByb3BzLmNsYXNzTmFtZSwge1xuICAgICAgJ3JiYy1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgJ3JiYy1ldmVudC1jb250aW51ZXMtZWFybGllcic6IGNvbnRpbnVlc0VhcmxpZXIsXG4gICAgICAncmJjLWV2ZW50LWNvbnRpbnVlcy1sYXRlcic6IGNvbnRpbnVlc0xhdGVyXG4gICAgfSlcbiAgfSwgaW5uZXIpKTtcbn1cblxudmFyIERheUNvbHVtbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShEYXlDb2x1bW4sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERheUNvbHVtbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNlbGVjdGluZzogZmFsc2UsXG4gICAgICB0aW1lSW5kaWNhdG9yUG9zaXRpb246IG51bGxcbiAgICB9O1xuICAgIF90aGlzLmludGVydmFsVHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBfdGhpcy5yZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBldmVudHMkJDEgPSBfdGhpcyRwcm9wcy5ldmVudHMsXG4gICAgICAgICAgaXNSdGwgPSBfdGhpcyRwcm9wcy5ydGwsXG4gICAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wcy5hY2Nlc3NvcnMsXG4gICAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkcHJvcHMubG9jYWxpemVyLFxuICAgICAgICAgIGdldHRlcnMgPSBfdGhpcyRwcm9wcy5nZXR0ZXJzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHN0ZXAgPSBfdGhpcyRwcm9wcy5zdGVwLFxuICAgICAgICAgIHRpbWVzbG90cyA9IF90aGlzJHByb3BzLnRpbWVzbG90cztcblxuICAgICAgdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICAgIHNsb3RNZXRyaWNzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplLnNsb3RNZXRyaWNzO1xuXG4gICAgICB2YXIgbWVzc2FnZXMgPSBsb2NhbGl6ZXIubWVzc2FnZXM7XG4gICAgICB2YXIgc3R5bGVkRXZlbnRzID0gZ2V0U3R5bGVkRXZlbnRzKHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMkJDEsXG4gICAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzLFxuICAgICAgICBzbG90TWV0cmljczogc2xvdE1ldHJpY3MsXG4gICAgICAgIG1pbmltdW1TdGFydERpZmZlcmVuY2U6IE1hdGguY2VpbChzdGVwICogdGltZXNsb3RzIC8gMilcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0eWxlZEV2ZW50cy5tYXAoZnVuY3Rpb24gKF9yZWYsIGlkeCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBfcmVmLmV2ZW50LFxuICAgICAgICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlO1xuICAgICAgICB2YXIgZW5kID0gYWNjZXNzb3JzLmVuZChldmVudCk7XG4gICAgICAgIHZhciBzdGFydCA9IGFjY2Vzc29ycy5zdGFydChldmVudCk7XG4gICAgICAgIHZhciBmb3JtYXQgPSAnZXZlbnRUaW1lUmFuZ2VGb3JtYXQnO1xuICAgICAgICB2YXIgbGFiZWw7XG4gICAgICAgIHZhciBzdGFydHNCZWZvcmVEYXkgPSBzbG90TWV0cmljcy5zdGFydHNCZWZvcmVEYXkoc3RhcnQpO1xuICAgICAgICB2YXIgc3RhcnRzQWZ0ZXJEYXkgPSBzbG90TWV0cmljcy5zdGFydHNBZnRlckRheShlbmQpO1xuICAgICAgICBpZiAoc3RhcnRzQmVmb3JlRGF5KSBmb3JtYXQgPSAnZXZlbnRUaW1lUmFuZ2VFbmRGb3JtYXQnO2Vsc2UgaWYgKHN0YXJ0c0FmdGVyRGF5KSBmb3JtYXQgPSAnZXZlbnRUaW1lUmFuZ2VTdGFydEZvcm1hdCc7XG4gICAgICAgIGlmIChzdGFydHNCZWZvcmVEYXkgJiYgc3RhcnRzQWZ0ZXJEYXkpIGxhYmVsID0gbWVzc2FnZXMuYWxsRGF5O2Vsc2UgbGFiZWwgPSBsb2NhbGl6ZXIuZm9ybWF0KHtcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfSwgZm9ybWF0KTtcbiAgICAgICAgdmFyIGNvbnRpbnVlc0VhcmxpZXIgPSBzdGFydHNCZWZvcmVEYXkgfHwgc2xvdE1ldHJpY3Muc3RhcnRzQmVmb3JlKHN0YXJ0KTtcbiAgICAgICAgdmFyIGNvbnRpbnVlc0xhdGVyID0gc3RhcnRzQWZ0ZXJEYXkgfHwgc2xvdE1ldHJpY3Muc3RhcnRzQWZ0ZXIoZW5kKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZUdyaWRFdmVudCwge1xuICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgIGtleTogJ2V2dF8nICsgaWR4LFxuICAgICAgICAgIGdldHRlcnM6IGdldHRlcnMsXG4gICAgICAgICAgaXNSdGw6IGlzUnRsLFxuICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAgICAgY29udGludWVzRWFybGllcjogY29udGludWVzRWFybGllcixcbiAgICAgICAgICBjb250aW51ZXNMYXRlcjogY29udGludWVzTGF0ZXIsXG4gICAgICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQoZXZlbnQsIHNlbGVjdGVkKSxcbiAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2VsZWN0KGV2ZW50LCBlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9kb3VibGVDbGljayhldmVudCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fc2VsZWN0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub2RlID0gZmluZERPTU5vZGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgICAgdmFyIHNlbGVjdG9yID0gX3RoaXMuX3NlbGVjdG9yID0gbmV3IFNlbGVjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmaW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgICB9LCB7XG4gICAgICAgIGxvbmdQcmVzc1RocmVzaG9sZDogX3RoaXMucHJvcHMubG9uZ1ByZXNzVGhyZXNob2xkXG4gICAgICB9KTtcblxuICAgICAgdmFyIG1heWJlU2VsZWN0ID0gZnVuY3Rpb24gbWF5YmVTZWxlY3QoYm94KSB7XG4gICAgICAgIHZhciBvblNlbGVjdGluZyA9IF90aGlzLnByb3BzLm9uU2VsZWN0aW5nO1xuICAgICAgICB2YXIgY3VycmVudCA9IF90aGlzLnN0YXRlIHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGUgPSBzZWxlY3Rpb25TdGF0ZShib3gpO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5zdGFydERhdGUsXG4gICAgICAgICAgICBlbmQgPSBzdGF0ZS5lbmREYXRlO1xuXG4gICAgICAgIGlmIChvblNlbGVjdGluZykge1xuICAgICAgICAgIGlmIChkYXRlcy5lcShjdXJyZW50LnN0YXJ0RGF0ZSwgc3RhcnQsICdtaW51dGVzJykgJiYgZGF0ZXMuZXEoY3VycmVudC5lbmREYXRlLCBlbmQsICdtaW51dGVzJykgfHwgb25TZWxlY3Rpbmcoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICB9KSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zdGFydCAhPT0gc3RhdGUuc3RhcnQgfHwgX3RoaXMuc3RhdGUuZW5kICE9PSBzdGF0ZS5lbmQgfHwgX3RoaXMuc3RhdGUuc2VsZWN0aW5nICE9PSBzdGF0ZS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBzZWxlY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHNlbGVjdGlvblN0YXRlKHBvaW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50U2xvdCA9IF90aGlzLnNsb3RNZXRyaWNzLmNsb3Nlc3RTbG90RnJvbVBvaW50KHBvaW50LCBnZXRCb3VuZHNGb3JOb2RlKG5vZGUpKTtcblxuICAgICAgICBpZiAoIV90aGlzLnN0YXRlLnNlbGVjdGluZykgX3RoaXMuX2luaXRpYWxTbG90ID0gY3VycmVudFNsb3Q7XG4gICAgICAgIHZhciBpbml0aWFsU2xvdCA9IF90aGlzLl9pbml0aWFsU2xvdDtcbiAgICAgICAgaWYgKGluaXRpYWxTbG90ID09PSBjdXJyZW50U2xvdCkgY3VycmVudFNsb3QgPSBfdGhpcy5zbG90TWV0cmljcy5uZXh0U2xvdChpbml0aWFsU2xvdCk7XG5cbiAgICAgICAgdmFyIHNlbGVjdFJhbmdlID0gX3RoaXMuc2xvdE1ldHJpY3MuZ2V0UmFuZ2UoZGF0ZXMubWluKGluaXRpYWxTbG90LCBjdXJyZW50U2xvdCksIGRhdGVzLm1heChpbml0aWFsU2xvdCwgY3VycmVudFNsb3QpKTtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNlbGVjdFJhbmdlLCB7XG4gICAgICAgICAgc2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgIHRvcDogc2VsZWN0UmFuZ2UudG9wICsgXCIlXCIsXG4gICAgICAgICAgaGVpZ2h0OiBzZWxlY3RSYW5nZS5oZWlnaHQgKyBcIiVcIlxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzZWxlY3RvckNsaWNrc0hhbmRsZXIgPSBmdW5jdGlvbiBzZWxlY3RvckNsaWNrc0hhbmRsZXIoYm94LCBhY3Rpb25UeXBlKSB7XG4gICAgICAgIGlmICghaXNFdmVudChmaW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSksIGJveCkpIHtcbiAgICAgICAgICB2YXIgX3NlbGVjdGlvblN0YXRlID0gc2VsZWN0aW9uU3RhdGUoYm94KSxcbiAgICAgICAgICAgICAgc3RhcnREYXRlID0gX3NlbGVjdGlvblN0YXRlLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgZW5kRGF0ZSA9IF9zZWxlY3Rpb25TdGF0ZS5lbmREYXRlO1xuXG4gICAgICAgICAgX3RoaXMuX3NlbGVjdFNsb3Qoe1xuICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgICAgICAgICBlbmREYXRlOiBlbmREYXRlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25UeXBlLFxuICAgICAgICAgICAgYm94OiBib3hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBzZWxlY3Rpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgc2VsZWN0b3Iub24oJ3NlbGVjdGluZycsIG1heWJlU2VsZWN0KTtcbiAgICAgIHNlbGVjdG9yLm9uKCdzZWxlY3RTdGFydCcsIG1heWJlU2VsZWN0KTtcbiAgICAgIHNlbGVjdG9yLm9uKCdiZWZvcmVTZWxlY3QnLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RhYmxlICE9PSAnaWdub3JlRXZlbnRzJykgcmV0dXJuO1xuICAgICAgICByZXR1cm4gIWlzRXZlbnQoZmluZERPTU5vZGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpLCBib3gpO1xuICAgICAgfSk7XG4gICAgICBzZWxlY3Rvci5vbignY2xpY2snLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvckNsaWNrc0hhbmRsZXIoYm94LCAnY2xpY2snKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0b3Iub24oJ2RvdWJsZUNsaWNrJywgZnVuY3Rpb24gKGJveCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3JDbGlja3NIYW5kbGVyKGJveCwgJ2RvdWJsZUNsaWNrJyk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdG9yLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBfdGhpcy5fc2VsZWN0U2xvdChfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3NlbGVjdCcsXG4gICAgICAgICAgICBib3VuZHM6IGJvdW5kc1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxlY3Rvci5vbigncmVzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rpbmc6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fdGVhcmRvd25TZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5fc2VsZWN0b3IpIHJldHVybjtcblxuICAgICAgX3RoaXMuX3NlbGVjdG9yLnRlYXJkb3duKCk7XG5cbiAgICAgIF90aGlzLl9zZWxlY3RvciA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLl9zZWxlY3RTbG90ID0gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgc3RhcnREYXRlID0gX3JlZjIuc3RhcnREYXRlLFxuICAgICAgICAgIGVuZERhdGUgPSBfcmVmMi5lbmREYXRlLFxuICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbixcbiAgICAgICAgICBib3VuZHMgPSBfcmVmMi5ib3VuZHMsXG4gICAgICAgICAgYm94ID0gX3JlZjIuYm94O1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydERhdGUsXG4gICAgICAgICAgc2xvdHMgPSBbXTtcblxuICAgICAgd2hpbGUgKGRhdGVzLmx0ZShjdXJyZW50LCBlbmREYXRlKSkge1xuICAgICAgICBzbG90cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gZGF0ZXMuYWRkKGN1cnJlbnQsIF90aGlzLnByb3BzLnN0ZXAsICdtaW51dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIG5vdGlmeShfdGhpcy5wcm9wcy5vblNlbGVjdFNsb3QsIHtcbiAgICAgICAgc2xvdHM6IHNsb3RzLFxuICAgICAgICBzdGFydDogc3RhcnREYXRlLFxuICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICAgIHJlc291cmNlSWQ6IF90aGlzLnByb3BzLnJlc291cmNlLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICAgIGJveDogYm94XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX3NlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIG5vdGlmeShfdGhpcy5wcm9wcy5vblNlbGVjdEV2ZW50LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2RvdWJsZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgbm90aWZ5KF90aGlzLnByb3BzLm9uRG91YmxlQ2xpY2tFdmVudCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLnNsb3RNZXRyaWNzID0gZ2V0U2xvdE1ldHJpY3MkMShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERheUNvbHVtbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5wcm9wcy5zZWxlY3RhYmxlICYmIHRoaXMuX3NlbGVjdGFibGUoKTtcblxuICAgIGlmICh0aGlzLnByb3BzLmlzTm93KSB7XG4gICAgICB0aGlzLnNldFRpbWVJbmRpY2F0b3JQb3NpdGlvblVwZGF0ZUludGVydmFsKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX3RlYXJkb3duU2VsZWN0YWJsZSgpO1xuXG4gICAgdGhpcy5jbGVhclRpbWVJbmRpY2F0b3JJbnRlcnZhbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNlbGVjdGFibGUgJiYgIXRoaXMucHJvcHMuc2VsZWN0YWJsZSkgdGhpcy5fc2VsZWN0YWJsZSgpO1xuICAgIGlmICghbmV4dFByb3BzLnNlbGVjdGFibGUgJiYgdGhpcy5wcm9wcy5zZWxlY3RhYmxlKSB0aGlzLl90ZWFyZG93blNlbGVjdGFibGUoKTtcbiAgICB0aGlzLnNsb3RNZXRyaWNzID0gdGhpcy5zbG90TWV0cmljcy51cGRhdGUobmV4dFByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIGdldE5vd0NoYW5nZWQgPSAhZGF0ZXMuZXEocHJldlByb3BzLmdldE5vdygpLCB0aGlzLnByb3BzLmdldE5vdygpLCAnbWludXRlcycpO1xuXG4gICAgaWYgKHByZXZQcm9wcy5pc05vdyAhPT0gdGhpcy5wcm9wcy5pc05vdyB8fCBnZXROb3dDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZUluZGljYXRvckludGVydmFsKCk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmlzTm93KSB7XG4gICAgICAgIHZhciB0YWlsID0gIWdldE5vd0NoYW5nZWQgJiYgZGF0ZXMuZXEocHJldlByb3BzLmRhdGUsIHRoaXMucHJvcHMuZGF0ZSwgJ21pbnV0ZXMnKSAmJiBwcmV2U3RhdGUudGltZUluZGljYXRvclBvc2l0aW9uID09PSB0aGlzLnN0YXRlLnRpbWVJbmRpY2F0b3JQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zZXRUaW1lSW5kaWNhdG9yUG9zaXRpb25VcGRhdGVJbnRlcnZhbCh0YWlsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB0YWlsIHtCb29sZWFufSAtIHdoZXRoZXIgYHBvc2l0aW9uVGltZUluZGljYXRvcmAgY2FsbCBzaG91bGQgYmVcbiAgICogICBkZWZlcnJlZCBvciBjYWxsZWQgdXBvbiBzZXR0aW5nIGludGVydmFsIChgdHJ1ZWAgLSBpZiBkZWZlcnJlZCk7XG4gICAqL1xuICBfcHJvdG8uc2V0VGltZUluZGljYXRvclBvc2l0aW9uVXBkYXRlSW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRUaW1lSW5kaWNhdG9yUG9zaXRpb25VcGRhdGVJbnRlcnZhbCh0YWlsKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodGFpbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0YWlsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmludGVydmFsVHJpZ2dlcmVkICYmICF0YWlsKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uVGltZUluZGljYXRvcigpO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVJbmRpY2F0b3JUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLmludGVydmFsVHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgICAgX3RoaXMyLnBvc2l0aW9uVGltZUluZGljYXRvcigpO1xuXG4gICAgICBfdGhpczIuc2V0VGltZUluZGljYXRvclBvc2l0aW9uVXBkYXRlSW50ZXJ2YWwoKTtcbiAgICB9LCA2MDAwMCk7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyVGltZUluZGljYXRvckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJUaW1lSW5kaWNhdG9ySW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5pbnRlcnZhbFRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZUluZGljYXRvclRpbWVvdXQpO1xuICB9O1xuXG4gIF9wcm90by5wb3NpdGlvblRpbWVJbmRpY2F0b3IgPSBmdW5jdGlvbiBwb3NpdGlvblRpbWVJbmRpY2F0b3IoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1pbiA9IF90aGlzJHByb3BzMi5taW4sXG4gICAgICAgIG1heCA9IF90aGlzJHByb3BzMi5tYXgsXG4gICAgICAgIGdldE5vdyA9IF90aGlzJHByb3BzMi5nZXROb3c7XG4gICAgdmFyIGN1cnJlbnQgPSBnZXROb3coKTtcblxuICAgIGlmIChjdXJyZW50ID49IG1pbiAmJiBjdXJyZW50IDw9IG1heCkge1xuICAgICAgdmFyIF90aGlzJHNsb3RNZXRyaWNzJGdldCA9IHRoaXMuc2xvdE1ldHJpY3MuZ2V0UmFuZ2UoY3VycmVudCwgY3VycmVudCksXG4gICAgICAgICAgdG9wID0gX3RoaXMkc2xvdE1ldHJpY3MkZ2V0LnRvcDtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRpbWVJbmRpY2F0b3JQb3NpdGlvbjogdG9wXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVJbmRpY2F0b3JJbnRlcnZhbCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBtYXggPSBfdGhpcyRwcm9wczMubWF4LFxuICAgICAgICBydGwgPSBfdGhpcyRwcm9wczMucnRsLFxuICAgICAgICBpc05vdyA9IF90aGlzJHByb3BzMy5pc05vdyxcbiAgICAgICAgcmVzb3VyY2UgPSBfdGhpcyRwcm9wczMucmVzb3VyY2UsXG4gICAgICAgIGFjY2Vzc29ycyA9IF90aGlzJHByb3BzMy5hY2Nlc3NvcnMsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzMy5sb2NhbGl6ZXIsXG4gICAgICAgIF90aGlzJHByb3BzMyRnZXR0ZXJzID0gX3RoaXMkcHJvcHMzLmdldHRlcnMsXG4gICAgICAgIGRheVByb3AgPSBfdGhpcyRwcm9wczMkZ2V0dGVycy5kYXlQcm9wLFxuICAgICAgICBnZXR0ZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMzJGdldHRlcnMsIFtcImRheVByb3BcIl0pLFxuICAgICAgICBfdGhpcyRwcm9wczMkY29tcG9uZW4gPSBfdGhpcyRwcm9wczMuY29tcG9uZW50cyxcbiAgICAgICAgRXZlbnRDb250YWluZXIgPSBfdGhpcyRwcm9wczMkY29tcG9uZW4uZXZlbnRDb250YWluZXJXcmFwcGVyLFxuICAgICAgICBjb21wb25lbnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMzJGNvbXBvbmVuLCBbXCJldmVudENvbnRhaW5lcldyYXBwZXJcIl0pO1xuXG4gICAgdmFyIHNsb3RNZXRyaWNzID0gdGhpcy5zbG90TWV0cmljcztcbiAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzZWxlY3RpbmcgPSBfdGhpcyRzdGF0ZS5zZWxlY3RpbmcsXG4gICAgICAgIHRvcCA9IF90aGlzJHN0YXRlLnRvcCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkc3RhdGUuaGVpZ2h0LFxuICAgICAgICBzdGFydERhdGUgPSBfdGhpcyRzdGF0ZS5zdGFydERhdGUsXG4gICAgICAgIGVuZERhdGUgPSBfdGhpcyRzdGF0ZS5lbmREYXRlO1xuICAgIHZhciBzZWxlY3REYXRlcyA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydERhdGUsXG4gICAgICBlbmQ6IGVuZERhdGVcbiAgICB9O1xuXG4gICAgdmFyIF9kYXlQcm9wID0gZGF5UHJvcChtYXgpLFxuICAgICAgICBjbGFzc05hbWUgPSBfZGF5UHJvcC5jbGFzc05hbWUsXG4gICAgICAgIHN0eWxlID0gX2RheVByb3Auc3R5bGU7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBjbGFzc05hbWU6IGNuKGNsYXNzTmFtZSwgJ3JiYy1kYXktc2xvdCcsICdyYmMtdGltZS1jb2x1bW4nLCBpc05vdyAmJiAncmJjLW5vdycsIGlzTm93ICYmICdyYmMtdG9kYXknLCAvLyBXSFlcbiAgICAgIHNlbGVjdGluZyAmJiAncmJjLXNsb3Qtc2VsZWN0aW5nJylcbiAgICB9LCBzbG90TWV0cmljcy5ncm91cHMubWFwKGZ1bmN0aW9uIChncnAsIGlkeCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZVNsb3RHcm91cCwge1xuICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgZ3JvdXA6IGdycCxcbiAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlLFxuICAgICAgICBnZXR0ZXJzOiBnZXR0ZXJzLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9KTtcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwge1xuICAgICAgbG9jYWxpemVyOiBsb2NhbGl6ZXIsXG4gICAgICByZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgIGdldHRlcnM6IGdldHRlcnMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgc2xvdE1ldHJpY3M6IHNsb3RNZXRyaWNzXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNuKCdyYmMtZXZlbnRzLWNvbnRhaW5lcicsIHJ0bCAmJiAncnRsJylcbiAgICB9LCB0aGlzLnJlbmRlckV2ZW50cygpKSksIHNlbGVjdGluZyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtc2xvdC1zZWxlY3Rpb25cIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfVxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGxvY2FsaXplci5mb3JtYXQoc2VsZWN0RGF0ZXMsICdzZWxlY3RSYW5nZUZvcm1hdCcpKSksIGlzTm93ICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1jdXJyZW50LXRpbWUtaW5kaWNhdG9yXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3A6IHRoaXMuc3RhdGUudGltZUluZGljYXRvclBvc2l0aW9uICsgXCIlXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIERheUNvbHVtbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRGF5Q29sdW1uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgc3RlcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBkYXRlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKS5pc1JlcXVpcmVkLFxuICBtaW46IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLmlzUmVxdWlyZWQsXG4gIG1heDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSkuaXNSZXF1aXJlZCxcbiAgZ2V0Tm93OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBpc05vdzogUHJvcFR5cGVzLmJvb2wsXG4gIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gIGFjY2Vzc29yczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb21wb25lbnRzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGdldHRlcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYWxpemVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHNob3dNdWx0aURheVRpbWVzOiBQcm9wVHlwZXMuYm9vbCxcbiAgY3VsdHVyZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGltZXNsb3RzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLm9uZU9mKFt0cnVlLCBmYWxzZSwgJ2lnbm9yZUV2ZW50cyddKSxcbiAgZXZlbnRPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxvbmdQcmVzc1RocmVzaG9sZDogUHJvcFR5cGVzLm51bWJlcixcbiAgb25TZWxlY3Rpbmc6IFByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdFNsb3Q6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uU2VsZWN0RXZlbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uRG91YmxlQ2xpY2tFdmVudDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkcmFnVGhyb3VnaEV2ZW50czogUHJvcFR5cGVzLmJvb2wsXG4gIHJlc291cmNlOiBQcm9wVHlwZXMuYW55XG59IDoge307XG5EYXlDb2x1bW4uZGVmYXVsdFByb3BzID0ge1xuICBkcmFnVGhyb3VnaEV2ZW50czogdHJ1ZSxcbiAgdGltZXNsb3RzOiAyXG59O1xuXG52YXIgVGltZUd1dHRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUaW1lR3V0dGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lR3V0dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucmVuZGVyU2xvdCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICBpZiAoaWR4ICE9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzLmxvY2FsaXplcixcbiAgICAgICAgICBnZXROb3cgPSBfdGhpcyRwcm9wcy5nZXROb3c7XG5cbiAgICAgIHZhciBpc05vdyA9IF90aGlzLnNsb3RNZXRyaWNzLmRhdGVJc0luR3JvdXAoZ2V0Tm93KCksIGlkeCk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY24oJ3JiYy1sYWJlbCcsIGlzTm93ICYmICdyYmMtbm93JylcbiAgICAgIH0sIGxvY2FsaXplci5mb3JtYXQodmFsdWUsICd0aW1lR3V0dGVyRm9ybWF0JykpO1xuICAgIH07XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgIG1pbiA9IF90aGlzJHByb3BzMi5taW4sXG4gICAgICAgIG1heCA9IF90aGlzJHByb3BzMi5tYXgsXG4gICAgICAgIHRpbWVzbG90cyA9IF90aGlzJHByb3BzMi50aW1lc2xvdHMsXG4gICAgICAgIHN0ZXAgPSBfdGhpcyRwcm9wczIuc3RlcDtcbiAgICBfdGhpcy5zbG90TWV0cmljcyA9IGdldFNsb3RNZXRyaWNzJDEoe1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heCxcbiAgICAgIHRpbWVzbG90czogdGltZXNsb3RzLFxuICAgICAgc3RlcDogc3RlcFxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUaW1lR3V0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIG1pbiA9IG5leHRQcm9wcy5taW4sXG4gICAgICAgIG1heCA9IG5leHRQcm9wcy5tYXgsXG4gICAgICAgIHRpbWVzbG90cyA9IG5leHRQcm9wcy50aW1lc2xvdHMsXG4gICAgICAgIHN0ZXAgPSBuZXh0UHJvcHMuc3RlcDtcbiAgICB0aGlzLnNsb3RNZXRyaWNzID0gdGhpcy5zbG90TWV0cmljcy51cGRhdGUoe1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heCxcbiAgICAgIHRpbWVzbG90czogdGltZXNsb3RzLFxuICAgICAgc3RlcDogc3RlcFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVzb3VyY2UgPSBfdGhpcyRwcm9wczMucmVzb3VyY2UsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wczMuY29tcG9uZW50cztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLXRpbWUtZ3V0dGVyIHJiYy10aW1lLWNvbHVtblwiXG4gICAgfSwgdGhpcy5zbG90TWV0cmljcy5ncm91cHMubWFwKGZ1bmN0aW9uIChncnAsIGlkeCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZVNsb3RHcm91cCwge1xuICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgZ3JvdXA6IGdycCxcbiAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgICByZW5kZXJTbG90OiBfdGhpczIucmVuZGVyU2xvdFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lR3V0dGVyO1xufShDb21wb25lbnQpO1xuVGltZUd1dHRlci5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIG1pbjogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSkuaXNSZXF1aXJlZCxcbiAgbWF4OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKS5pc1JlcXVpcmVkLFxuICB0aW1lc2xvdHM6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc3RlcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBnZXROb3c6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYWxpemVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHJlc291cmNlOiBQcm9wVHlwZXMuc3RyaW5nXG59IDoge307XG5cbnZhciBSZXNvdXJjZUhlYWRlciA9IGZ1bmN0aW9uIFJlc291cmNlSGVhZGVyKF9yZWYpIHtcbiAgdmFyIGxhYmVsID0gX3JlZi5sYWJlbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxhYmVsKTtcbn07XG5cblJlc291cmNlSGVhZGVyLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICBpbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgcmVzb3VyY2U6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB7fTtcblxudmFyIFRpbWVHcmlkSGVhZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVHcmlkSGVhZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lR3JpZEhlYWRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcblxuICAgIF90aGlzLmhhbmRsZUhlYWRlckNsaWNrID0gZnVuY3Rpb24gKGRhdGUsIHZpZXcsIGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5vdGlmeShfdGhpcy5wcm9wcy5vbkRyaWxsRG93biwgW2RhdGUsIHZpZXddKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyUm93ID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBldmVudHMkJDEgPSBfdGhpcyRwcm9wcy5ldmVudHMsXG4gICAgICAgICAgcnRsID0gX3RoaXMkcHJvcHMucnRsLFxuICAgICAgICAgIHNlbGVjdGFibGUgPSBfdGhpcyRwcm9wcy5zZWxlY3RhYmxlLFxuICAgICAgICAgIGdldE5vdyA9IF90aGlzJHByb3BzLmdldE5vdyxcbiAgICAgICAgICByYW5nZSQkMSA9IF90aGlzJHByb3BzLnJhbmdlLFxuICAgICAgICAgIGdldHRlcnMgPSBfdGhpcyRwcm9wcy5nZXR0ZXJzLFxuICAgICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzLmxvY2FsaXplcixcbiAgICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wcy5hY2Nlc3NvcnMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHM7XG4gICAgICB2YXIgcmVzb3VyY2VJZCA9IGFjY2Vzc29ycy5yZXNvdXJjZUlkKHJlc291cmNlKTtcbiAgICAgIHZhciBldmVudHNUb0Rpc3BsYXkgPSByZXNvdXJjZSA/IGV2ZW50cyQkMS5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NvcnMucmVzb3VyY2UoZXZlbnQpID09PSByZXNvdXJjZUlkO1xuICAgICAgfSkgOiBldmVudHMkJDE7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEYXRlQ29udGVudFJvdywge1xuICAgICAgICBpc0FsbERheTogdHJ1ZSxcbiAgICAgICAgcnRsOiBydGwsXG4gICAgICAgIGdldE5vdzogZ2V0Tm93LFxuICAgICAgICBtaW5Sb3dzOiAyLFxuICAgICAgICByYW5nZTogcmFuZ2UkJDEsXG4gICAgICAgIGV2ZW50czogZXZlbnRzVG9EaXNwbGF5LFxuICAgICAgICByZXNvdXJjZUlkOiByZXNvdXJjZUlkLFxuICAgICAgICBjbGFzc05hbWU6IFwicmJjLWFsbGRheS1jZWxsXCIsXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdGFibGUsXG4gICAgICAgIHNlbGVjdGVkOiBfdGhpcy5wcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICAgIGdldHRlcnM6IGdldHRlcnMsXG4gICAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgICBvblNlbGVjdDogX3RoaXMucHJvcHMub25TZWxlY3RFdmVudCxcbiAgICAgICAgb25Eb3VibGVDbGljazogX3RoaXMucHJvcHMub25Eb3VibGVDbGlja0V2ZW50LFxuICAgICAgICBvblNlbGVjdFNsb3Q6IF90aGlzLnByb3BzLm9uU2VsZWN0U2xvdCxcbiAgICAgICAgbG9uZ1ByZXNzVGhyZXNob2xkOiBfdGhpcy5wcm9wcy5sb25nUHJlc3NUaHJlc2hvbGRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGltZUdyaWRIZWFkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXJIZWFkZXJDZWxscyA9IGZ1bmN0aW9uIHJlbmRlckhlYWRlckNlbGxzKHJhbmdlJCQxKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkcHJvcHMyLmxvY2FsaXplcixcbiAgICAgICAgZ2V0RHJpbGxkb3duVmlldyA9IF90aGlzJHByb3BzMi5nZXREcmlsbGRvd25WaWV3LFxuICAgICAgICBnZXROb3cgPSBfdGhpcyRwcm9wczIuZ2V0Tm93LFxuICAgICAgICBkYXlQcm9wID0gX3RoaXMkcHJvcHMyLmdldHRlcnMuZGF5UHJvcCxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGNvbXBvbmVuID0gX3RoaXMkcHJvcHMyLmNvbXBvbmVudHMuaGVhZGVyLFxuICAgICAgICBIZWFkZXJDb21wb25lbnQgPSBfdGhpcyRwcm9wczIkY29tcG9uZW4gPT09IHZvaWQgMCA/IEhlYWRlciA6IF90aGlzJHByb3BzMiRjb21wb25lbjtcbiAgICB2YXIgdG9kYXkgPSBnZXROb3coKTtcbiAgICByZXR1cm4gcmFuZ2UkJDEubWFwKGZ1bmN0aW9uIChkYXRlLCBpKSB7XG4gICAgICB2YXIgZHJpbGxkb3duVmlldyA9IGdldERyaWxsZG93blZpZXcoZGF0ZSk7XG4gICAgICB2YXIgbGFiZWwgPSBsb2NhbGl6ZXIuZm9ybWF0KGRhdGUsICdkYXlGb3JtYXQnKTtcblxuICAgICAgdmFyIF9kYXlQcm9wID0gZGF5UHJvcChkYXRlKSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfZGF5UHJvcC5jbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGUgPSBfZGF5UHJvcC5zdHlsZTtcblxuICAgICAgdmFyIGhlYWRlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyQ29tcG9uZW50LCB7XG4gICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbG9jYWxpemVyOiBsb2NhbGl6ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbigncmJjLWhlYWRlcicsIGNsYXNzTmFtZSwgZGF0ZXMuZXEoZGF0ZSwgdG9kYXksICdkYXknKSAmJiAncmJjLXRvZGF5JylcbiAgICAgIH0sIGRyaWxsZG93blZpZXcgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIGhyZWY6IFwiI1wiLFxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZUhlYWRlckNsaWNrKGRhdGUsIGRyaWxsZG93blZpZXcsIGUpO1xuICAgICAgICB9XG4gICAgICB9LCBoZWFkZXIpIDogUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgaGVhZGVyKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzMy53aWR0aCxcbiAgICAgICAgcnRsID0gX3RoaXMkcHJvcHMzLnJ0bCxcbiAgICAgICAgcmVzb3VyY2VzID0gX3RoaXMkcHJvcHMzLnJlc291cmNlcyxcbiAgICAgICAgcmFuZ2UkJDEgPSBfdGhpcyRwcm9wczMucmFuZ2UsXG4gICAgICAgIGV2ZW50cyQkMSA9IF90aGlzJHByb3BzMy5ldmVudHMsXG4gICAgICAgIGdldE5vdyA9IF90aGlzJHByb3BzMy5nZXROb3csXG4gICAgICAgIGFjY2Vzc29ycyA9IF90aGlzJHByb3BzMy5hY2Nlc3NvcnMsXG4gICAgICAgIHNlbGVjdGFibGUgPSBfdGhpcyRwcm9wczMuc2VsZWN0YWJsZSxcbiAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzMy5jb21wb25lbnRzLFxuICAgICAgICBnZXR0ZXJzID0gX3RoaXMkcHJvcHMzLmdldHRlcnMsXG4gICAgICAgIHNjcm9sbFJlZiA9IF90aGlzJHByb3BzMy5zY3JvbGxSZWYsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzMy5sb2NhbGl6ZXIsXG4gICAgICAgIGlzT3ZlcmZsb3dpbmcgPSBfdGhpcyRwcm9wczMuaXNPdmVyZmxvd2luZyxcbiAgICAgICAgX3RoaXMkcHJvcHMzJGNvbXBvbmVuID0gX3RoaXMkcHJvcHMzLmNvbXBvbmVudHMsXG4gICAgICAgIFRpbWVHdXR0ZXJIZWFkZXIgPSBfdGhpcyRwcm9wczMkY29tcG9uZW4udGltZUd1dHRlckhlYWRlcixcbiAgICAgICAgX3RoaXMkcHJvcHMzJGNvbXBvbmVuMiA9IF90aGlzJHByb3BzMyRjb21wb25lbi5yZXNvdXJjZUhlYWRlcixcbiAgICAgICAgUmVzb3VyY2VIZWFkZXJDb21wb25lbnQgPSBfdGhpcyRwcm9wczMkY29tcG9uZW4yID09PSB2b2lkIDAgPyBSZXNvdXJjZUhlYWRlciA6IF90aGlzJHByb3BzMyRjb21wb25lbjI7XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICBpZiAoaXNPdmVyZmxvd2luZykge1xuICAgICAgc3R5bGVbcnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSBzY3JvbGxiYXJTaXplKCkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwZWRFdmVudHMgPSByZXNvdXJjZXMuZ3JvdXBFdmVudHMoZXZlbnRzJCQxKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICByZWY6IHNjcm9sbFJlZixcbiAgICAgIGNsYXNzTmFtZTogY24oJ3JiYy10aW1lLWhlYWRlcicsIGlzT3ZlcmZsb3dpbmcgJiYgJ3JiYy1vdmVyZmxvd2luZycpXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLWxhYmVsIHJiYy10aW1lLWhlYWRlci1ndXR0ZXJcIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgbWluV2lkdGg6IHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH1cbiAgICB9LCBUaW1lR3V0dGVySGVhZGVyICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZUd1dHRlckhlYWRlciwgbnVsbCkpLCByZXNvdXJjZXMubWFwKGZ1bmN0aW9uIChfcmVmLCBpZHgpIHtcbiAgICAgIHZhciBpZCA9IF9yZWZbMF0sXG4gICAgICAgICAgcmVzb3VyY2UgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmJjLXRpbWUtaGVhZGVyLWNvbnRlbnRcIixcbiAgICAgICAga2V5OiBpZCB8fCBpZHhcbiAgICAgIH0sIHJlc291cmNlICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmJjLXJvdyByYmMtcm93LXJlc291cmNlXCIsXG4gICAgICAgIGtleTogXCJyZXNvdXJjZV9cIiArIGlkeFxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyYmMtaGVhZGVyXCJcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzb3VyY2VIZWFkZXJDb21wb25lbnQsIHtcbiAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgbGFiZWw6IGFjY2Vzc29ycy5yZXNvdXJjZVRpdGxlKHJlc291cmNlKSxcbiAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlXG4gICAgICB9KSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1yb3cgcmJjLXRpbWUtaGVhZGVyLWNlbGxcIiArIChyYW5nZSQkMS5sZW5ndGggPD0gMSA/ICcgcmJjLXRpbWUtaGVhZGVyLWNlbGwtc2luZ2xlLWRheScgOiAnJylcbiAgICAgIH0sIF90aGlzMy5yZW5kZXJIZWFkZXJDZWxscyhyYW5nZSQkMSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVDb250ZW50Um93LCB7XG4gICAgICAgIGlzQWxsRGF5OiB0cnVlLFxuICAgICAgICBydGw6IHJ0bCxcbiAgICAgICAgZ2V0Tm93OiBnZXROb3csXG4gICAgICAgIG1pblJvd3M6IDIsXG4gICAgICAgIHJhbmdlOiByYW5nZSQkMSxcbiAgICAgICAgZXZlbnRzOiBncm91cGVkRXZlbnRzLmdldChpZCkgfHwgW10sXG4gICAgICAgIHJlc291cmNlSWQ6IHJlc291cmNlICYmIGlkLFxuICAgICAgICBjbGFzc05hbWU6IFwicmJjLWFsbGRheS1jZWxsXCIsXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdGFibGUsXG4gICAgICAgIHNlbGVjdGVkOiBfdGhpczMucHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzLFxuICAgICAgICBnZXR0ZXJzOiBnZXR0ZXJzLFxuICAgICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplcixcbiAgICAgICAgb25TZWxlY3Q6IF90aGlzMy5wcm9wcy5vblNlbGVjdEV2ZW50LFxuICAgICAgICBvbkRvdWJsZUNsaWNrOiBfdGhpczMucHJvcHMub25Eb3VibGVDbGlja0V2ZW50LFxuICAgICAgICBvblNlbGVjdFNsb3Q6IF90aGlzMy5wcm9wcy5vblNlbGVjdFNsb3QsXG4gICAgICAgIGxvbmdQcmVzc1RocmVzaG9sZDogX3RoaXMzLnByb3BzLmxvbmdQcmVzc1RocmVzaG9sZFxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gVGltZUdyaWRIZWFkZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRpbWVHcmlkSGVhZGVyLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgcmFuZ2U6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBldmVudHM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICByZXNvdXJjZXM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdldE5vdzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNPdmVyZmxvd2luZzogUHJvcFR5cGVzLmJvb2wsXG4gIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsb2NhbGl6ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgYWNjZXNzb3JzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZ2V0dGVyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLm9uZU9mKFt0cnVlLCBmYWxzZSwgJ2lnbm9yZUV2ZW50cyddKSxcbiAgbG9uZ1ByZXNzVGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvblNlbGVjdFNsb3Q6IFByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdEV2ZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Eb3VibGVDbGlja0V2ZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmlsbERvd246IFByb3BUeXBlcy5mdW5jLFxuICBnZXREcmlsbGRvd25WaWV3OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzY3JvbGxSZWY6IFByb3BUeXBlcy5hbnlcbn0gOiB7fTtcblxudmFyIE5PTkUgPSB7fTtcbmZ1bmN0aW9uIFJlc291cmNlcyhyZXNvdXJjZXMsIGFjY2Vzc29ycykge1xuICByZXR1cm4ge1xuICAgIG1hcDogZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgICBpZiAoIXJlc291cmNlcykgcmV0dXJuIFtmbihbTk9ORSwgbnVsbF0sIDApXTtcbiAgICAgIHJldHVybiByZXNvdXJjZXMubWFwKGZ1bmN0aW9uIChyZXNvdXJjZSwgaWR4KSB7XG4gICAgICAgIHJldHVybiBmbihbYWNjZXNzb3JzLnJlc291cmNlSWQocmVzb3VyY2UpLCByZXNvdXJjZV0sIGlkeCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdyb3VwRXZlbnRzOiBmdW5jdGlvbiBncm91cEV2ZW50cyhldmVudHMkJDEpIHtcbiAgICAgIHZhciBldmVudHNCeVJlc291cmNlID0gbmV3IE1hcCgpO1xuXG4gICAgICBpZiAoIXJlc291cmNlcykge1xuICAgICAgICAvLyBSZXR1cm4gYWxsIGV2ZW50cyBpZiByZXNvdXJjZXMgYXJlIG5vdCBwcm92aWRlZFxuICAgICAgICBldmVudHNCeVJlc291cmNlLnNldChOT05FLCBldmVudHMkJDEpO1xuICAgICAgICByZXR1cm4gZXZlbnRzQnlSZXNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzJCQxLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBpZCA9IGFjY2Vzc29ycy5yZXNvdXJjZShldmVudCkgfHwgTk9ORTtcbiAgICAgICAgdmFyIHJlc291cmNlRXZlbnRzID0gZXZlbnRzQnlSZXNvdXJjZS5nZXQoaWQpIHx8IFtdO1xuICAgICAgICByZXNvdXJjZUV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgZXZlbnRzQnlSZXNvdXJjZS5zZXQoaWQsIHJlc291cmNlRXZlbnRzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV2ZW50c0J5UmVzb3VyY2U7XG4gICAgfVxuICB9O1xufVxuXG52YXIgVGltZUdyaWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZUdyaWQsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVHcmlkKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLnNjcm9sbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIF90aGlzLnNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbExlZnQgPSBlLnRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByYWYuY2FuY2VsKF90aGlzLnJhZkhhbmRsZSk7XG4gICAgICBfdGhpcy5yYWZIYW5kbGUgPSByYWYoX3RoaXMuY2hlY2tPdmVyZmxvdyk7XG4gICAgfTtcblxuICAgIF90aGlzLmd1dHRlclJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIF90aGlzLmd1dHRlciA9IHJlZiAmJiBmaW5kRE9NTm9kZShyZWYpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVTZWxlY3RBbGxkYXlFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vY2FuY2VsIGFueSBwZW5kaW5nIHNlbGVjdGlvbnMgc28gb25seSB0aGUgZXZlbnQgY2xpY2sgZ29lcyB0aHJvdWdoLlxuICAgICAgX3RoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIG5vdGlmeShfdGhpcy5wcm9wcy5vblNlbGVjdEV2ZW50LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU2VsZWN0QWxsRGF5U2xvdCA9IGZ1bmN0aW9uIChzbG90cywgc2xvdEluZm8pIHtcbiAgICAgIHZhciBvblNlbGVjdFNsb3QgPSBfdGhpcy5wcm9wcy5vblNlbGVjdFNsb3Q7XG4gICAgICBub3RpZnkob25TZWxlY3RTbG90LCB7XG4gICAgICAgIHNsb3RzOiBzbG90cyxcbiAgICAgICAgc3RhcnQ6IHNsb3RzWzBdLFxuICAgICAgICBlbmQ6IHNsb3RzW3Nsb3RzLmxlbmd0aCAtIDFdLFxuICAgICAgICBhY3Rpb246IHNsb3RJbmZvLmFjdGlvblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNoZWNrT3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuX3VwZGF0aW5nT3ZlcmZsb3cpIHJldHVybjtcbiAgICAgIHZhciBpc092ZXJmbG93aW5nID0gX3RoaXMucmVmcy5jb250ZW50LnNjcm9sbEhlaWdodCA+IF90aGlzLnJlZnMuY29udGVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5pc092ZXJmbG93aW5nICE9PSBpc092ZXJmbG93aW5nKSB7XG4gICAgICAgIF90aGlzLl91cGRhdGluZ092ZXJmbG93ID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaXNPdmVyZmxvd2luZzogaXNPdmVyZmxvd2luZ1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX3VwZGF0aW5nT3ZlcmZsb3cgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm1lbW9pemVkUmVzb3VyY2VzID0gbWVtb2l6ZShmdW5jdGlvbiAocmVzb3VyY2VzLCBhY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBSZXNvdXJjZXMocmVzb3VyY2VzLCBhY2Nlc3NvcnMpO1xuICAgIH0pO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgZ3V0dGVyV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgIGlzT3ZlcmZsb3dpbmc6IG51bGxcbiAgICB9O1xuICAgIF90aGlzLnNjcm9sbFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUaW1lR3JpZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVNjcm9sbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuY2hlY2tPdmVyZmxvdygpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMud2lkdGggPT0gbnVsbCkge1xuICAgICAgdGhpcy5tZWFzdXJlR3V0dGVyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseVNjcm9sbCgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICByYWYuY2FuY2VsKHRoaXMucmFmSGFuZGxlKTtcblxuICAgIGlmICh0aGlzLm1lYXN1cmVHdXR0ZXJBbmltYXRpb25GcmFtZVJlcXVlc3QpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVHdXR0ZXJBbmltYXRpb25GcmFtZVJlcXVlc3QpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnByb3BzLndpZHRoID09IG51bGwpIHtcbiAgICAgIHRoaXMubWVhc3VyZUd1dHRlcigpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwbHlTY3JvbGwoKTsgLy90aGlzLmNoZWNrT3ZlcmZsb3coKVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByYW5nZSQkMSA9IF90aGlzJHByb3BzLnJhbmdlLFxuICAgICAgICBzY3JvbGxUb1RpbWUgPSBfdGhpcyRwcm9wcy5zY3JvbGxUb1RpbWU7IC8vIFdoZW4gcGFnaW5hdGluZywgcmVzZXQgc2Nyb2xsXG5cbiAgICBpZiAoIWRhdGVzLmVxKG5leHRQcm9wcy5yYW5nZVswXSwgcmFuZ2UkJDFbMF0sICdtaW51dGUnKSB8fCAhZGF0ZXMuZXEobmV4dFByb3BzLnNjcm9sbFRvVGltZSwgc2Nyb2xsVG9UaW1lLCAnbWludXRlJykpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2Nyb2xsKG5leHRQcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXJFdmVudHMgPSBmdW5jdGlvbiByZW5kZXJFdmVudHMocmFuZ2UkJDEsIGV2ZW50cyQkMSwgbm93KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbWluID0gX3RoaXMkcHJvcHMyLm1pbixcbiAgICAgICAgbWF4ID0gX3RoaXMkcHJvcHMyLm1heCxcbiAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzMi5jb21wb25lbnRzLFxuICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wczIuYWNjZXNzb3JzLFxuICAgICAgICBsb2NhbGl6ZXIgPSBfdGhpcyRwcm9wczIubG9jYWxpemVyO1xuICAgIHZhciByZXNvdXJjZXMgPSB0aGlzLm1lbW9pemVkUmVzb3VyY2VzKHRoaXMucHJvcHMucmVzb3VyY2VzLCBhY2Nlc3NvcnMpO1xuICAgIHZhciBncm91cGVkRXZlbnRzID0gcmVzb3VyY2VzLmdyb3VwRXZlbnRzKGV2ZW50cyQkMSk7XG4gICAgcmV0dXJuIHJlc291cmNlcy5tYXAoZnVuY3Rpb24gKF9yZWYsIGkpIHtcbiAgICAgIHZhciBpZCA9IF9yZWZbMF0sXG4gICAgICAgICAgcmVzb3VyY2UgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIHJhbmdlJCQxLm1hcChmdW5jdGlvbiAoZGF0ZSwgamopIHtcbiAgICAgICAgdmFyIGRheXNFdmVudHMgPSAoZ3JvdXBlZEV2ZW50cy5nZXQoaWQpIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGVzLmluUmFuZ2UoZGF0ZSwgYWNjZXNzb3JzLnN0YXJ0KGV2ZW50KSwgYWNjZXNzb3JzLmVuZChldmVudCksICdkYXknKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERheUNvbHVtbiwgX2V4dGVuZHMoe30sIF90aGlzMi5wcm9wcywge1xuICAgICAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgICAgIG1pbjogZGF0ZXMubWVyZ2UoZGF0ZSwgbWluKSxcbiAgICAgICAgICBtYXg6IGRhdGVzLm1lcmdlKGRhdGUsIG1heCksXG4gICAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlICYmIGlkLFxuICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAgICAgaXNOb3c6IGRhdGVzLmVxKGRhdGUsIG5vdywgJ2RheScpLFxuICAgICAgICAgIGtleTogaSArICctJyArIGpqLFxuICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgZXZlbnRzOiBkYXlzRXZlbnRzXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGV2ZW50cyQkMSA9IF90aGlzJHByb3BzMy5ldmVudHMsXG4gICAgICAgIHJhbmdlJCQxID0gX3RoaXMkcHJvcHMzLnJhbmdlLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzMy53aWR0aCxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wczMuc2VsZWN0ZWQsXG4gICAgICAgIGdldE5vdyA9IF90aGlzJHByb3BzMy5nZXROb3csXG4gICAgICAgIHJlc291cmNlcyA9IF90aGlzJHByb3BzMy5yZXNvdXJjZXMsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wczMuY29tcG9uZW50cyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3RoaXMkcHJvcHMzLmFjY2Vzc29ycyxcbiAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzMy5nZXR0ZXJzLFxuICAgICAgICBsb2NhbGl6ZXIgPSBfdGhpcyRwcm9wczMubG9jYWxpemVyLFxuICAgICAgICBtaW4gPSBfdGhpcyRwcm9wczMubWluLFxuICAgICAgICBtYXggPSBfdGhpcyRwcm9wczMubWF4LFxuICAgICAgICBzaG93TXVsdGlEYXlUaW1lcyA9IF90aGlzJHByb3BzMy5zaG93TXVsdGlEYXlUaW1lcyxcbiAgICAgICAgbG9uZ1ByZXNzVGhyZXNob2xkID0gX3RoaXMkcHJvcHMzLmxvbmdQcmVzc1RocmVzaG9sZDtcbiAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuc3RhdGUuZ3V0dGVyV2lkdGg7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2UkJDFbMF0sXG4gICAgICAgIGVuZCA9IHJhbmdlJCQxW3JhbmdlJCQxLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuc2xvdHMgPSByYW5nZSQkMS5sZW5ndGg7XG4gICAgdmFyIGFsbERheUV2ZW50cyA9IFtdLFxuICAgICAgICByYW5nZUV2ZW50cyA9IFtdO1xuICAgIGV2ZW50cyQkMS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGluUmFuZ2UoZXZlbnQsIHN0YXJ0LCBlbmQsIGFjY2Vzc29ycykpIHtcbiAgICAgICAgdmFyIGVTdGFydCA9IGFjY2Vzc29ycy5zdGFydChldmVudCksXG4gICAgICAgICAgICBlRW5kID0gYWNjZXNzb3JzLmVuZChldmVudCk7XG5cbiAgICAgICAgaWYgKGFjY2Vzc29ycy5hbGxEYXkoZXZlbnQpIHx8IGRhdGVzLmlzSnVzdERhdGUoZVN0YXJ0KSAmJiBkYXRlcy5pc0p1c3REYXRlKGVFbmQpIHx8ICFzaG93TXVsdGlEYXlUaW1lcyAmJiAhZGF0ZXMuZXEoZVN0YXJ0LCBlRW5kLCAnZGF5JykpIHtcbiAgICAgICAgICBhbGxEYXlFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2VFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBhbGxEYXlFdmVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRFdmVudHMoYSwgYiwgYWNjZXNzb3JzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNuKCdyYmMtdGltZS12aWV3JywgcmVzb3VyY2VzICYmICdyYmMtdGltZS12aWV3LXJlc291cmNlcycpXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUaW1lR3JpZEhlYWRlciwge1xuICAgICAgcmFuZ2U6IHJhbmdlJCQxLFxuICAgICAgZXZlbnRzOiBhbGxEYXlFdmVudHMsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBnZXROb3c6IGdldE5vdyxcbiAgICAgIGxvY2FsaXplcjogbG9jYWxpemVyLFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgcmVzb3VyY2VzOiB0aGlzLm1lbW9pemVkUmVzb3VyY2VzKHJlc291cmNlcywgYWNjZXNzb3JzKSxcbiAgICAgIHNlbGVjdGFibGU6IHRoaXMucHJvcHMuc2VsZWN0YWJsZSxcbiAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzLFxuICAgICAgZ2V0dGVyczogZ2V0dGVycyxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBzY3JvbGxSZWY6IHRoaXMuc2Nyb2xsUmVmLFxuICAgICAgaXNPdmVyZmxvd2luZzogdGhpcy5zdGF0ZS5pc092ZXJmbG93aW5nLFxuICAgICAgbG9uZ1ByZXNzVGhyZXNob2xkOiBsb25nUHJlc3NUaHJlc2hvbGQsXG4gICAgICBvblNlbGVjdFNsb3Q6IHRoaXMuaGFuZGxlU2VsZWN0QWxsRGF5U2xvdCxcbiAgICAgIG9uU2VsZWN0RXZlbnQ6IHRoaXMuaGFuZGxlU2VsZWN0QWxsZGF5RXZlbnQsXG4gICAgICBvbkRvdWJsZUNsaWNrRXZlbnQ6IHRoaXMucHJvcHMub25Eb3VibGVDbGlja0V2ZW50LFxuICAgICAgb25EcmlsbERvd246IHRoaXMucHJvcHMub25EcmlsbERvd24sXG4gICAgICBnZXREcmlsbGRvd25WaWV3OiB0aGlzLnByb3BzLmdldERyaWxsZG93blZpZXdcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IFwiY29udGVudFwiLFxuICAgICAgY2xhc3NOYW1lOiBcInJiYy10aW1lLWNvbnRlbnRcIixcbiAgICAgIG9uU2Nyb2xsOiB0aGlzLmhhbmRsZVNjcm9sbFxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZUd1dHRlciwge1xuICAgICAgZGF0ZTogc3RhcnQsXG4gICAgICByZWY6IHRoaXMuZ3V0dGVyUmVmLFxuICAgICAgbG9jYWxpemVyOiBsb2NhbGl6ZXIsXG4gICAgICBtaW46IGRhdGVzLm1lcmdlKHN0YXJ0LCBtaW4pLFxuICAgICAgbWF4OiBkYXRlcy5tZXJnZShzdGFydCwgbWF4KSxcbiAgICAgIHN0ZXA6IHRoaXMucHJvcHMuc3RlcCxcbiAgICAgIGdldE5vdzogdGhpcy5wcm9wcy5nZXROb3csXG4gICAgICB0aW1lc2xvdHM6IHRoaXMucHJvcHMudGltZXNsb3RzLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtdGltZS1ndXR0ZXJcIlxuICAgIH0pLCB0aGlzLnJlbmRlckV2ZW50cyhyYW5nZSQkMSwgcmFuZ2VFdmVudHMsIGdldE5vdygpKSkpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zZWxlY3RUaW1lcik7XG4gICAgdGhpcy5fcGVuZGluZ1NlbGVjdGlvbiA9IFtdO1xuICB9O1xuXG4gIF9wcm90by5tZWFzdXJlR3V0dGVyID0gZnVuY3Rpb24gbWVhc3VyZUd1dHRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmICh0aGlzLm1lYXN1cmVHdXR0ZXJBbmltYXRpb25GcmFtZVJlcXVlc3QpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVHdXR0ZXJBbmltYXRpb25GcmFtZVJlcXVlc3QpO1xuICAgIH1cblxuICAgIHRoaXMubWVhc3VyZUd1dHRlckFuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdpZHRoID0gZ2V0V2lkdGgoX3RoaXMzLmd1dHRlcik7XG5cbiAgICAgIGlmICh3aWR0aCAmJiBfdGhpczMuc3RhdGUuZ3V0dGVyV2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZ3V0dGVyV2lkdGg6IHdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5hcHBseVNjcm9sbCA9IGZ1bmN0aW9uIGFwcGx5U2Nyb2xsKCkge1xuICAgIGlmICh0aGlzLl9zY3JvbGxSYXRpbykge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlZnMuY29udGVudDtcbiAgICAgIGNvbnRlbnQuc2Nyb2xsVG9wID0gY29udGVudC5zY3JvbGxIZWlnaHQgKiB0aGlzLl9zY3JvbGxSYXRpbzsgLy8gT25seSBkbyB0aGlzIG9uY2VcblxuICAgICAgdGhpcy5fc2Nyb2xsUmF0aW8gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2FsY3VsYXRlU2Nyb2xsID0gZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsKHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICAgIG1pbiA9IF9wcm9wcy5taW4sXG4gICAgICAgIG1heCA9IF9wcm9wcy5tYXgsXG4gICAgICAgIHNjcm9sbFRvVGltZSA9IF9wcm9wcy5zY3JvbGxUb1RpbWU7XG4gICAgdmFyIGRpZmZNaWxsaXMgPSBzY3JvbGxUb1RpbWUgLSBkYXRlcy5zdGFydE9mKHNjcm9sbFRvVGltZSwgJ2RheScpO1xuICAgIHZhciB0b3RhbE1pbGxpcyA9IGRhdGVzLmRpZmYobWF4LCBtaW4pO1xuICAgIHRoaXMuX3Njcm9sbFJhdGlvID0gZGlmZk1pbGxpcyAvIHRvdGFsTWlsbGlzO1xuICB9O1xuXG4gIHJldHVybiBUaW1lR3JpZDtcbn0oQ29tcG9uZW50KTtcblRpbWVHcmlkLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgcmVzb3VyY2VzOiBQcm9wVHlwZXMuYXJyYXksXG4gIHN0ZXA6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpbWVzbG90czogUHJvcFR5cGVzLm51bWJlcixcbiAgcmFuZ2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpKSxcbiAgbWluOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgbWF4OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgZ2V0Tm93OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzY3JvbGxUb1RpbWU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuICBzaG93TXVsdGlEYXlUaW1lczogUHJvcFR5cGVzLmJvb2wsXG4gIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBhY2Nlc3NvcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBnZXR0ZXJzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2FsaXplcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0YWJsZTogUHJvcFR5cGVzLm9uZU9mKFt0cnVlLCBmYWxzZSwgJ2lnbm9yZUV2ZW50cyddKSxcbiAgbG9uZ1ByZXNzVGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvbk5hdmlnYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RTbG90OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3RFdmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRG91YmxlQ2xpY2tFdmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRHJpbGxEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgZ2V0RHJpbGxkb3duVmlldzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSA6IHt9O1xuVGltZUdyaWQuZGVmYXVsdFByb3BzID0ge1xuICBzdGVwOiAzMCxcbiAgdGltZXNsb3RzOiAyLFxuICBtaW46IGRhdGVzLnN0YXJ0T2YobmV3IERhdGUoKSwgJ2RheScpLFxuICBtYXg6IGRhdGVzLmVuZE9mKG5ldyBEYXRlKCksICdkYXknKSxcbiAgc2Nyb2xsVG9UaW1lOiBkYXRlcy5zdGFydE9mKG5ldyBEYXRlKCksICdkYXknKVxufTtcblxudmFyIERheSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShEYXksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERheSgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGF5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRhdGUgPSBfdGhpcyRwcm9wcy5kYXRlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJkYXRlXCJdKTtcblxuICAgIHZhciByYW5nZSQkMSA9IERheS5yYW5nZShkYXRlKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUaW1lR3JpZCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByYW5nZTogcmFuZ2UkJDEsXG4gICAgICBldmVudE9mZnNldDogMTBcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIERheTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRGF5LnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZGF0ZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSkuaXNSZXF1aXJlZFxufSA6IHt9O1xuXG5EYXkucmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICByZXR1cm4gW2RhdGVzLnN0YXJ0T2YoZGF0ZSwgJ2RheScpXTtcbn07XG5cbkRheS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChkYXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIG5hdmlnYXRlLlBSRVZJT1VTOlxuICAgICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlLCAtMSwgJ2RheScpO1xuXG4gICAgY2FzZSBuYXZpZ2F0ZS5ORVhUOlxuICAgICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlLCAxLCAnZGF5Jyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGU7XG4gIH1cbn07XG5cbkRheS50aXRsZSA9IGZ1bmN0aW9uIChkYXRlLCBfcmVmKSB7XG4gIHZhciBsb2NhbGl6ZXIgPSBfcmVmLmxvY2FsaXplcjtcbiAgcmV0dXJuIGxvY2FsaXplci5mb3JtYXQoZGF0ZSwgJ2RheUhlYWRlckZvcm1hdCcpO1xufTtcblxudmFyIFdlZWsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoV2VlaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gV2VlaygpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gV2Vlay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRlID0gX3RoaXMkcHJvcHMuZGF0ZSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiZGF0ZVwiXSk7XG5cbiAgICB2YXIgcmFuZ2UkJDEgPSBXZWVrLnJhbmdlKGRhdGUsIHRoaXMucHJvcHMpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRpbWVHcmlkLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJhbmdlOiByYW5nZSQkMSxcbiAgICAgIGV2ZW50T2Zmc2V0OiAxNVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gV2Vlaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuV2Vlay5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGRhdGU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLmlzUmVxdWlyZWRcbn0gOiB7fTtcbldlZWsuZGVmYXVsdFByb3BzID0gVGltZUdyaWQuZGVmYXVsdFByb3BzO1xuXG5XZWVrLm5hdmlnYXRlID0gZnVuY3Rpb24gKGRhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbikge1xuICAgIGNhc2UgbmF2aWdhdGUuUFJFVklPVVM6XG4gICAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGUsIC0xLCAnd2VlaycpO1xuXG4gICAgY2FzZSBuYXZpZ2F0ZS5ORVhUOlxuICAgICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlLCAxLCAnd2VlaycpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlO1xuICB9XG59O1xuXG5XZWVrLnJhbmdlID0gZnVuY3Rpb24gKGRhdGUsIF9yZWYpIHtcbiAgdmFyIGxvY2FsaXplciA9IF9yZWYubG9jYWxpemVyO1xuICB2YXIgZmlyc3RPZldlZWsgPSBsb2NhbGl6ZXIuc3RhcnRPZldlZWsoKTtcbiAgdmFyIHN0YXJ0ID0gZGF0ZXMuc3RhcnRPZihkYXRlLCAnd2VlaycsIGZpcnN0T2ZXZWVrKTtcbiAgdmFyIGVuZCA9IGRhdGVzLmVuZE9mKGRhdGUsICd3ZWVrJywgZmlyc3RPZldlZWspO1xuICByZXR1cm4gZGF0ZXMucmFuZ2Uoc3RhcnQsIGVuZCk7XG59O1xuXG5XZWVrLnRpdGxlID0gZnVuY3Rpb24gKGRhdGUsIF9yZWYyKSB7XG4gIHZhciBsb2NhbGl6ZXIgPSBfcmVmMi5sb2NhbGl6ZXI7XG5cbiAgdmFyIF9XZWVrJHJhbmdlID0gV2Vlay5yYW5nZShkYXRlLCB7XG4gICAgbG9jYWxpemVyOiBsb2NhbGl6ZXJcbiAgfSksXG4gICAgICBzdGFydCA9IF9XZWVrJHJhbmdlWzBdLFxuICAgICAgcmVzdCA9IF9XZWVrJHJhbmdlLnNsaWNlKDEpO1xuXG4gIHJldHVybiBsb2NhbGl6ZXIuZm9ybWF0KHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiByZXN0LnBvcCgpXG4gIH0sICdkYXlSYW5nZUhlYWRlckZvcm1hdCcpO1xufTtcblxuZnVuY3Rpb24gd29ya1dlZWtSYW5nZShkYXRlLCBvcHRpb25zKSB7XG4gIHJldHVybiBXZWVrLnJhbmdlKGRhdGUsIG9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBbNiwgMF0uaW5kZXhPZihkLmdldERheSgpKSA9PT0gLTE7XG4gIH0pO1xufVxuXG52YXIgV29ya1dlZWsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoV29ya1dlZWssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFdvcmtXZWVrKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBXb3JrV2Vlay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRlID0gX3RoaXMkcHJvcHMuZGF0ZSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiZGF0ZVwiXSk7XG5cbiAgICB2YXIgcmFuZ2UkJDEgPSB3b3JrV2Vla1JhbmdlKGRhdGUsIHRoaXMucHJvcHMpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRpbWVHcmlkLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJhbmdlOiByYW5nZSQkMSxcbiAgICAgIGV2ZW50T2Zmc2V0OiAxNVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gV29ya1dlZWs7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbldvcmtXZWVrLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZGF0ZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSkuaXNSZXF1aXJlZFxufSA6IHt9O1xuV29ya1dlZWsuZGVmYXVsdFByb3BzID0gVGltZUdyaWQuZGVmYXVsdFByb3BzO1xuV29ya1dlZWsucmFuZ2UgPSB3b3JrV2Vla1JhbmdlO1xuV29ya1dlZWsubmF2aWdhdGUgPSBXZWVrLm5hdmlnYXRlO1xuXG5Xb3JrV2Vlay50aXRsZSA9IGZ1bmN0aW9uIChkYXRlLCBfcmVmKSB7XG4gIHZhciBsb2NhbGl6ZXIgPSBfcmVmLmxvY2FsaXplcjtcblxuICB2YXIgX3dvcmtXZWVrUmFuZ2UgPSB3b3JrV2Vla1JhbmdlKGRhdGUsIHtcbiAgICBsb2NhbGl6ZXI6IGxvY2FsaXplclxuICB9KSxcbiAgICAgIHN0YXJ0ID0gX3dvcmtXZWVrUmFuZ2VbMF0sXG4gICAgICByZXN0ID0gX3dvcmtXZWVrUmFuZ2Uuc2xpY2UoMSk7XG5cbiAgcmV0dXJuIGxvY2FsaXplci5mb3JtYXQoe1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IHJlc3QucG9wKClcbiAgfSwgJ2RheVJhbmdlSGVhZGVyRm9ybWF0Jyk7XG59O1xuXG52YXIgQWdlbmRhID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEFnZW5kYSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQWdlbmRhKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucmVuZGVyRGF5ID0gZnVuY3Rpb24gKGRheSwgZXZlbnRzJCQxLCBkYXlLZXkpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgICAgZ2V0dGVycyA9IF90aGlzJHByb3BzLmdldHRlcnMsXG4gICAgICAgICAgYWNjZXNzb3JzID0gX3RoaXMkcHJvcHMuYWNjZXNzb3JzLFxuICAgICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzLmxvY2FsaXplcixcbiAgICAgICAgICBfdGhpcyRwcm9wcyRjb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIEV2ZW50ID0gX3RoaXMkcHJvcHMkY29tcG9uZW50LmV2ZW50LFxuICAgICAgICAgIEFnZW5kYURhdGUgPSBfdGhpcyRwcm9wcyRjb21wb25lbnQuZGF0ZTtcbiAgICAgIGV2ZW50cyQkMSA9IGV2ZW50cyQkMS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UoZSwgZGF0ZXMuc3RhcnRPZihkYXksICdkYXknKSwgZGF0ZXMuZW5kT2YoZGF5LCAnZGF5JyksIGFjY2Vzc29ycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBldmVudHMkJDEubWFwKGZ1bmN0aW9uIChldmVudCwgaWR4KSB7XG4gICAgICAgIHZhciB0aXRsZSA9IGFjY2Vzc29ycy50aXRsZShldmVudCk7XG4gICAgICAgIHZhciBlbmQgPSBhY2Nlc3NvcnMuZW5kKGV2ZW50KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYWNjZXNzb3JzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgdmFyIHVzZXJQcm9wcyA9IGdldHRlcnMuZXZlbnRQcm9wKGV2ZW50LCBzdGFydCwgZW5kLCBpc1NlbGVjdGVkKGV2ZW50LCBzZWxlY3RlZCkpO1xuICAgICAgICB2YXIgZGF0ZUxhYmVsID0gaWR4ID09PSAwICYmIGxvY2FsaXplci5mb3JtYXQoZGF5LCAnYWdlbmRhRGF0ZUZvcm1hdCcpO1xuICAgICAgICB2YXIgZmlyc3QgPSBpZHggPT09IDAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwge1xuICAgICAgICAgIHJvd1NwYW46IGV2ZW50cyQkMS5sZW5ndGgsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJiYy1hZ2VuZGEtZGF0ZS1jZWxsXCJcbiAgICAgICAgfSwgQWdlbmRhRGF0ZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWdlbmRhRGF0ZSwge1xuICAgICAgICAgIGRheTogZGF5LFxuICAgICAgICAgIGxhYmVsOiBkYXRlTGFiZWxcbiAgICAgICAgfSkgOiBkYXRlTGFiZWwpIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwge1xuICAgICAgICAgIGtleTogZGF5S2V5ICsgJ18nICsgaWR4LFxuICAgICAgICAgIGNsYXNzTmFtZTogdXNlclByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZTogdXNlclByb3BzLnN0eWxlXG4gICAgICAgIH0sIGZpcnN0LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyYmMtYWdlbmRhLXRpbWUtY2VsbFwiXG4gICAgICAgIH0sIF90aGlzLnRpbWVSYW5nZUxhYmVsKGRheSwgZXZlbnQpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmJjLWFnZW5kYS1ldmVudC1jZWxsXCJcbiAgICAgICAgfSwgRXZlbnQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KEV2ZW50LCB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICB9KSA6IHRpdGxlKSk7XG4gICAgICB9LCBbXSk7XG4gICAgfTtcblxuICAgIF90aGlzLnRpbWVSYW5nZUxhYmVsID0gZnVuY3Rpb24gKGRheSwgZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRwcm9wczIuYWNjZXNzb3JzLFxuICAgICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzMi5sb2NhbGl6ZXIsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzMi5jb21wb25lbnRzO1xuICAgICAgdmFyIGxhYmVsQ2xhc3MgPSAnJyxcbiAgICAgICAgICBUaW1lQ29tcG9uZW50ID0gY29tcG9uZW50cy50aW1lLFxuICAgICAgICAgIGxhYmVsID0gbG9jYWxpemVyLm1lc3NhZ2VzLmFsbERheTtcbiAgICAgIHZhciBlbmQgPSBhY2Nlc3NvcnMuZW5kKGV2ZW50KTtcbiAgICAgIHZhciBzdGFydCA9IGFjY2Vzc29ycy5zdGFydChldmVudCk7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzLmFsbERheShldmVudCkpIHtcbiAgICAgICAgaWYgKGRhdGVzLmVxKHN0YXJ0LCBlbmQsICdkYXknKSkge1xuICAgICAgICAgIGxhYmVsID0gbG9jYWxpemVyLmZvcm1hdCh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgIH0sICdhZ2VuZGFUaW1lUmFuZ2VGb3JtYXQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlcy5lcShkYXksIHN0YXJ0LCAnZGF5JykpIHtcbiAgICAgICAgICBsYWJlbCA9IGxvY2FsaXplci5mb3JtYXQoc3RhcnQsICdhZ2VuZGFUaW1lRm9ybWF0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0ZXMuZXEoZGF5LCBlbmQsICdkYXknKSkge1xuICAgICAgICAgIGxhYmVsID0gbG9jYWxpemVyLmZvcm1hdChlbmQsICdhZ2VuZGFUaW1lRm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGVzLmd0KGRheSwgc3RhcnQsICdkYXknKSkgbGFiZWxDbGFzcyA9ICdyYmMtY29udGludWVzLXByaW9yJztcbiAgICAgIGlmIChkYXRlcy5sdChkYXksIGVuZCwgJ2RheScpKSBsYWJlbENsYXNzICs9ICcgcmJjLWNvbnRpbnVlcy1hZnRlcic7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IGxhYmVsQ2xhc3MudHJpbSgpXG4gICAgICB9LCBUaW1lQ29tcG9uZW50ID8gUmVhY3QuY3JlYXRlRWxlbWVudChUaW1lQ29tcG9uZW50LCB7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgfSkgOiBsYWJlbCk7XG4gICAgfTtcblxuICAgIF90aGlzLl9hZGp1c3RIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnJlZnMudGJvZHkpIHJldHVybjtcbiAgICAgIHZhciBoZWFkZXIgPSBfdGhpcy5yZWZzLmhlYWRlcjtcbiAgICAgIHZhciBmaXJzdFJvdyA9IF90aGlzLnJlZnMudGJvZHkuZmlyc3RDaGlsZDtcbiAgICAgIGlmICghZmlyc3RSb3cpIHJldHVybjtcbiAgICAgIHZhciBpc092ZXJmbG93aW5nID0gX3RoaXMucmVmcy5jb250ZW50LnNjcm9sbEhlaWdodCA+IF90aGlzLnJlZnMuY29udGVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgd2lkdGhzID0gX3RoaXMuX3dpZHRocyB8fCBbXTtcbiAgICAgIF90aGlzLl93aWR0aHMgPSBbZ2V0V2lkdGgoZmlyc3RSb3cuY2hpbGRyZW5bMF0pLCBnZXRXaWR0aChmaXJzdFJvdy5jaGlsZHJlblsxXSldO1xuXG4gICAgICBpZiAod2lkdGhzWzBdICE9PSBfdGhpcy5fd2lkdGhzWzBdIHx8IHdpZHRoc1sxXSAhPT0gX3RoaXMuX3dpZHRoc1sxXSkge1xuICAgICAgICBfdGhpcy5yZWZzLmRhdGVDb2wuc3R5bGUud2lkdGggPSBfdGhpcy5fd2lkdGhzWzBdICsgJ3B4JztcbiAgICAgICAgX3RoaXMucmVmcy50aW1lQ29sLnN0eWxlLndpZHRoID0gX3RoaXMuX3dpZHRoc1sxXSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc092ZXJmbG93aW5nKSB7XG4gICAgICAgIGNsYXNzZXMuYWRkQ2xhc3MoaGVhZGVyLCAncmJjLWhlYWRlci1vdmVyZmxvd2luZycpO1xuICAgICAgICBoZWFkZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBzY3JvbGxiYXJTaXplKCkgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3Nlcy5yZW1vdmVDbGFzcyhoZWFkZXIsICdyYmMtaGVhZGVyLW92ZXJmbG93aW5nJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBZ2VuZGEucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2FkanVzdEhlYWRlcigpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0SGVhZGVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBsZW5ndGggPSBfdGhpcyRwcm9wczMubGVuZ3RoLFxuICAgICAgICBkYXRlID0gX3RoaXMkcHJvcHMzLmRhdGUsXG4gICAgICAgIGV2ZW50cyQkMSA9IF90aGlzJHByb3BzMy5ldmVudHMsXG4gICAgICAgIGFjY2Vzc29ycyA9IF90aGlzJHByb3BzMy5hY2Nlc3NvcnMsXG4gICAgICAgIGxvY2FsaXplciA9IF90aGlzJHByb3BzMy5sb2NhbGl6ZXI7XG4gICAgdmFyIG1lc3NhZ2VzID0gbG9jYWxpemVyLm1lc3NhZ2VzO1xuICAgIHZhciBlbmQgPSBkYXRlcy5hZGQoZGF0ZSwgbGVuZ3RoLCAnZGF5Jyk7XG4gICAgdmFyIHJhbmdlJCQxID0gZGF0ZXMucmFuZ2UoZGF0ZSwgZW5kLCAnZGF5Jyk7XG4gICAgZXZlbnRzJCQxID0gZXZlbnRzJCQxLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBpblJhbmdlKGV2ZW50LCBkYXRlLCBlbmQsIGFjY2Vzc29ycyk7XG4gICAgfSk7XG4gICAgZXZlbnRzJCQxLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiArYWNjZXNzb3JzLnN0YXJ0KGEpIC0gK2FjY2Vzc29ycy5zdGFydChiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLWFnZW5kYS12aWV3XCJcbiAgICB9LCBldmVudHMkJDEubGVuZ3RoICE9PSAwID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHtcbiAgICAgIHJlZjogXCJoZWFkZXJcIixcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtYWdlbmRhLXRhYmxlXCJcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhlYWRcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLWhlYWRlclwiLFxuICAgICAgcmVmOiBcImRhdGVDb2xcIlxuICAgIH0sIG1lc3NhZ2VzLmRhdGUpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1oZWFkZXJcIixcbiAgICAgIHJlZjogXCJ0aW1lQ29sXCJcbiAgICB9LCBtZXNzYWdlcy50aW1lKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRoXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtaGVhZGVyXCJcbiAgICB9LCBtZXNzYWdlcy5ldmVudCkpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1hZ2VuZGEtY29udGVudFwiLFxuICAgICAgcmVmOiBcImNvbnRlbnRcIlxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmJjLWFnZW5kYS10YWJsZVwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHtcbiAgICAgIHJlZjogXCJ0Ym9keVwiXG4gICAgfSwgcmFuZ2UkJDEubWFwKGZ1bmN0aW9uIChkYXksIGlkeCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJEYXkoZGF5LCBldmVudHMkJDEsIGlkeCk7XG4gICAgfSkpKSkpIDogUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1hZ2VuZGEtZW1wdHlcIlxuICAgIH0sIG1lc3NhZ2VzLm5vRXZlbnRzSW5SYW5nZSkpO1xuICB9O1xuXG4gIHJldHVybiBBZ2VuZGE7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkFnZW5kYS5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGV2ZW50czogUHJvcFR5cGVzLmFycmF5LFxuICBkYXRlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgbGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY2Nlc3NvcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY29tcG9uZW50czogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBnZXR0ZXJzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2FsaXplcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59IDoge307XG5BZ2VuZGEuZGVmYXVsdFByb3BzID0ge1xuICBsZW5ndGg6IDMwXG59O1xuXG5BZ2VuZGEucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIF9yZWYpIHtcbiAgdmFyIF9yZWYkbGVuZ3RoID0gX3JlZi5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBfcmVmJGxlbmd0aCA9PT0gdm9pZCAwID8gQWdlbmRhLmRlZmF1bHRQcm9wcy5sZW5ndGggOiBfcmVmJGxlbmd0aDtcbiAgdmFyIGVuZCA9IGRhdGVzLmFkZChzdGFydCwgbGVuZ3RoLCAnZGF5Jyk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59O1xuXG5BZ2VuZGEubmF2aWdhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgYWN0aW9uLCBfcmVmMikge1xuICB2YXIgX3JlZjIkbGVuZ3RoID0gX3JlZjIubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gX3JlZjIkbGVuZ3RoID09PSB2b2lkIDAgPyBBZ2VuZGEuZGVmYXVsdFByb3BzLmxlbmd0aCA6IF9yZWYyJGxlbmd0aDtcblxuICBzd2l0Y2ggKGFjdGlvbikge1xuICAgIGNhc2UgbmF2aWdhdGUuUFJFVklPVVM6XG4gICAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGUsIC1sZW5ndGgsICdkYXknKTtcblxuICAgIGNhc2UgbmF2aWdhdGUuTkVYVDpcbiAgICAgIHJldHVybiBkYXRlcy5hZGQoZGF0ZSwgbGVuZ3RoLCAnZGF5Jyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGU7XG4gIH1cbn07XG5cbkFnZW5kYS50aXRsZSA9IGZ1bmN0aW9uIChzdGFydCwgX3JlZjMpIHtcbiAgdmFyIF9yZWYzJGxlbmd0aCA9IF9yZWYzLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IF9yZWYzJGxlbmd0aCA9PT0gdm9pZCAwID8gQWdlbmRhLmRlZmF1bHRQcm9wcy5sZW5ndGggOiBfcmVmMyRsZW5ndGgsXG4gICAgICBsb2NhbGl6ZXIgPSBfcmVmMy5sb2NhbGl6ZXI7XG4gIHZhciBlbmQgPSBkYXRlcy5hZGQoc3RhcnQsIGxlbmd0aCwgJ2RheScpO1xuICByZXR1cm4gbG9jYWxpemVyLmZvcm1hdCh7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH0sICdhZ2VuZGFIZWFkZXJGb3JtYXQnKTtcbn07XG5cbnZhciBfVklFV1M7XG52YXIgVklFV1MgPSAoX1ZJRVdTID0ge30sIF9WSUVXU1t2aWV3cy5NT05USF0gPSBNb250aFZpZXcsIF9WSUVXU1t2aWV3cy5XRUVLXSA9IFdlZWssIF9WSUVXU1t2aWV3cy5XT1JLX1dFRUtdID0gV29ya1dlZWssIF9WSUVXU1t2aWV3cy5EQVldID0gRGF5LCBfVklFV1Nbdmlld3MuQUdFTkRBXSA9IEFnZW5kYSwgX1ZJRVdTKTtcblxuZnVuY3Rpb24gbW92ZURhdGUoVmlldywgX3JlZikge1xuICB2YXIgYWN0aW9uID0gX3JlZi5hY3Rpb24sXG4gICAgICBkYXRlID0gX3JlZi5kYXRlLFxuICAgICAgdG9kYXkgPSBfcmVmLnRvZGF5LFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhY3Rpb25cIiwgXCJkYXRlXCIsIFwidG9kYXlcIl0pO1xuXG4gIFZpZXcgPSB0eXBlb2YgVmlldyA9PT0gJ3N0cmluZycgPyBWSUVXU1tWaWV3XSA6IFZpZXc7XG5cbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIG5hdmlnYXRlLlRPREFZOlxuICAgICAgZGF0ZSA9IHRvZGF5IHx8IG5ldyBEYXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbmF2aWdhdGUuREFURTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgICEoVmlldyAmJiB0eXBlb2YgVmlldy5uYXZpZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYWxlbmRhciBWaWV3IGNvbXBvbmVudHMgbXVzdCBpbXBsZW1lbnQgYSBzdGF0aWMgYC5uYXZpZ2F0ZShkYXRlLCBhY3Rpb24pYCBtZXRob2QucycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGRhdGUgPSBWaWV3Lm5hdmlnYXRlKGRhdGUsIGFjdGlvbiwgcHJvcHMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbnZhciBUb29sYmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRvb2xiYXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRvb2xiYXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIF90aGlzLnByb3BzLm9uTmF2aWdhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgX3RoaXMudmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICBfdGhpcy5wcm9wcy5vblZpZXcodmlldyk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb29sYmFyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1lc3NhZ2VzID0gX3RoaXMkcHJvcHMubG9jYWxpemVyLm1lc3NhZ2VzLFxuICAgICAgICBsYWJlbCA9IF90aGlzJHByb3BzLmxhYmVsO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtdG9vbGJhclwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy1idG4tZ3JvdXBcIlxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IHRoaXMubmF2aWdhdGUuYmluZChudWxsLCBuYXZpZ2F0ZS5UT0RBWSlcbiAgICB9LCBtZXNzYWdlcy50b2RheSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IHRoaXMubmF2aWdhdGUuYmluZChudWxsLCBuYXZpZ2F0ZS5QUkVWSU9VUylcbiAgICB9LCBtZXNzYWdlcy5wcmV2aW91cyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IHRoaXMubmF2aWdhdGUuYmluZChudWxsLCBuYXZpZ2F0ZS5ORVhUKVxuICAgIH0sIG1lc3NhZ2VzLm5leHQpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInJiYy10b29sYmFyLWxhYmVsXCJcbiAgICB9LCBsYWJlbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyYmMtYnRuLWdyb3VwXCJcbiAgICB9LCB0aGlzLnZpZXdOYW1lc0dyb3VwKG1lc3NhZ2VzKSkpO1xuICB9O1xuXG4gIF9wcm90by52aWV3TmFtZXNHcm91cCA9IGZ1bmN0aW9uIHZpZXdOYW1lc0dyb3VwKG1lc3NhZ2VzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdmlld05hbWVzID0gdGhpcy5wcm9wcy52aWV3cztcbiAgICB2YXIgdmlldyA9IHRoaXMucHJvcHMudmlldztcblxuICAgIGlmICh2aWV3TmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHZpZXdOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAga2V5OiBuYW1lLFxuICAgICAgICAgIGNsYXNzTmFtZTogY24oe1xuICAgICAgICAgICAgJ3JiYy1hY3RpdmUnOiB2aWV3ID09PSBuYW1lXG4gICAgICAgICAgfSksXG4gICAgICAgICAgb25DbGljazogX3RoaXMyLnZpZXcuYmluZChudWxsLCBuYW1lKVxuICAgICAgICB9LCBtZXNzYWdlc1tuYW1lXSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRvb2xiYXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRvb2xiYXIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICB2aWV3OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHZpZXdzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKS5pc1JlcXVpcmVkLFxuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgbG9jYWxpemVyOiBQcm9wVHlwZXMub2JqZWN0LFxuICBvbk5hdmlnYXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvblZpZXc6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0gOiB7fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB2aWEgYW4gYWNjZXNzb3ItbGlrZSBwcm9wZXJ0eVxuICpcbiAqICAgIGFjY2Vzc29yKG9iaiwgJ25hbWUnKSAgIC8vID0+IHJldHJpZXZlcyBvYmpbJ25hbWUnXVxuICogICAgYWNjZXNzb3IoZGF0YSwgZnVuYykgICAgLy8gPT4gcmV0cmlldmVzIGZ1bmMoZGF0YSlcbiAqICAgIC4uLiBvdGhlcndpc2UgbnVsbFxuICovXG5mdW5jdGlvbiBhY2Nlc3NvciQxKGRhdGEsIGZpZWxkKSB7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIGlmICh0eXBlb2YgZmllbGQgPT09ICdmdW5jdGlvbicpIHZhbHVlID0gZmllbGQoZGF0YSk7ZWxzZSBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPSBudWxsICYmIGZpZWxkIGluIGRhdGEpIHZhbHVlID0gZGF0YVtmaWVsZF07XG4gIHJldHVybiB2YWx1ZTtcbn1cbnZhciB3cmFwQWNjZXNzb3IgPSBmdW5jdGlvbiB3cmFwQWNjZXNzb3IoYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBhY2Nlc3NvciQxKGRhdGEsIGFjYyk7XG4gIH07XG59O1xuXG5mdW5jdGlvbiB2aWV3TmFtZXMkMShfdmlld3MpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KF92aWV3cykgPyBPYmplY3Qua2V5cyhfdmlld3MpIDogX3ZpZXdzO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkVmlldyh2aWV3LCBfcmVmKSB7XG4gIHZhciBfdmlld3MgPSBfcmVmLnZpZXdzO1xuICB2YXIgbmFtZXMgPSB2aWV3TmFtZXMkMShfdmlld3MpO1xuICByZXR1cm4gbmFtZXMuaW5kZXhPZih2aWV3KSAhPT0gLTE7XG59XG4vKipcbiAqIHJlYWN0LWJpZy1jYWxlbmRhciBpcyBhIGZ1bGwgZmVhdHVyZWQgQ2FsZW5kYXIgY29tcG9uZW50IGZvciBtYW5hZ2luZyBldmVudHMgYW5kIGRhdGVzLiBJdCB1c2VzXG4gKiBtb2Rlcm4gYGZsZXhib3hgIGZvciBsYXlvdXQsIG1ha2luZyBpdCBzdXBlciByZXNwb25zaXZlIGFuZCBwZXJmb3JtYW50LiBMZWF2aW5nIG1vc3Qgb2YgdGhlIGxheW91dCBoZWF2eSBsaWZ0aW5nXG4gKiB0byB0aGUgYnJvd3Nlci4gX19ub3RlOl9fIFRoZSBkZWZhdWx0IHN0eWxlcyB1c2UgYGhlaWdodDogMTAwJWAgd2hpY2ggbWVhbnMgeW91ciBjb250YWluZXIgbXVzdCBzZXQgYW4gZXhwbGljaXRcbiAqIGhlaWdodCAoZmVlbCBmcmVlIHRvIGFkanVzdCB0aGUgc3R5bGVzIHRvIHN1aXQgeW91ciBzcGVjaWZpYyBuZWVkcykuXG4gKlxuICogQmlnIENhbGVuZGFyIGlzIHVub3BpbmlhdGVkIGFib3V0IGVkaXRpbmcgYW5kIG1vdmluZyBldmVudHMsIHByZWZlcnJpbmcgdG8gbGV0IHlvdSBpbXBsZW1lbnQgaXQgaW4gYSB3YXkgdGhhdCBtYWtlc1xuICogdGhlIG1vc3Qgc2Vuc2UgdG8geW91ciBhcHAuIEl0IGFsc28gdHJpZXMgbm90IHRvIGJlIHByZXNjcmlwdGl2ZSBhYm91dCB5b3VyIGV2ZW50IGRhdGEgc3RydWN0dXJlcywganVzdCB0ZWxsIGl0XG4gKiBob3cgdG8gZmluZCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRldGltZXMgYW5kIHlvdSBjYW4gcGFzcyBpdCB3aGF0ZXZlciB5b3Ugd2FudC5cbiAqXG4gKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0LCBgcmVhY3QtYmlnLWNhbGVuZGFyYCB0cmVhdHMgZXZlbnQgc3RhcnQvZW5kIGRhdGVzIGFzIGFuIF9leGNsdXNpdmVfIHJhbmdlLlxuICogd2hpY2ggbWVhbnMgdGhhdCB0aGUgZXZlbnQgc3BhbnMgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZW5kIGRhdGUuIEluIHRoZSBjYXNlXG4gKiBvZiBkaXNwbGF5aW5nIGV2ZW50cyBvbiB3aG9sZSBkYXlzLCBlbmQgZGF0ZXMgYXJlIHJvdW5kZWQgX3VwXyB0byB0aGUgbmV4dCBkYXkuIFNvIGFuXG4gKiBldmVudCBlbmRpbmcgb24gYEFwciA4dGggMTI6MDA6MDAgYW1gIHdpbGwgbm90IGFwcGVhciBvbiB0aGUgOHRoLCB3aGVyZWFzIG9uZSBlbmRpbmdcbiAqIG9uIGBBcHIgOHRoIDEyOjAxOjAwIGFtYCB3aWxsLiBJZiB5b3Ugd2FudCBfaW5jbHVzaXZlXyByYW5nZXMgY29uc2lkZXIgcHJvdmlkaW5nIGFcbiAqIGZ1bmN0aW9uIGBlbmRBY2Nlc3NvcmAgdGhhdCByZXR1cm5zIHRoZSBlbmQgZGF0ZSArIDEgZGF5IGZvciB0aG9zZSBldmVudHMgdGhhdCBlbmQgYXQgbWlkbmlnaHQuXG4gKi9cblxuXG52YXIgQ2FsZW5kYXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENhbGVuZGFyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuZ2V0Vmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmlld3MkJDEgPSBfdGhpcy5wcm9wcy52aWV3cztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlld3MkJDEpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0odmlld3MkJDEsIGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW25hbWVdID0gVklFV1NbbmFtZV07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2aWV3cyQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG1hcFZhbHVlcyh2aWV3cyQkMSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBWSUVXU1trZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBWSUVXUztcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2aWV3cyQkMSA9IF90aGlzLmdldFZpZXdzKCk7XG5cbiAgICAgIHJldHVybiB2aWV3cyQkMVtfdGhpcy5wcm9wcy52aWV3XTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0RHJpbGxkb3duVmlldyA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICB2aWV3ID0gX3RoaXMkcHJvcHMudmlldyxcbiAgICAgICAgICBkcmlsbGRvd25WaWV3ID0gX3RoaXMkcHJvcHMuZHJpbGxkb3duVmlldyxcbiAgICAgICAgICBnZXREcmlsbGRvd25WaWV3ID0gX3RoaXMkcHJvcHMuZ2V0RHJpbGxkb3duVmlldztcbiAgICAgIGlmICghZ2V0RHJpbGxkb3duVmlldykgcmV0dXJuIGRyaWxsZG93blZpZXc7XG4gICAgICByZXR1cm4gZ2V0RHJpbGxkb3duVmlldyhkYXRlLCB2aWV3LCBPYmplY3Qua2V5cyhfdGhpcy5nZXRWaWV3cygpKSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVJhbmdlQ2hhbmdlID0gZnVuY3Rpb24gKGRhdGUsIHZpZXdDb21wb25lbnQsIHZpZXcpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBvblJhbmdlQ2hhbmdlID0gX3RoaXMkcHJvcHMyLm9uUmFuZ2VDaGFuZ2UsXG4gICAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkcHJvcHMyLmxvY2FsaXplcjtcblxuICAgICAgaWYgKG9uUmFuZ2VDaGFuZ2UpIHtcbiAgICAgICAgaWYgKHZpZXdDb21wb25lbnQucmFuZ2UpIHtcbiAgICAgICAgICBvblJhbmdlQ2hhbmdlKHZpZXdDb21wb25lbnQucmFuZ2UoZGF0ZSwge1xuICAgICAgICAgICAgbG9jYWxpemVyOiBsb2NhbGl6ZXJcbiAgICAgICAgICB9KSwgdmlldyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyh0cnVlLCAnb25SYW5nZUNoYW5nZSBwcm9wIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgdmlldycpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU5hdmlnYXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgbmV3RGF0ZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHZpZXcgPSBfdGhpcyRwcm9wczMudmlldyxcbiAgICAgICAgICBkYXRlID0gX3RoaXMkcHJvcHMzLmRhdGUsXG4gICAgICAgICAgZ2V0Tm93ID0gX3RoaXMkcHJvcHMzLmdldE5vdyxcbiAgICAgICAgICBvbk5hdmlnYXRlID0gX3RoaXMkcHJvcHMzLm9uTmF2aWdhdGUsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczMsIFtcInZpZXdcIiwgXCJkYXRlXCIsIFwiZ2V0Tm93XCIsIFwib25OYXZpZ2F0ZVwiXSk7XG5cbiAgICAgIHZhciBWaWV3Q29tcG9uZW50ID0gX3RoaXMuZ2V0VmlldygpO1xuXG4gICAgICB2YXIgdG9kYXkgPSBnZXROb3coKTtcbiAgICAgIGRhdGUgPSBtb3ZlRGF0ZShWaWV3Q29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGRhdGU6IG5ld0RhdGUgfHwgZGF0ZSB8fCB0b2RheSxcbiAgICAgICAgdG9kYXk6IHRvZGF5XG4gICAgICB9KSk7XG4gICAgICBvbk5hdmlnYXRlKGRhdGUsIHZpZXcsIGFjdGlvbik7XG5cbiAgICAgIF90aGlzLmhhbmRsZVJhbmdlQ2hhbmdlKGRhdGUsIFZpZXdDb21wb25lbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVWaWV3Q2hhbmdlID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIGlmICh2aWV3ICE9PSBfdGhpcy5wcm9wcy52aWV3ICYmIGlzVmFsaWRWaWV3KHZpZXcsIF90aGlzLnByb3BzKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vblZpZXcodmlldyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3cyQkMSA9IF90aGlzLmdldFZpZXdzKCk7XG5cbiAgICAgIF90aGlzLmhhbmRsZVJhbmdlQ2hhbmdlKF90aGlzLnByb3BzLmRhdGUgfHwgX3RoaXMucHJvcHMuZ2V0Tm93KCksIHZpZXdzJCQxW3ZpZXddLCB2aWV3KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU2VsZWN0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBub3RpZnkoX3RoaXMucHJvcHMub25TZWxlY3RFdmVudCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZURvdWJsZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICBub3RpZnkoX3RoaXMucHJvcHMub25Eb3VibGVDbGlja0V2ZW50LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU2VsZWN0U2xvdCA9IGZ1bmN0aW9uIChzbG90SW5mbykge1xuICAgICAgbm90aWZ5KF90aGlzLnByb3BzLm9uU2VsZWN0U2xvdCwgc2xvdEluZm8pO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVEcmlsbERvd24gPSBmdW5jdGlvbiAoZGF0ZSwgdmlldykge1xuICAgICAgdmFyIG9uRHJpbGxEb3duID0gX3RoaXMucHJvcHMub25EcmlsbERvd247XG5cbiAgICAgIGlmIChvbkRyaWxsRG93bikge1xuICAgICAgICBvbkRyaWxsRG93bihkYXRlLCB2aWV3LCBfdGhpcy5kcmlsbGRvd25WaWV3KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlldykgX3RoaXMuaGFuZGxlVmlld0NoYW5nZSh2aWV3KTtcblxuICAgICAgX3RoaXMuaGFuZGxlTmF2aWdhdGUobmF2aWdhdGUuREFURSwgZGF0ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY29udGV4dDogX3RoaXMuZ2V0Q29udGV4dChfdGhpcy5wcm9wcylcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYWxlbmRhci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY29udGV4dDogdGhpcy5nZXRDb250ZXh0KG5leHRQcm9wcylcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQoX3JlZjIpIHtcbiAgICB2YXIgc3RhcnRBY2Nlc3NvciA9IF9yZWYyLnN0YXJ0QWNjZXNzb3IsXG4gICAgICAgIGVuZEFjY2Vzc29yID0gX3JlZjIuZW5kQWNjZXNzb3IsXG4gICAgICAgIGFsbERheUFjY2Vzc29yID0gX3JlZjIuYWxsRGF5QWNjZXNzb3IsXG4gICAgICAgIHRvb2x0aXBBY2Nlc3NvciA9IF9yZWYyLnRvb2x0aXBBY2Nlc3NvcixcbiAgICAgICAgdGl0bGVBY2Nlc3NvciA9IF9yZWYyLnRpdGxlQWNjZXNzb3IsXG4gICAgICAgIHJlc291cmNlQWNjZXNzb3IgPSBfcmVmMi5yZXNvdXJjZUFjY2Vzc29yLFxuICAgICAgICByZXNvdXJjZUlkQWNjZXNzb3IgPSBfcmVmMi5yZXNvdXJjZUlkQWNjZXNzb3IsXG4gICAgICAgIHJlc291cmNlVGl0bGVBY2Nlc3NvciA9IF9yZWYyLnJlc291cmNlVGl0bGVBY2Nlc3NvcixcbiAgICAgICAgZXZlbnRQcm9wR2V0dGVyID0gX3JlZjIuZXZlbnRQcm9wR2V0dGVyLFxuICAgICAgICBzbG90UHJvcEdldHRlciA9IF9yZWYyLnNsb3RQcm9wR2V0dGVyLFxuICAgICAgICBkYXlQcm9wR2V0dGVyID0gX3JlZjIuZGF5UHJvcEdldHRlcixcbiAgICAgICAgdmlldyA9IF9yZWYyLnZpZXcsXG4gICAgICAgIHZpZXdzJCQxID0gX3JlZjIudmlld3MsXG4gICAgICAgIGxvY2FsaXplciA9IF9yZWYyLmxvY2FsaXplcixcbiAgICAgICAgY3VsdHVyZSA9IF9yZWYyLmN1bHR1cmUsXG4gICAgICAgIF9yZWYyJG1lc3NhZ2VzID0gX3JlZjIubWVzc2FnZXMsXG4gICAgICAgIG1lc3NhZ2VzJCQxID0gX3JlZjIkbWVzc2FnZXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkbWVzc2FnZXMsXG4gICAgICAgIF9yZWYyJGNvbXBvbmVudHMgPSBfcmVmMi5jb21wb25lbnRzLFxuICAgICAgICBjb21wb25lbnRzID0gX3JlZjIkY29tcG9uZW50cyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMiRjb21wb25lbnRzLFxuICAgICAgICBfcmVmMiRmb3JtYXRzID0gX3JlZjIuZm9ybWF0cyxcbiAgICAgICAgZm9ybWF0cyA9IF9yZWYyJGZvcm1hdHMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkZm9ybWF0cztcbiAgICB2YXIgbmFtZXMgPSB2aWV3TmFtZXMkMSh2aWV3cyQkMSk7XG4gICAgdmFyIG1zZ3MgPSBtZXNzYWdlcyhtZXNzYWdlcyQkMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdOYW1lczogbmFtZXMsXG4gICAgICBsb2NhbGl6ZXI6IG1lcmdlV2l0aERlZmF1bHRzKGxvY2FsaXplciwgY3VsdHVyZSwgZm9ybWF0cywgbXNncyksXG4gICAgICBnZXR0ZXJzOiB7XG4gICAgICAgIGV2ZW50UHJvcDogZnVuY3Rpb24gZXZlbnRQcm9wKCkge1xuICAgICAgICAgIHJldHVybiBldmVudFByb3BHZXR0ZXIgJiYgZXZlbnRQcm9wR2V0dGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSB8fCB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2xvdFByb3A6IGZ1bmN0aW9uIHNsb3RQcm9wKCkge1xuICAgICAgICAgIHJldHVybiBzbG90UHJvcEdldHRlciAmJiBzbG90UHJvcEdldHRlci5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykgfHwge307XG4gICAgICAgIH0sXG4gICAgICAgIGRheVByb3A6IGZ1bmN0aW9uIGRheVByb3AoKSB7XG4gICAgICAgICAgcmV0dXJuIGRheVByb3BHZXR0ZXIgJiYgZGF5UHJvcEdldHRlci5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykgfHwge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21wb25lbnRzOiBkZWZhdWx0cyhjb21wb25lbnRzW3ZpZXddIHx8IHt9LCBvbWl0KGNvbXBvbmVudHMsIG5hbWVzKSwge1xuICAgICAgICBldmVudFdyYXBwZXI6IE5vb3BXcmFwcGVyLFxuICAgICAgICBldmVudENvbnRhaW5lcldyYXBwZXI6IE5vb3BXcmFwcGVyLFxuICAgICAgICBkYXlXcmFwcGVyOiBOb29wV3JhcHBlcixcbiAgICAgICAgZGF0ZUNlbGxXcmFwcGVyOiBOb29wV3JhcHBlcixcbiAgICAgICAgd2Vla1dyYXBwZXI6IE5vb3BXcmFwcGVyLFxuICAgICAgICB0aW1lU2xvdFdyYXBwZXI6IE5vb3BXcmFwcGVyXG4gICAgICB9KSxcbiAgICAgIGFjY2Vzc29yczoge1xuICAgICAgICBzdGFydDogd3JhcEFjY2Vzc29yKHN0YXJ0QWNjZXNzb3IpLFxuICAgICAgICBlbmQ6IHdyYXBBY2Nlc3NvcihlbmRBY2Nlc3NvciksXG4gICAgICAgIGFsbERheTogd3JhcEFjY2Vzc29yKGFsbERheUFjY2Vzc29yKSxcbiAgICAgICAgdG9vbHRpcDogd3JhcEFjY2Vzc29yKHRvb2x0aXBBY2Nlc3NvciksXG4gICAgICAgIHRpdGxlOiB3cmFwQWNjZXNzb3IodGl0bGVBY2Nlc3NvciksXG4gICAgICAgIHJlc291cmNlOiB3cmFwQWNjZXNzb3IocmVzb3VyY2VBY2Nlc3NvciksXG4gICAgICAgIHJlc291cmNlSWQ6IHdyYXBBY2Nlc3NvcihyZXNvdXJjZUlkQWNjZXNzb3IpLFxuICAgICAgICByZXNvdXJjZVRpdGxlOiB3cmFwQWNjZXNzb3IocmVzb3VyY2VUaXRsZUFjY2Vzc29yKVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdmlldyA9IF90aGlzJHByb3BzNC52aWV3LFxuICAgICAgICB0b29sYmFyID0gX3RoaXMkcHJvcHM0LnRvb2xiYXIsXG4gICAgICAgIGV2ZW50cyQkMSA9IF90aGlzJHByb3BzNC5ldmVudHMsXG4gICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHM0LnN0eWxlLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczQuY2xhc3NOYW1lLFxuICAgICAgICBlbGVtZW50UHJvcHMgPSBfdGhpcyRwcm9wczQuZWxlbWVudFByb3BzLFxuICAgICAgICBjdXJyZW50ID0gX3RoaXMkcHJvcHM0LmRhdGUsXG4gICAgICAgIGdldE5vdyA9IF90aGlzJHByb3BzNC5nZXROb3csXG4gICAgICAgIGxlbmd0aCA9IF90aGlzJHByb3BzNC5sZW5ndGgsXG4gICAgICAgIHNob3dNdWx0aURheVRpbWVzID0gX3RoaXMkcHJvcHM0LnNob3dNdWx0aURheVRpbWVzLFxuICAgICAgICBvblNob3dNb3JlID0gX3RoaXMkcHJvcHM0Lm9uU2hvd01vcmUsXG4gICAgICAgIF8wID0gX3RoaXMkcHJvcHM0LmNvbXBvbmVudHMsXG4gICAgICAgIF8xID0gX3RoaXMkcHJvcHM0LmZvcm1hdHMsXG4gICAgICAgIF8yID0gX3RoaXMkcHJvcHM0Lm1lc3NhZ2VzLFxuICAgICAgICBfMyA9IF90aGlzJHByb3BzNC5jdWx0dXJlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzNCwgW1widmlld1wiLCBcInRvb2xiYXJcIiwgXCJldmVudHNcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcImVsZW1lbnRQcm9wc1wiLCBcImRhdGVcIiwgXCJnZXROb3dcIiwgXCJsZW5ndGhcIiwgXCJzaG93TXVsdGlEYXlUaW1lc1wiLCBcIm9uU2hvd01vcmVcIiwgXCJjb21wb25lbnRzXCIsIFwiZm9ybWF0c1wiLCBcIm1lc3NhZ2VzXCIsIFwiY3VsdHVyZVwiXSk7XG5cbiAgICBjdXJyZW50ID0gY3VycmVudCB8fCBnZXROb3coKTtcbiAgICB2YXIgVmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIHZhciBfdGhpcyRzdGF0ZSRjb250ZXh0ID0gdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICBhY2Nlc3NvcnMgPSBfdGhpcyRzdGF0ZSRjb250ZXh0LmFjY2Vzc29ycyxcbiAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHN0YXRlJGNvbnRleHQuY29tcG9uZW50cyxcbiAgICAgICAgZ2V0dGVycyA9IF90aGlzJHN0YXRlJGNvbnRleHQuZ2V0dGVycyxcbiAgICAgICAgbG9jYWxpemVyID0gX3RoaXMkc3RhdGUkY29udGV4dC5sb2NhbGl6ZXIsXG4gICAgICAgIHZpZXdOYW1lcyA9IF90aGlzJHN0YXRlJGNvbnRleHQudmlld05hbWVzO1xuICAgIHZhciBDYWxUb29sYmFyID0gY29tcG9uZW50cy50b29sYmFyIHx8IFRvb2xiYXI7XG4gICAgdmFyIGxhYmVsID0gVmlldy50aXRsZShjdXJyZW50LCB7XG4gICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplcixcbiAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIGVsZW1lbnRQcm9wcywge1xuICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWUsICdyYmMtY2FsZW5kYXInLCBwcm9wcy5ydGwgJiYgJ3JiYy1pcy1ydGwnKSxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH0pLCB0b29sYmFyICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsVG9vbGJhciwge1xuICAgICAgZGF0ZTogY3VycmVudCxcbiAgICAgIHZpZXc6IHZpZXcsXG4gICAgICB2aWV3czogdmlld05hbWVzLFxuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgb25WaWV3OiB0aGlzLmhhbmRsZVZpZXdDaGFuZ2UsXG4gICAgICBvbk5hdmlnYXRlOiB0aGlzLmhhbmRsZU5hdmlnYXRlLFxuICAgICAgbG9jYWxpemVyOiBsb2NhbGl6ZXJcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChWaWV3LCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IFwidmlld1wiXG4gICAgfSwgcHJvcHMsIHtcbiAgICAgIGV2ZW50czogZXZlbnRzJCQxLFxuICAgICAgZGF0ZTogY3VycmVudCxcbiAgICAgIGdldE5vdzogZ2V0Tm93LFxuICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICBsb2NhbGl6ZXI6IGxvY2FsaXplcixcbiAgICAgIGdldHRlcnM6IGdldHRlcnMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICBzaG93TXVsdGlEYXlUaW1lczogc2hvd011bHRpRGF5VGltZXMsXG4gICAgICBnZXREcmlsbGRvd25WaWV3OiB0aGlzLmdldERyaWxsZG93blZpZXcsXG4gICAgICBvbk5hdmlnYXRlOiB0aGlzLmhhbmRsZU5hdmlnYXRlLFxuICAgICAgb25EcmlsbERvd246IHRoaXMuaGFuZGxlRHJpbGxEb3duLFxuICAgICAgb25TZWxlY3RFdmVudDogdGhpcy5oYW5kbGVTZWxlY3RFdmVudCxcbiAgICAgIG9uRG91YmxlQ2xpY2tFdmVudDogdGhpcy5oYW5kbGVEb3VibGVDbGlja0V2ZW50LFxuICAgICAgb25TZWxlY3RTbG90OiB0aGlzLmhhbmRsZVNlbGVjdFNsb3QsXG4gICAgICBvblNob3dNb3JlOiBvblNob3dNb3JlXG4gICAgfSkpKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqIEBwYXJhbSB2aWV3Q29tcG9uZW50XG4gICAqIEBwYXJhbSB7J21vbnRoJ3wnd2Vlayd8J3dvcmtfd2Vlayd8J2RheSd8J2FnZW5kYSd9IFt2aWV3XSAtIG9wdGlvbmFsXG4gICAqIHBhcmFtZXRlci4gSXQgYXBwZWFycyB3aGVuIHJhbmdlIGNoYW5nZSBvbiB2aWV3IGNoYW5naW5nLiBJdCBjb3VsZCBiZSBoYW5keVxuICAgKiB3aGVuIHlvdSBuZWVkIHRvIGhhdmUgYm90aDogcmFuZ2UgYW5kIHZpZXcgdHlwZSBhdCBvbmNlLCBpLmUuIGZvciBtYW5hZ2UgcmJjXG4gICAqIHN0YXRlIHZpYSB1cmxcbiAgICovXG5cblxuICByZXR1cm4gQ2FsZW5kYXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkNhbGVuZGFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZWxlbWVudFByb3BzOiB7fSxcbiAgcG9wdXA6IGZhbHNlLFxuICB0b29sYmFyOiB0cnVlLFxuICB2aWV3OiB2aWV3cy5NT05USCxcbiAgdmlld3M6IFt2aWV3cy5NT05USCwgdmlld3MuV0VFSywgdmlld3MuREFZLCB2aWV3cy5BR0VOREFdLFxuICBzdGVwOiAzMCxcbiAgbGVuZ3RoOiAzMCxcbiAgZHJpbGxkb3duVmlldzogdmlld3MuREFZLFxuICB0aXRsZUFjY2Vzc29yOiAndGl0bGUnLFxuICB0b29sdGlwQWNjZXNzb3I6ICd0aXRsZScsXG4gIGFsbERheUFjY2Vzc29yOiAnYWxsRGF5JyxcbiAgc3RhcnRBY2Nlc3NvcjogJ3N0YXJ0JyxcbiAgZW5kQWNjZXNzb3I6ICdlbmQnLFxuICByZXNvdXJjZUFjY2Vzc29yOiAncmVzb3VyY2VJZCcsXG4gIHJlc291cmNlSWRBY2Nlc3NvcjogJ2lkJyxcbiAgcmVzb3VyY2VUaXRsZUFjY2Vzc29yOiAndGl0bGUnLFxuICBsb25nUHJlc3NUaHJlc2hvbGQ6IDI1MCxcbiAgZ2V0Tm93OiBmdW5jdGlvbiBnZXROb3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbn07XG5DYWxlbmRhci5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGxvY2FsaXplcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBwYXNzZWQgdG8gbWFpbiBjYWxlbmRhciBgPGRpdj5gLlxuICAgKlxuICAgKi9cbiAgZWxlbWVudFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBkYXRlIHZhbHVlIG9mIHRoZSBjYWxlbmRhci4gRGV0ZXJtaW5lcyB0aGUgdmlzaWJsZSB2aWV3IHJhbmdlLlxuICAgKiBJZiBgZGF0ZWAgaXMgb21pdHRlZCB0aGVuIHRoZSByZXN1bHQgb2YgYGdldE5vd2AgaXMgdXNlZDsgb3RoZXJ3aXNlIHRoZVxuICAgKiBjdXJyZW50IGRhdGUgaXMgdXNlZC5cbiAgICpcbiAgICogQGNvbnRyb2xsYWJsZSBvbk5hdmlnYXRlXG4gICAqL1xuICBkYXRlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmlldyBvZiB0aGUgY2FsZW5kYXIuXG4gICAqXG4gICAqIEBkZWZhdWx0ICdtb250aCdcbiAgICogQGNvbnRyb2xsYWJsZSBvblZpZXdcbiAgICovXG4gIHZpZXc6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHZpZXcgc2V0IGZvciB0aGUgQ2FsZW5kYXIuXG4gICAqIEB0eXBlIENhbGVuZGFyLlZpZXdzICgnbW9udGgnfCd3ZWVrJ3wnd29ya193ZWVrJ3wnZGF5J3wnYWdlbmRhJylcbiAgICogQGRlZmF1bHQgJ21vbnRoJ1xuICAgKi9cbiAgZGVmYXVsdFZpZXc6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgdG8gZGlzcGxheSBvbiB0aGUgY2FsZW5kYXIuIEV2ZW50cyBvYmplY3RzXG4gICAqIGNhbiBiZSBhbnkgc2hhcGUsIGFzIGxvbmcgYXMgdGhlIENhbGVuZGFyIGtub3dzIGhvdyB0byByZXRyaWV2ZSB0aGVcbiAgICogZm9sbG93aW5nIGRldGFpbHMgb2YgdGhlIGV2ZW50OlxuICAgKlxuICAgKiAgLSBzdGFydCB0aW1lXG4gICAqICAtIGVuZCB0aW1lXG4gICAqICAtIHRpdGxlXG4gICAqICAtIHdoZXRoZXIgaXRzIGFuIFwiYWxsIGRheVwiIGV2ZW50IG9yIG5vdFxuICAgKiAgLSBhbnkgcmVzb3VyY2UgdGhlIGV2ZW50IG1heSBiZSByZWxhdGVkIHRvXG4gICAqXG4gICAqIEVhY2ggb2YgdGhlc2UgcHJvcGVydGllcyBjYW4gYmUgY3VzdG9taXplZCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgYnlcbiAgICogc2V0dGluZyB0aGUgdmFyaW91cyBcImFjY2Vzc29yXCIgcHJvcHMuIFdpdGhvdXQgYW55IGNvbmZpZ3VyYXRpb24gdGhlIGRlZmF1bHRcbiAgICogZXZlbnQgc2hvdWxkIGxvb2sgbGlrZTpcbiAgICpcbiAgICogYGBganNcbiAgICogRXZlbnQge1xuICAgKiAgIHRpdGxlOiBzdHJpbmcsXG4gICAqICAgc3RhcnQ6IERhdGUsXG4gICAqICAgZW5kOiBEYXRlLFxuICAgKiAgIGFsbERheT86IGJvb2xlYW5cbiAgICogICByZXNvdXJjZT86IGFueSxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGV2ZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cbiAgLyoqXG4gICAqIEFjY2Vzc29yIGZvciB0aGUgZXZlbnQgdGl0bGUsIHVzZWQgdG8gZGlzcGxheSBldmVudCBpbmZvcm1hdGlvbi4gU2hvdWxkXG4gICAqIHJlc29sdmUgdG8gYSBgcmVuZGVyYWJsZWAgdmFsdWUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHN0cmluZyB8IChldmVudDogT2JqZWN0KSA9PiBzdHJpbmdcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHsoZnVuY3xzdHJpbmcpfVxuICAgKi9cbiAgdGl0bGVBY2Nlc3NvcjogYWNjZXNzb3IsXG5cbiAgLyoqXG4gICAqIEFjY2Vzc29yIGZvciB0aGUgZXZlbnQgdG9vbHRpcC4gU2hvdWxkXG4gICAqIHJlc29sdmUgdG8gYSBgcmVuZGVyYWJsZWAgdmFsdWUuIFJlbW92ZXMgdGhlIHRvb2x0aXAgaWYgbnVsbC5cbiAgICpcbiAgICogYGBganNcbiAgICogc3RyaW5nIHwgKGV2ZW50OiBPYmplY3QpID0+IHN0cmluZ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUgeyhmdW5jfHN0cmluZyl9XG4gICAqL1xuICB0b29sdGlwQWNjZXNzb3I6IGFjY2Vzc29yLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIFwiYWxsIGRheVwiIGV2ZW50IGFuZCBpZ25vcmUgdGltZS5cbiAgICogTXVzdCByZXNvbHZlIHRvIGEgYGJvb2xlYW5gIHZhbHVlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBzdHJpbmcgfCAoZXZlbnQ6IE9iamVjdCkgPT4gYm9vbGVhblxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUgeyhmdW5jfHN0cmluZyl9XG4gICAqL1xuICBhbGxEYXlBY2Nlc3NvcjogYWNjZXNzb3IsXG5cbiAgLyoqXG4gICAqIFRoZSBzdGFydCBkYXRlL3RpbWUgb2YgdGhlIGV2ZW50LiBNdXN0IHJlc29sdmUgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHN0cmluZyB8IChldmVudDogT2JqZWN0KSA9PiBEYXRlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7KGZ1bmN8c3RyaW5nKX1cbiAgICovXG4gIHN0YXJ0QWNjZXNzb3I6IGFjY2Vzc29yLFxuXG4gIC8qKlxuICAgKiBUaGUgZW5kIGRhdGUvdGltZSBvZiB0aGUgZXZlbnQuIE11c3QgcmVzb2x2ZSB0byBhIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdC5cbiAgICpcbiAgICogYGBganNcbiAgICogc3RyaW5nIHwgKGV2ZW50OiBPYmplY3QpID0+IERhdGVcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHsoZnVuY3xzdHJpbmcpfVxuICAgKi9cbiAgZW5kQWNjZXNzb3I6IGFjY2Vzc29yLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgYHJlc291cmNlYCB0aGF0IHRoZSBldmVudCBpcyBhIG1lbWJlciBvZi4gVGhpc1xuICAgKiBpZCBzaG91bGQgbWF0Y2ggYXQgbGVhc3Qgb25lIHJlc291cmNlIGluIHRoZSBgcmVzb3VyY2VzYCBhcnJheS5cbiAgICpcbiAgICogYGBganNcbiAgICogc3RyaW5nIHwgKGV2ZW50OiBPYmplY3QpID0+IERhdGVcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHsoZnVuY3xzdHJpbmcpfVxuICAgKi9cbiAgcmVzb3VyY2VBY2Nlc3NvcjogYWNjZXNzb3IsXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHJlc291cmNlIG9iamVjdHMgdGhhdCBtYXAgZXZlbnRzIHRvIGEgc3BlY2lmaWMgcmVzb3VyY2UuXG4gICAqIFJlc291cmNlIG9iamVjdHMsIGxpa2UgZXZlbnRzLCBjYW4gYmUgYW55IHNoYXBlIG9yIGhhdmUgYW55IHByb3BlcnRpZXMsXG4gICAqIGJ1dCBzaG91bGQgYmUgdW5pcXVseSBpZGVudGlmaWFibGUgdmlhIHRoZSBgcmVzb3VyY2VJZEFjY2Vzc29yYCwgYXNcbiAgICogd2VsbCBhcyBhIFwidGl0bGVcIiBvciBuYW1lIGFzIHByb3ZpZGVkIGJ5IHRoZSBgcmVzb3VyY2VUaXRsZUFjY2Vzc29yYCBwcm9wLlxuICAgKi9cbiAgcmVzb3VyY2VzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub2JqZWN0KSxcblxuICAvKipcbiAgICogUHJvdmlkZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCByZXNvdXJjZSBpbiB0aGUgYHJlc291cmNlc2AgYXJyYXlcbiAgICpcbiAgICogYGBganNcbiAgICogc3RyaW5nIHwgKHJlc291cmNlOiBPYmplY3QpID0+IGFueVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUgeyhmdW5jfHN0cmluZyl9XG4gICAqL1xuICByZXNvdXJjZUlkQWNjZXNzb3I6IGFjY2Vzc29yLFxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSByZXNvdXJjZSBvYmplY3QsIHVzZWQgaW4gaGVhZGVycy5cbiAgICpcbiAgICogYGBganNcbiAgICogc3RyaW5nIHwgKHJlc291cmNlOiBPYmplY3QpID0+IGFueVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUgeyhmdW5jfHN0cmluZyl9XG4gICAqL1xuICByZXNvdXJjZVRpdGxlQWNjZXNzb3I6IGFjY2Vzc29yLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBjdXJyZW50IGRhdGUvdGltZSB3aGljaCBpcyBoaWdobGlnaHRlZCBpbiB0aGUgdmlld3MuXG4gICAqXG4gICAqIFRoZSB2YWx1ZSBhZmZlY3RzIHdoaWNoIGRheSBpcyBzaGFkZWQgYW5kIHdoaWNoIHRpbWUgaXMgc2hvd24gYXNcbiAgICogdGhlIGN1cnJlbnQgdGltZS4gSXQgYWxzbyBhZmZlY3RzIHRoZSBkYXRlIHVzZWQgYnkgdGhlIFRvZGF5IGJ1dHRvbiBpblxuICAgKiB0aGUgdG9vbGJhci5cbiAgICpcbiAgICogUHJvdmlkaW5nIGEgdmFsdWUgaGVyZSBjYW4gYmUgdXNlZnVsIHdoZW4geW91IGFyZSBpbXBsZW1lbnRpbmcgdGltZSB6b25lc1xuICAgKiB1c2luZyB0aGUgYHN0YXJ0QWNjZXNzb3JgIGFuZCBgZW5kQWNjZXNzb3JgIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEB0eXBlIHtmdW5jfVxuICAgKiBAZGVmYXVsdCAoKSA9PiBuZXcgRGF0ZSgpXG4gICAqL1xuICBnZXROb3c6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBgZGF0ZWAgdmFsdWUgY2hhbmdlcy5cbiAgICpcbiAgICogQGNvbnRyb2xsYWJsZSBkYXRlXG4gICAqL1xuICBvbk5hdmlnYXRlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgYHZpZXdgIHZhbHVlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBjb250cm9sbGFibGUgdmlld1xuICAgKi9cbiAgb25WaWV3OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiBkYXRlIGhlYWRlciwgb3IgdGhlIHRydW5jYXRlZCBldmVudHMgbGlua3MgYXJlIGNsaWNrZWRcbiAgICpcbiAgICovXG4gIG9uRHJpbGxEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICpcbiAgICogYGBganNcbiAgICogKGRhdGVzOiBEYXRlW10gfCB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfSwgdmlldz86ICdtb250aCd8J3dlZWsnfCd3b3JrX3dlZWsnfCdkYXknfCdhZ2VuZGEnKSA9PiB2b2lkXG4gICAqIGBgYFxuICAgKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2aXNpYmxlIGRhdGUgcmFuZ2UgY2hhbmdlcy4gUmV0dXJucyBhbiBBcnJheSBvZiBkYXRlc1xuICAgKiBvciBhbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIGRhdGVzIGZvciBCVUlMVElOIHZpZXdzLiBPcHRpb25hbGx5IG5ldyBgdmlld2BcbiAgICogd2lsbCBiZSByZXR1cm5lZCB3aGVuIGNhbGxiYWNrIGNhbGxlZCBhZnRlciB2aWV3IGNoYW5nZS5cbiAgICpcbiAgICogQ3VzdG9tIHZpZXdzIG1heSByZXR1cm4gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICovXG4gIG9uUmFuZ2VDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIGZpcmVkIHdoZW4gYSBkYXRlIHNlbGVjdGlvbiBpcyBtYWRlLiBPbmx5IGZpcmVzIHdoZW4gYHNlbGVjdGFibGVgIGlzIGB0cnVlYC5cbiAgICpcbiAgICogYGBganNcbiAgICogKFxuICAgKiAgIHNsb3RJbmZvOiB7XG4gICAqICAgICBzdGFydDogRGF0ZSxcbiAgICogICAgIGVuZDogRGF0ZSxcbiAgICogICAgIHNsb3RzOiBBcnJheTxEYXRlPixcbiAgICogICAgIGFjdGlvbjogXCJzZWxlY3RcIiB8IFwiY2xpY2tcIiB8IFwiZG91YmxlQ2xpY2tcIixcbiAgICogICAgIGJvdW5kczogP3sgLy8gRm9yIFwic2VsZWN0XCIgYWN0aW9uXG4gICAqICAgICAgIHg6IG51bWJlcixcbiAgICogICAgICAgeTogbnVtYmVyLFxuICAgKiAgICAgICB0b3A6IG51bWJlcixcbiAgICogICAgICAgcmlnaHQ6IG51bWJlcixcbiAgICogICAgICAgbGVmdDogbnVtYmVyLFxuICAgKiAgICAgICBib3R0b206IG51bWJlcixcbiAgICogICAgIH0sXG4gICAqICAgICBib3g6ID97IC8vIEZvciBcImNsaWNrXCIgb3IgXCJkb3VibGVDbGlja1wiIGFjdGlvbnNcbiAgICogICAgICAgY2xpZW50WDogbnVtYmVyLFxuICAgKiAgICAgICBjbGllbnRZOiBudW1iZXIsXG4gICAqICAgICAgIHg6IG51bWJlcixcbiAgICogICAgICAgeTogbnVtYmVyLFxuICAgKiAgICAgfSxcbiAgICogICB9XG4gICAqICkgPT4gYW55XG4gICAqIGBgYFxuICAgKi9cbiAgb25TZWxlY3RTbG90OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiBhIGNhbGVuZGFyIGV2ZW50IGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAoZXZlbnQ6IE9iamVjdCwgZTogU3ludGhldGljRXZlbnQpID0+IGFueVxuICAgKiBgYGBcbiAgICpcbiAgICogQGNvbnRyb2xsYWJsZSBzZWxlY3RlZFxuICAgKi9cbiAgb25TZWxlY3RFdmVudDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gYSBjYWxlbmRhciBldmVudCBpcyBjbGlja2VkIHR3aWNlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAoZXZlbnQ6IE9iamVjdCwgZTogU3ludGhldGljRXZlbnQpID0+IHZvaWRcbiAgICogYGBgXG4gICAqL1xuICBvbkRvdWJsZUNsaWNrRXZlbnQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIGRyYWdnaW5nIGEgc2VsZWN0aW9uIGluIHRoZSBUaW1lIHZpZXdzLlxuICAgKlxuICAgKiBSZXR1cm5pbmcgYGZhbHNlYCBmcm9tIHRoZSBoYW5kbGVyIHdpbGwgcHJldmVudCBhIHNlbGVjdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogKHJhbmdlOiB7IHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUgfSkgPT4gP2Jvb2xlYW5cbiAgICogYGBgXG4gICAqL1xuICBvblNlbGVjdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gYSAre2NvdW50fSBtb3JlIGlzIGNsaWNrZWRcbiAgICpcbiAgICogYGBganNcbiAgICogKGV2ZW50czogT2JqZWN0LCBkYXRlOiBEYXRlKSA9PiBhbnlcbiAgICogYGBgXG4gICAqL1xuICBvblNob3dNb3JlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNlbGVjdGVkIGV2ZW50LCBpZiBhbnkuXG4gICAqL1xuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgYnVpbHQtaW4gdmlldyBuYW1lcyB0byBhbGxvdyB0aGUgY2FsZW5kYXIgdG8gZGlzcGxheS5cbiAgICogYWNjZXB0cyBlaXRoZXIgYW4gYXJyYXkgb2YgYnVpbHRpbiB2aWV3IG5hbWVzLFxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdmlld3M9e1snbW9udGgnLCAnZGF5JywgJ2FnZW5kYSddfVxuICAgKiBgYGBcbiAgICogb3IgYW4gb2JqZWN0IGhhc2ggb2YgdGhlIHZpZXcgbmFtZSBhbmQgdGhlIGNvbXBvbmVudCAob3IgYm9vbGVhbiBmb3IgYnVpbHRpbikuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB2aWV3cz17e1xuICAgKiAgIG1vbnRoOiB0cnVlLFxuICAgKiAgIHdlZWs6IGZhbHNlLFxuICAgKiAgIG15d2VlazogV29ya1dlZWtWaWV3Q29tcG9uZW50LFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQ3VzdG9tIHZpZXdzIGNhbiBiZSBhbnkgUmVhY3QgY29tcG9uZW50LCB0aGF0IGltcGxlbWVudHMgdGhlIGZvbGxvd2luZ1xuICAgKiBpbnRlcmZhY2U6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGludGVyZmFjZSBWaWV3IHtcbiAgICogICBzdGF0aWMgdGl0bGUoZGF0ZTogRGF0ZSwgeyBmb3JtYXRzOiBEYXRlRm9ybWF0W10sIGN1bHR1cmU6IHN0cmluZz8sIC4uLnByb3BzIH0pOiBzdHJpbmdcbiAgICogICBzdGF0aWMgbmF2aWdhdGUoZGF0ZTogRGF0ZSwgYWN0aW9uOiAnUFJFVicgfCAnTkVYVCcgfCAnREFURScpOiBEYXRlXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIENhbGVuZGFyLlZpZXdzICgnbW9udGgnfCd3ZWVrJ3wnd29ya193ZWVrJ3wnZGF5J3wnYWdlbmRhJylcbiAgICogQFZpZXdcbiAgIFsnbW9udGgnLCAnd2VlaycsICdkYXknLCAnYWdlbmRhJ11cbiAgICovXG4gIHZpZXdzOiB2aWV3cyQxLFxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uIHZpZXcgZm9yIGRyaWxsLWRvd24gYWN0aW9ucywgc3VjaFxuICAgKiBhcyBjbGlja2luZyBhIGRhdGUgaGVhZGVyLCBvciB0aGUgdHJ1bmNhdGVkIGV2ZW50cyBsaW5rcy4gSWZcbiAgICogYGdldERyaWxsZG93blZpZXdgIGlzIGFsc28gc3BlY2lmaWVkIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUgZHJpbGwtZG93biBhY3Rpb25zLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiA8QmlnQ2FsZW5kYXJcbiAgICogICBkcmlsbGRvd25WaWV3PVwiYWdlbmRhXCJcbiAgICogLz5cbiAgICogYGBgXG4gICAqL1xuICBkcmlsbGRvd25WaWV3OiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBgZHJpbGxkb3duVmlld2AsIGJ1dCBhY2NlcHRzIGEgZnVuY3Rpb25cbiAgICogdGhhdCBjYW4gcmV0dXJuIGEgdmlldyBuYW1lLiBJdCdzIHVzZWZ1bCBmb3IgY3VzdG9taXppbmcgdGhlIGRyaWxsLWRvd25cbiAgICogYWN0aW9ucyBkZXBlbmRpbmcgb24gdGhlIHRhcmdldCBkYXRlIGFuZCB0cmlnZ2VyaW5nIHZpZXcuXG4gICAqXG4gICAqIFJldHVybiBgbnVsbGAgdG8gZGlzYWJsZSBkcmlsbC1kb3duIGFjdGlvbnMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIDxCaWdDYWxlbmRhclxuICAgKiAgIGdldERyaWxsZG93blZpZXc9eyh0YXJnZXREYXRlLCBjdXJyZW50Vmlld05hbWUsIGNvbmZpZ3VyZWRWaWV3TmFtZXMpID0+XG4gICAqICAgICBpZiAoY3VycmVudFZpZXdOYW1lID09PSAnbW9udGgnICYmIGNvbmZpZ3VyZWRWaWV3TmFtZXMuaW5jbHVkZXMoJ3dlZWsnKSlcbiAgICogICAgICAgcmV0dXJuICd3ZWVrJ1xuICAgKlxuICAgKiAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgfX1cbiAgICogLz5cbiAgICogYGBgXG4gICAqL1xuICBnZXREcmlsbGRvd25WaWV3OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgZW5kIGRhdGUgZnJvbSBkYXRlIHByb3AgaW4gdGhlIGFnZW5kYSB2aWV3XG4gICAqIGRhdGUgcHJvcCArIGxlbmd0aCAoaW4gbnVtYmVyIG9mIGRheXMpID0gZW5kIGRhdGVcbiAgICovXG4gIGxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0b29sYmFyIGlzIGRpc3BsYXllZFxuICAgKi9cbiAgdG9vbGJhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFNob3cgdHJ1bmNhdGVkIGV2ZW50cyBpbiBhbiBvdmVybGF5IHdoZW4geW91IGNsaWNrIHRoZSBcIitfeF8gbW9yZVwiIGxpbmsuXG4gICAqL1xuICBwb3B1cDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlIGluIHBpeGVscywgZnJvbSB0aGUgZWRnZXMgb2YgdGhlIHZpZXdwb3J0LCB0aGUgXCJzaG93IG1vcmVcIiBvdmVybGF5IHNob3VsZCBiZSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPEJpZ0NhbGVuZGFyIHBvcHVwT2Zmc2V0PXszMH0vPlxuICAgKiA8QmlnQ2FsZW5kYXIgcG9wdXBPZmZzZXQ9e3t4OiAzMCwgeTogMjB9fS8+XG4gICAqIGBgYFxuICAgKi9cbiAgcG9wdXBPZmZzZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB5OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG5cbiAgLyoqXG4gICAqIEFsbG93cyBtb3VzZSBzZWxlY3Rpb24gb2YgcmFuZ2VzIG9mIGRhdGVzL3RpbWVzLlxuICAgKlxuICAgKiBUaGUgJ2lnbm9yZUV2ZW50cycgb3B0aW9uIHByZXZlbnRzIHNlbGVjdGlvbiBjb2RlIGZyb20gcnVubmluZyB3aGVuIGFcbiAgICogZHJhZyBiZWdpbnMgb3ZlciBhbiBldmVudC4gVXNlZnVsIHdoZW4geW91IHdhbnQgY3VzdG9tIGV2ZW50IGNsaWNrIG9yIGRyYWdcbiAgICogbG9naWNcbiAgICovXG4gIHNlbGVjdGFibGU6IFByb3BUeXBlcy5vbmVPZihbdHJ1ZSwgZmFsc2UsICdpZ25vcmVFdmVudHMnXSksXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIG1pbGlzZWNvbmRzIHRoZSB1c2VyIG11c3QgcHJlc3MgYW5kIGhvbGQgb24gdGhlIHNjcmVlbiBmb3IgYSB0b3VjaFxuICAgKiB0byBiZSBjb25zaWRlcmVkIGEgXCJsb25nIHByZXNzLlwiIExvbmcgcHJlc3NlcyBhcmUgdXNlZCBmb3IgdGltZSBzbG90IHNlbGVjdGlvbiBvbiB0b3VjaFxuICAgKiBkZXZpY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAyNTBcbiAgICovXG4gIGxvbmdQcmVzc1RocmVzaG9sZDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgc2VsZWN0YWJsZSB0aW1lIGluY3JlbWVudHMgaW4gd2VlayBhbmQgZGF5IHZpZXdzXG4gICAqL1xuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHNsb3RzIHBlciBcInNlY3Rpb25cIiBpbiB0aGUgdGltZSBncmlkIHZpZXdzLiBBZGp1c3Qgd2l0aCBgc3RlcGBcbiAgICogdG8gY2hhbmdlIHRoZSBkZWZhdWx0IG9mIDEgaG91ciBsb25nIGdyb3Vwcywgd2l0aCAzMCBtaW51dGUgc2xvdHMuXG4gICAqL1xuICB0aW1lc2xvdHM6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqU3dpdGNoIHRoZSBjYWxlbmRhciB0byBhIGByaWdodC10by1sZWZ0YCByZWFkIGRpcmVjdGlvbi5cbiAgICovXG4gIHJ0bDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb2YgY2xhc3NOYW1lIG9yIHN0eWxlIHByb3BzXG4gICAqIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRoZSBldmVudCBub2RlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAoXG4gICAqIFx0ZXZlbnQ6IE9iamVjdCxcbiAgICogXHRzdGFydDogRGF0ZSxcbiAgICogXHRlbmQ6IERhdGUsXG4gICAqIFx0aXNTZWxlY3RlZDogYm9vbGVhblxuICAgKiApID0+IHsgY2xhc3NOYW1lPzogc3RyaW5nLCBzdHlsZT86IE9iamVjdCB9XG4gICAqIGBgYFxuICAgKi9cbiAgZXZlbnRQcm9wR2V0dGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCBvZiBjbGFzc05hbWUgb3Igc3R5bGUgcHJvcHNcbiAgICogdG8gYmUgYXBwbGllZCB0byB0aGUgdGhlIHRpbWUtc2xvdCBub2RlLiBDYXV0aW9uISBTdHlsZXMgdGhhdCBjaGFuZ2UgbGF5b3V0IG9yXG4gICAqIHBvc2l0aW9uIG1heSBicmVhayB0aGUgY2FsZW5kYXIgaW4gdW5leHBlY3RlZCB3YXlzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAoZGF0ZTogRGF0ZSwgcmVzb3VyY2VJZDogKG51bWJlcnxzdHJpbmcpKSA9PiB7IGNsYXNzTmFtZT86IHN0cmluZywgc3R5bGU/OiBPYmplY3QgfVxuICAgKiBgYGBcbiAgICovXG4gIHNsb3RQcm9wR2V0dGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCBvZiBjbGFzc05hbWUgb3Igc3R5bGUgcHJvcHNcbiAgICogdG8gYmUgYXBwbGllZCB0byB0aGUgdGhlIGRheSBiYWNrZ3JvdW5kLiBDYXV0aW9uISBTdHlsZXMgdGhhdCBjaGFuZ2UgbGF5b3V0IG9yXG4gICAqIHBvc2l0aW9uIG1heSBicmVhayB0aGUgY2FsZW5kYXIgaW4gdW5leHBlY3RlZCB3YXlzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAoZGF0ZTogRGF0ZSkgPT4geyBjbGFzc05hbWU/OiBzdHJpbmcsIHN0eWxlPzogT2JqZWN0IH1cbiAgICogYGBgXG4gICAqL1xuICBkYXlQcm9wR2V0dGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogU3VwcG9ydCB0byBzaG93IG11bHRpLWRheSBldmVudHMgd2l0aCBzcGVjaWZpYyBzdGFydCBhbmQgZW5kIHRpbWVzIGluIHRoZVxuICAgKiBtYWluIHRpbWUgZ3JpZCAocmF0aGVyIHRoYW4gaW4gdGhlIGFsbCBkYXkgaGVhZGVyKS5cbiAgICpcbiAgICogKipOb3RlOiBUaGlzIG1heSBjYXVzZSBjYWxlbmRhcnMgd2l0aCBzZXZlcmFsIGV2ZW50cyB0byBsb29rIHZlcnkgYnVzeSBpblxuICAgKiB0aGUgd2VlayBhbmQgZGF5IHZpZXdzLioqXG4gICAqL1xuICBzaG93TXVsdGlEYXlUaW1lczogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnMgdGhlIG1pbmltdW0gX3RpbWVfIG9mIHRoZSBEYXkgYW5kIFdlZWsgdmlld3MuXG4gICAqL1xuICBtaW46IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW5zIHRoZSBtYXhpbXVtIF90aW1lXyBvZiB0aGUgRGF5IGFuZCBXZWVrIHZpZXdzLlxuICAgKi9cbiAgbWF4OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBob3cgZmFyIGRvd24gdGhlIHNjcm9sbCBwYW5lIGlzIGluaXRpYWxseSBzY3JvbGxlZCBkb3duLlxuICAgKi9cbiAgc2Nyb2xsVG9UaW1lOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcblxuICAvKipcbiAgICogU3BlY2lmeSBhIHNwZWNpZmljIGN1bHR1cmUgY29kZSBmb3IgdGhlIENhbGVuZGFyLlxuICAgKlxuICAgKiAqKk5vdGU6IGl0J3MgZ2VuZXJhbGx5IGJldHRlciB0byBoYW5kbGUgdGhpcyBnbG9iYWxseSB2aWEgeW91ciBpMThuIGxpYnJhcnkuKipcbiAgICovXG4gIGN1bHR1cmU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIExvY2FsaXplciBzcGVjaWZpYyBmb3JtYXRzLCB0ZWxsIHRoZSBDYWxlbmRhciBob3cgdG8gZm9ybWF0IGFuZCBkaXNwbGF5IGRhdGVzLlxuICAgKlxuICAgKiBgZm9ybWF0YCB0eXBlcyBhcmUgZGVwZW5kZW50IG9uIHRoZSBjb25maWd1cmVkIGxvY2FsaXplcjsgYm90aCBNb21lbnQgYW5kIEdsb2JhbGl6ZVxuICAgKiBhY2NlcHQgc3RyaW5ncyBvZiB0b2tlbnMgYWNjb3JkaW5nIHRvIHRoZWlyIG93biBzcGVjaWZpY2F0aW9uLCBzdWNoIGFzOiBgJ0REIG1tIHl5eXknYC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGxldCBmb3JtYXRzID0ge1xuICAgKiAgIGRhdGVGb3JtYXQ6ICdkZCcsXG4gICAqXG4gICAqICAgZGF5Rm9ybWF0OiAoZGF0ZSwgLCBsb2NhbGl6ZXIpID0+XG4gICAqICAgICBsb2NhbGl6ZXIuZm9ybWF0KGRhdGUsICdEREQnLCBjdWx0dXJlKSxcbiAgICpcbiAgICogICBkYXlSYW5nZUhlYWRlckZvcm1hdDogKHsgc3RhcnQsIGVuZCB9LCBjdWx0dXJlLCBsb2NhbGl6ZXIpID0+XG4gICAqICAgICBsb2NhbGl6ZXIuZm9ybWF0KHN0YXJ0LCB7IGRhdGU6ICdzaG9ydCcgfSwgY3VsdHVyZSkgKyAnIOKAlCAnICtcbiAgICogICAgIGxvY2FsaXplci5mb3JtYXQoZW5kLCB7IGRhdGU6ICdzaG9ydCcgfSwgY3VsdHVyZSlcbiAgICogfVxuICAgKlxuICAgKiA8Q2FsZW5kYXIgZm9ybWF0cz17Zm9ybWF0c30gLz5cbiAgICogYGBgXG4gICAqXG4gICAqIEFsbCBsb2NhbGl6ZXJzIGFjY2VwdCBhIGZ1bmN0aW9uIG9mXG4gICAqIHRoZSBmb3JtIGAoZGF0ZTogRGF0ZSwgY3VsdHVyZTogP3N0cmluZywgbG9jYWxpemVyOiBMb2NhbGl6ZXIpIC0+IHN0cmluZ2BcbiAgICovXG4gIGZvcm1hdHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgLyoqXG4gICAgICogRm9ybWF0IGZvciB0aGUgZGF5IG9mIHRoZSBtb250aCBoZWFkaW5nIGluIHRoZSBNb250aCB2aWV3LlxuICAgICAqIGUuZy4gXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgZXRjXG4gICAgICovXG4gICAgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIEEgZGF5IG9mIHRoZSB3ZWVrIGZvcm1hdCBmb3IgV2VlayBhbmQgRGF5IGhlYWRpbmdzLFxuICAgICAqIGUuZy4gXCJXZWQgMDEvMDRcIlxuICAgICAqXG4gICAgICovXG4gICAgZGF5Rm9ybWF0OiBkYXRlRm9ybWF0LFxuXG4gICAgLyoqXG4gICAgICogV2VlayBkYXkgbmFtZSBmb3JtYXQgZm9yIHRoZSBNb250aCB3ZWVrIGRheSBoZWFkaW5ncyxcbiAgICAgKiBlLmc6IFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIGV0Y1xuICAgICAqXG4gICAgICovXG4gICAgd2Vla2RheUZvcm1hdDogZGF0ZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lc3RhbXAgY2VsbCBmb3JtYXRzIGluIFdlZWsgYW5kIFRpbWUgdmlld3MsIGUuZy4gXCI0OjAwIEFNXCJcbiAgICAgKi9cbiAgICB0aW1lR3V0dGVyRm9ybWF0OiBkYXRlRm9ybWF0LFxuXG4gICAgLyoqXG4gICAgICogVG9vbGJhciBoZWFkZXIgZm9ybWF0IGZvciB0aGUgTW9udGggdmlldywgZS5nIFwiMjAxNSBBcHJpbFwiXG4gICAgICpcbiAgICAgKi9cbiAgICBtb250aEhlYWRlckZvcm1hdDogZGF0ZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIFRvb2xiYXIgaGVhZGVyIGZvcm1hdCBmb3IgdGhlIFdlZWsgdmlld3MsIGUuZy4gXCJNYXIgMjkgLSBBcHIgMDRcIlxuICAgICAqL1xuICAgIGRheVJhbmdlSGVhZGVyRm9ybWF0OiBkYXRlUmFuZ2VGb3JtYXQsXG5cbiAgICAvKipcbiAgICAgKiBUb29sYmFyIGhlYWRlciBmb3JtYXQgZm9yIHRoZSBEYXkgdmlldywgZS5nLiBcIldlZG5lc2RheSBBcHIgMDFcIlxuICAgICAqL1xuICAgIGRheUhlYWRlckZvcm1hdDogZGF0ZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIFRvb2xiYXIgaGVhZGVyIGZvcm1hdCBmb3IgdGhlIEFnZW5kYSB2aWV3LCBlLmcuIFwiNC8xLzIwMTUg4oCUIDUvMS8yMDE1XCJcbiAgICAgKi9cbiAgICBhZ2VuZGFIZWFkZXJGb3JtYXQ6IGRhdGVSYW5nZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIEEgdGltZSByYW5nZSBmb3JtYXQgZm9yIHNlbGVjdGluZyB0aW1lIHNsb3RzLCBlLmcgXCI4OjAwYW0g4oCUIDI6MDBwbVwiXG4gICAgICovXG4gICAgc2VsZWN0UmFuZ2VGb3JtYXQ6IGRhdGVSYW5nZUZvcm1hdCxcbiAgICBhZ2VuZGFEYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuICAgIGFnZW5kYVRpbWVGb3JtYXQ6IGRhdGVGb3JtYXQsXG4gICAgYWdlbmRhVGltZVJhbmdlRm9ybWF0OiBkYXRlUmFuZ2VGb3JtYXQsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lIHJhbmdlIGRpc3BsYXllZCBvbiBldmVudHMuXG4gICAgICovXG4gICAgZXZlbnRUaW1lUmFuZ2VGb3JtYXQ6IGRhdGVSYW5nZUZvcm1hdCxcblxuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIGV2ZW50IHRpbWUgcmFuZ2UgZm9yIGV2ZW50cyB0aGF0IGNvbnRpbnVlIG9udG8gYW5vdGhlciBkYXlcbiAgICAgKi9cbiAgICBldmVudFRpbWVSYW5nZVN0YXJ0Rm9ybWF0OiBkYXRlRm9ybWF0LFxuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgZXZlbnQgdGltZSByYW5nZSBmb3IgZXZlbnRzIHRoYXQgY29udGludWUgZnJvbSBhbm90aGVyIGRheVxuICAgICAqL1xuICAgIGV2ZW50VGltZVJhbmdlRW5kRm9ybWF0OiBkYXRlRm9ybWF0XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBDdXN0b21pemUgaG93IGRpZmZlcmVudCBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIgcmVuZGVyIGJ5IHByb3ZpZGluZyBjdXN0b20gQ29tcG9uZW50cy5cbiAgICogSW4gcGFydGljdWxhciB0aGUgYEV2ZW50YCBjb21wb25lbnQgY2FuIGJlIHNwZWNpZmllZCBmb3IgdGhlIGVudGlyZSBjYWxlbmRhciwgb3IgeW91IGNhblxuICAgKiBwcm92aWRlIGFuIGluZGl2aWR1YWwgY29tcG9uZW50IGZvciBlYWNoIHZpZXcgdHlwZS5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGxldCBjb21wb25lbnRzID0ge1xuICAgKiAgIGV2ZW50OiBNeUV2ZW50LCAvLyB1c2VkIGJ5IGVhY2ggdmlldyAoTW9udGgsIERheSwgV2VlaylcbiAgICogICBldmVudFdyYXBwZXI6IE15RXZlbnRXcmFwcGVyLFxuICAgKiAgIGV2ZW50Q29udGFpbmVyV3JhcHBlcjogTXlFdmVudENvbnRhaW5lcldyYXBwZXIsXG4gICAqICAgZGF5V3JhcHBlcjogTXlEYXlXcmFwcGVyLFxuICAgKiAgIGRhdGVDZWxsV3JhcHBlcjogTXlEYXRlQ2VsbFdyYXBwZXIsXG4gICAqICAgdGltZVNsb3RXcmFwcGVyOiBNeVRpbWVTbG90V3JhcHBlcixcbiAgICogICB0aW1lR3V0dGVySGVhZGVyOiBNeVRpbWVHdXR0ZXJXcmFwcGVyLFxuICAgKiAgIHRvb2xiYXI6IE15VG9vbGJhcixcbiAgICogICBhZ2VuZGE6IHtcbiAgICogICBcdCBldmVudDogTXlBZ2VuZGFFdmVudCAvLyB3aXRoIHRoZSBhZ2VuZGEgdmlldyB1c2UgYSBkaWZmZXJlbnQgY29tcG9uZW50IHRvIHJlbmRlciBldmVudHNcbiAgICogICAgIHRpbWU6IE15QWdlbmRhVGltZSxcbiAgICogICAgIGRhdGU6IE15QWdlbmRhRGF0ZSxcbiAgICogICB9LFxuICAgKiAgIGRheToge1xuICAgKiAgICAgaGVhZGVyOiBNeURheUhlYWRlcixcbiAgICogICAgIGV2ZW50OiBNeURheUV2ZW50LFxuICAgKiAgIH0sXG4gICAqICAgd2Vlazoge1xuICAgKiAgICAgaGVhZGVyOiBNeVdlZWtIZWFkZXIsXG4gICAqICAgICBldmVudDogTXlXZWVrRXZlbnQsXG4gICAqICAgfSxcbiAgICogICBtb250aDoge1xuICAgKiAgICAgaGVhZGVyOiBNeU1vbnRoSGVhZGVyLFxuICAgKiAgICAgZGF0ZUhlYWRlcjogTXlNb250aERhdGVIZWFkZXIsXG4gICAqICAgICBldmVudDogTXlNb250aEV2ZW50LFxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8Q2FsZW5kYXIgY29tcG9uZW50cz17Y29tcG9uZW50c30gLz5cbiAgICogYGBgXG4gICAqL1xuICBjb21wb25lbnRzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGV2ZW50OiBlbGVtZW50VHlwZSxcbiAgICBldmVudFdyYXBwZXI6IGVsZW1lbnRUeXBlLFxuICAgIGV2ZW50Q29udGFpbmVyV3JhcHBlcjogZWxlbWVudFR5cGUsXG4gICAgZGF5V3JhcHBlcjogZWxlbWVudFR5cGUsXG4gICAgZGF0ZUNlbGxXcmFwcGVyOiBlbGVtZW50VHlwZSxcbiAgICB0aW1lU2xvdFdyYXBwZXI6IGVsZW1lbnRUeXBlLFxuICAgIHRpbWVHdXR0ZXJIZWFkZXI6IGVsZW1lbnRUeXBlLFxuICAgIHRvb2xiYXI6IGVsZW1lbnRUeXBlLFxuICAgIGFnZW5kYTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGRhdGU6IGVsZW1lbnRUeXBlLFxuICAgICAgdGltZTogZWxlbWVudFR5cGUsXG4gICAgICBldmVudDogZWxlbWVudFR5cGVcbiAgICB9KSxcbiAgICBkYXk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBoZWFkZXI6IGVsZW1lbnRUeXBlLFxuICAgICAgZXZlbnQ6IGVsZW1lbnRUeXBlXG4gICAgfSksXG4gICAgd2VlazogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGhlYWRlcjogZWxlbWVudFR5cGUsXG4gICAgICBldmVudDogZWxlbWVudFR5cGVcbiAgICB9KSxcbiAgICBtb250aDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGhlYWRlcjogZWxlbWVudFR5cGUsXG4gICAgICBkYXRlSGVhZGVyOiBlbGVtZW50VHlwZSxcbiAgICAgIGV2ZW50OiBlbGVtZW50VHlwZVxuICAgIH0pXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBTdHJpbmcgbWVzc2FnZXMgdXNlZCB0aHJvdWdob3V0IHRoZSBjb21wb25lbnQsIG92ZXJyaWRlIHRvIHByb3ZpZGUgbG9jYWxpemF0aW9uc1xuICAgKi9cbiAgbWVzc2FnZXM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYWxsRGF5OiBQcm9wVHlwZXMubm9kZSxcbiAgICBwcmV2aW91czogUHJvcFR5cGVzLm5vZGUsXG4gICAgbmV4dDogUHJvcFR5cGVzLm5vZGUsXG4gICAgdG9kYXk6IFByb3BUeXBlcy5ub2RlLFxuICAgIG1vbnRoOiBQcm9wVHlwZXMubm9kZSxcbiAgICB3ZWVrOiBQcm9wVHlwZXMubm9kZSxcbiAgICBkYXk6IFByb3BUeXBlcy5ub2RlLFxuICAgIGFnZW5kYTogUHJvcFR5cGVzLm5vZGUsXG4gICAgZGF0ZTogUHJvcFR5cGVzLm5vZGUsXG4gICAgdGltZTogUHJvcFR5cGVzLm5vZGUsXG4gICAgZXZlbnQ6IFByb3BUeXBlcy5ub2RlLFxuICAgIG5vRXZlbnRzSW5SYW5nZTogUHJvcFR5cGVzLm5vZGUsXG4gICAgc2hvd01vcmU6IFByb3BUeXBlcy5mdW5jXG4gIH0pXG59IDoge307XG52YXIgQ2FsZW5kYXIkMSA9IHVuY29udHJvbGxhYmxlKENhbGVuZGFyLCB7XG4gIHZpZXc6ICdvblZpZXcnLFxuICBkYXRlOiAnb25OYXZpZ2F0ZScsXG4gIHNlbGVjdGVkOiAnb25TZWxlY3RFdmVudCdcbn0pO1xuXG52YXIgZGF0ZVJhbmdlRm9ybWF0JDEgPSBmdW5jdGlvbiBkYXRlUmFuZ2VGb3JtYXQoX3JlZiwgY3VsdHVyZSwgbG9jYWwpIHtcbiAgdmFyIHN0YXJ0ID0gX3JlZi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYuZW5kO1xuICByZXR1cm4gbG9jYWwuZm9ybWF0KHN0YXJ0LCAnTCcsIGN1bHR1cmUpICsgJyDigJQgJyArIGxvY2FsLmZvcm1hdChlbmQsICdMJywgY3VsdHVyZSk7XG59O1xuXG52YXIgdGltZVJhbmdlRm9ybWF0ID0gZnVuY3Rpb24gdGltZVJhbmdlRm9ybWF0KF9yZWYyLCBjdWx0dXJlLCBsb2NhbCkge1xuICB2YXIgc3RhcnQgPSBfcmVmMi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYyLmVuZDtcbiAgcmV0dXJuIGxvY2FsLmZvcm1hdChzdGFydCwgJ0xUJywgY3VsdHVyZSkgKyAnIOKAlCAnICsgbG9jYWwuZm9ybWF0KGVuZCwgJ0xUJywgY3VsdHVyZSk7XG59O1xuXG52YXIgdGltZVJhbmdlU3RhcnRGb3JtYXQgPSBmdW5jdGlvbiB0aW1lUmFuZ2VTdGFydEZvcm1hdChfcmVmMywgY3VsdHVyZSwgbG9jYWwpIHtcbiAgdmFyIHN0YXJ0ID0gX3JlZjMuc3RhcnQ7XG4gIHJldHVybiBsb2NhbC5mb3JtYXQoc3RhcnQsICdMVCcsIGN1bHR1cmUpICsgJyDigJQgJztcbn07XG5cbnZhciB0aW1lUmFuZ2VFbmRGb3JtYXQgPSBmdW5jdGlvbiB0aW1lUmFuZ2VFbmRGb3JtYXQoX3JlZjQsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBlbmQgPSBfcmVmNC5lbmQ7XG4gIHJldHVybiAnIOKAlCAnICsgbG9jYWwuZm9ybWF0KGVuZCwgJ0xUJywgY3VsdHVyZSk7XG59O1xuXG52YXIgd2Vla1JhbmdlRm9ybWF0ID0gZnVuY3Rpb24gd2Vla1JhbmdlRm9ybWF0KF9yZWY1LCBjdWx0dXJlLCBsb2NhbCkge1xuICB2YXIgc3RhcnQgPSBfcmVmNS5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWY1LmVuZDtcbiAgcmV0dXJuIGxvY2FsLmZvcm1hdChzdGFydCwgJ01NTU0gREQnLCBjdWx0dXJlKSArICcgLSAnICsgbG9jYWwuZm9ybWF0KGVuZCwgZGF0ZXMuZXEoc3RhcnQsIGVuZCwgJ21vbnRoJykgPyAnREQnIDogJ01NTU0gREQnLCBjdWx0dXJlKTtcbn07XG5cbnZhciBmb3JtYXRzID0ge1xuICBkYXRlRm9ybWF0OiAnREQnLFxuICBkYXlGb3JtYXQ6ICdERCBkZGQnLFxuICB3ZWVrZGF5Rm9ybWF0OiAnZGRkJyxcbiAgc2VsZWN0UmFuZ2VGb3JtYXQ6IHRpbWVSYW5nZUZvcm1hdCxcbiAgZXZlbnRUaW1lUmFuZ2VGb3JtYXQ6IHRpbWVSYW5nZUZvcm1hdCxcbiAgZXZlbnRUaW1lUmFuZ2VTdGFydEZvcm1hdDogdGltZVJhbmdlU3RhcnRGb3JtYXQsXG4gIGV2ZW50VGltZVJhbmdlRW5kRm9ybWF0OiB0aW1lUmFuZ2VFbmRGb3JtYXQsXG4gIHRpbWVHdXR0ZXJGb3JtYXQ6ICdMVCcsXG4gIG1vbnRoSGVhZGVyRm9ybWF0OiAnTU1NTSBZWVlZJyxcbiAgZGF5SGVhZGVyRm9ybWF0OiAnZGRkZCBNTU0gREQnLFxuICBkYXlSYW5nZUhlYWRlckZvcm1hdDogd2Vla1JhbmdlRm9ybWF0LFxuICBhZ2VuZGFIZWFkZXJGb3JtYXQ6IGRhdGVSYW5nZUZvcm1hdCQxLFxuICBhZ2VuZGFEYXRlRm9ybWF0OiAnZGRkIE1NTSBERCcsXG4gIGFnZW5kYVRpbWVGb3JtYXQ6ICdMVCcsXG4gIGFnZW5kYVRpbWVSYW5nZUZvcm1hdDogdGltZVJhbmdlRm9ybWF0XG59O1xuZnVuY3Rpb24gbW9tZW50TG9jYWxpemVyIChtb21lbnQpIHtcbiAgdmFyIGxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZShtLCBjKSB7XG4gICAgcmV0dXJuIGMgPyBtLmxvY2FsZShjKSA6IG07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBEYXRlTG9jYWxpemVyKHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIGZpcnN0T2ZXZWVrOiBmdW5jdGlvbiBmaXJzdE9mV2VlayhjdWx0dXJlKSB7XG4gICAgICB2YXIgZGF0YSA9IGN1bHR1cmUgPyBtb21lbnQubG9jYWxlRGF0YShjdWx0dXJlKSA6IG1vbWVudC5sb2NhbGVEYXRhKCk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGEuZmlyc3REYXlPZldlZWsoKSA6IDA7XG4gICAgfSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgX2Zvcm1hdCwgY3VsdHVyZSkge1xuICAgICAgcmV0dXJuIGxvY2FsZShtb21lbnQodmFsdWUpLCBjdWx0dXJlKS5mb3JtYXQoX2Zvcm1hdCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRhdGVSYW5nZUZvcm1hdCQyID0gZnVuY3Rpb24gZGF0ZVJhbmdlRm9ybWF0KF9yZWYsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWYuc3RhcnQsXG4gICAgICBlbmQgPSBfcmVmLmVuZDtcbiAgcmV0dXJuIGxvY2FsLmZvcm1hdChzdGFydCwgJ2QnLCBjdWx0dXJlKSArICcg4oCUICcgKyBsb2NhbC5mb3JtYXQoZW5kLCAnZCcsIGN1bHR1cmUpO1xufTtcblxudmFyIHRpbWVSYW5nZUZvcm1hdCQxID0gZnVuY3Rpb24gdGltZVJhbmdlRm9ybWF0KF9yZWYyLCBjdWx0dXJlLCBsb2NhbCkge1xuICB2YXIgc3RhcnQgPSBfcmVmMi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYyLmVuZDtcbiAgcmV0dXJuIGxvY2FsLmZvcm1hdChzdGFydCwgJ3QnLCBjdWx0dXJlKSArICcg4oCUICcgKyBsb2NhbC5mb3JtYXQoZW5kLCAndCcsIGN1bHR1cmUpO1xufTtcblxudmFyIHRpbWVSYW5nZVN0YXJ0Rm9ybWF0JDEgPSBmdW5jdGlvbiB0aW1lUmFuZ2VTdGFydEZvcm1hdChfcmVmMywgY3VsdHVyZSwgbG9jYWwpIHtcbiAgdmFyIHN0YXJ0ID0gX3JlZjMuc3RhcnQ7XG4gIHJldHVybiBsb2NhbC5mb3JtYXQoc3RhcnQsICd0JywgY3VsdHVyZSkgKyAnIOKAlCAnO1xufTtcblxudmFyIHRpbWVSYW5nZUVuZEZvcm1hdCQxID0gZnVuY3Rpb24gdGltZVJhbmdlRW5kRm9ybWF0KF9yZWY0LCBjdWx0dXJlLCBsb2NhbCkge1xuICB2YXIgZW5kID0gX3JlZjQuZW5kO1xuICByZXR1cm4gJyDigJQgJyArIGxvY2FsLmZvcm1hdChlbmQsICd0JywgY3VsdHVyZSk7XG59O1xuXG52YXIgd2Vla1JhbmdlRm9ybWF0JDEgPSBmdW5jdGlvbiB3ZWVrUmFuZ2VGb3JtYXQoX3JlZjUsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWY1LnN0YXJ0LFxuICAgICAgZW5kID0gX3JlZjUuZW5kO1xuICByZXR1cm4gbG9jYWwuZm9ybWF0KHN0YXJ0LCAnTU1NIGRkJywgY3VsdHVyZSkgKyAnIC0gJyArIGxvY2FsLmZvcm1hdChlbmQsIGRhdGVzLmVxKHN0YXJ0LCBlbmQsICdtb250aCcpID8gJ2RkJyA6ICdNTU0gZGQnLCBjdWx0dXJlKTtcbn07XG5cbnZhciBmb3JtYXRzJDEgPSB7XG4gIGRhdGVGb3JtYXQ6ICdkZCcsXG4gIGRheUZvcm1hdDogJ2RkZCBkZC9NTScsXG4gIHdlZWtkYXlGb3JtYXQ6ICdkZGQnLFxuICBzZWxlY3RSYW5nZUZvcm1hdDogdGltZVJhbmdlRm9ybWF0JDEsXG4gIGV2ZW50VGltZVJhbmdlRm9ybWF0OiB0aW1lUmFuZ2VGb3JtYXQkMSxcbiAgZXZlbnRUaW1lUmFuZ2VTdGFydEZvcm1hdDogdGltZVJhbmdlU3RhcnRGb3JtYXQkMSxcbiAgZXZlbnRUaW1lUmFuZ2VFbmRGb3JtYXQ6IHRpbWVSYW5nZUVuZEZvcm1hdCQxLFxuICB0aW1lR3V0dGVyRm9ybWF0OiAndCcsXG4gIG1vbnRoSGVhZGVyRm9ybWF0OiAnWScsXG4gIGRheUhlYWRlckZvcm1hdDogJ2RkZGQgTU1NIGRkJyxcbiAgZGF5UmFuZ2VIZWFkZXJGb3JtYXQ6IHdlZWtSYW5nZUZvcm1hdCQxLFxuICBhZ2VuZGFIZWFkZXJGb3JtYXQ6IGRhdGVSYW5nZUZvcm1hdCQyLFxuICBhZ2VuZGFEYXRlRm9ybWF0OiAnZGRkIE1NTSBkZCcsXG4gIGFnZW5kYVRpbWVGb3JtYXQ6ICd0JyxcbiAgYWdlbmRhVGltZVJhbmdlRm9ybWF0OiB0aW1lUmFuZ2VGb3JtYXQkMVxufTtcbmZ1bmN0aW9uIG9sZEdsb2JhbGl6ZSAoZ2xvYmFsaXplKSB7XG4gIGZ1bmN0aW9uIGdldEN1bHR1cmUoY3VsdHVyZSkge1xuICAgIHJldHVybiBjdWx0dXJlID8gZ2xvYmFsaXplLmZpbmRDbG9zZXN0Q3VsdHVyZShjdWx0dXJlKSA6IGdsb2JhbGl6ZS5jdWx0dXJlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdE9mV2VlayhjdWx0dXJlKSB7XG4gICAgY3VsdHVyZSA9IGdldEN1bHR1cmUoY3VsdHVyZSk7XG4gICAgcmV0dXJuIGN1bHR1cmUgJiYgY3VsdHVyZS5jYWxlbmRhci5maXJzdERheSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlTG9jYWxpemVyKHtcbiAgICBmaXJzdE9mV2VlazogZmlyc3RPZldlZWssXG4gICAgZm9ybWF0czogZm9ybWF0cyQxLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCBfZm9ybWF0LCBjdWx0dXJlKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsaXplLmZvcm1hdCh2YWx1ZSwgX2Zvcm1hdCwgY3VsdHVyZSk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRhdGVSYW5nZUZvcm1hdCQzID0gZnVuY3Rpb24gZGF0ZVJhbmdlRm9ybWF0KF9yZWYsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWYuc3RhcnQsXG4gICAgICBlbmQgPSBfcmVmLmVuZDtcbiAgcmV0dXJuIGxvY2FsLmZvcm1hdChzdGFydCwge1xuICAgIGRhdGU6ICdzaG9ydCdcbiAgfSwgY3VsdHVyZSkgKyAnIOKAlCAnICsgbG9jYWwuZm9ybWF0KGVuZCwge1xuICAgIGRhdGU6ICdzaG9ydCdcbiAgfSwgY3VsdHVyZSk7XG59O1xuXG52YXIgdGltZVJhbmdlRm9ybWF0JDIgPSBmdW5jdGlvbiB0aW1lUmFuZ2VGb3JtYXQoX3JlZjIsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWYyLnN0YXJ0LFxuICAgICAgZW5kID0gX3JlZjIuZW5kO1xuICByZXR1cm4gbG9jYWwuZm9ybWF0KHN0YXJ0LCB7XG4gICAgdGltZTogJ3Nob3J0J1xuICB9LCBjdWx0dXJlKSArICcg4oCUICcgKyBsb2NhbC5mb3JtYXQoZW5kLCB7XG4gICAgdGltZTogJ3Nob3J0J1xuICB9LCBjdWx0dXJlKTtcbn07XG5cbnZhciB0aW1lUmFuZ2VTdGFydEZvcm1hdCQyID0gZnVuY3Rpb24gdGltZVJhbmdlU3RhcnRGb3JtYXQoX3JlZjMsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWYzLnN0YXJ0O1xuICByZXR1cm4gbG9jYWwuZm9ybWF0KHN0YXJ0LCB7XG4gICAgdGltZTogJ3Nob3J0J1xuICB9LCBjdWx0dXJlKSArICcg4oCUICc7XG59O1xuXG52YXIgdGltZVJhbmdlRW5kRm9ybWF0JDIgPSBmdW5jdGlvbiB0aW1lUmFuZ2VFbmRGb3JtYXQoX3JlZjQsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBlbmQgPSBfcmVmNC5lbmQ7XG4gIHJldHVybiAnIOKAlCAnICsgbG9jYWwuZm9ybWF0KGVuZCwge1xuICAgIHRpbWU6ICdzaG9ydCdcbiAgfSwgY3VsdHVyZSk7XG59O1xuXG52YXIgd2Vla1JhbmdlRm9ybWF0JDIgPSBmdW5jdGlvbiB3ZWVrUmFuZ2VGb3JtYXQoX3JlZjUsIGN1bHR1cmUsIGxvY2FsKSB7XG4gIHZhciBzdGFydCA9IF9yZWY1LnN0YXJ0LFxuICAgICAgZW5kID0gX3JlZjUuZW5kO1xuICByZXR1cm4gbG9jYWwuZm9ybWF0KHN0YXJ0LCAnTU1NIGRkJywgY3VsdHVyZSkgKyAnIOKAlCAnICsgbG9jYWwuZm9ybWF0KGVuZCwgZGF0ZXMuZXEoc3RhcnQsIGVuZCwgJ21vbnRoJykgPyAnZGQnIDogJ01NTSBkZCcsIGN1bHR1cmUpO1xufTtcblxudmFyIGZvcm1hdHMkMiA9IHtcbiAgZGF0ZUZvcm1hdDogJ2RkJyxcbiAgZGF5Rm9ybWF0OiAnZWVlIGRkL01NJyxcbiAgd2Vla2RheUZvcm1hdDogJ2VlZScsXG4gIHNlbGVjdFJhbmdlRm9ybWF0OiB0aW1lUmFuZ2VGb3JtYXQkMixcbiAgZXZlbnRUaW1lUmFuZ2VGb3JtYXQ6IHRpbWVSYW5nZUZvcm1hdCQyLFxuICBldmVudFRpbWVSYW5nZVN0YXJ0Rm9ybWF0OiB0aW1lUmFuZ2VTdGFydEZvcm1hdCQyLFxuICBldmVudFRpbWVSYW5nZUVuZEZvcm1hdDogdGltZVJhbmdlRW5kRm9ybWF0JDIsXG4gIHRpbWVHdXR0ZXJGb3JtYXQ6IHtcbiAgICB0aW1lOiAnc2hvcnQnXG4gIH0sXG4gIG1vbnRoSGVhZGVyRm9ybWF0OiAnTU1NTSB5eXl5JyxcbiAgZGF5SGVhZGVyRm9ybWF0OiAnZWVlZSBNTU0gZGQnLFxuICBkYXlSYW5nZUhlYWRlckZvcm1hdDogd2Vla1JhbmdlRm9ybWF0JDIsXG4gIGFnZW5kYUhlYWRlckZvcm1hdDogZGF0ZVJhbmdlRm9ybWF0JDMsXG4gIGFnZW5kYURhdGVGb3JtYXQ6ICdlZWUgTU1NIGRkJyxcbiAgYWdlbmRhVGltZUZvcm1hdDoge1xuICAgIHRpbWU6ICdzaG9ydCdcbiAgfSxcbiAgYWdlbmRhVGltZVJhbmdlRm9ybWF0OiB0aW1lUmFuZ2VGb3JtYXQkMlxufTtcbmZ1bmN0aW9uIGdsb2JhbGl6ZUxvY2FsaXplciAoZ2xvYmFsaXplKSB7XG4gIHZhciBsb2NhbGUgPSBmdW5jdGlvbiBsb2NhbGUoY3VsdHVyZSkge1xuICAgIHJldHVybiBjdWx0dXJlID8gZ2xvYmFsaXplKGN1bHR1cmUpIDogZ2xvYmFsaXplO1xuICB9OyAvLyByZXR1cm4gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBmcm9tIHRoZSBsb2NhbGUgZGF0YS4gRGVmYXVsdHMgdG8gJ3dvcmxkJ1xuICAvLyB0ZXJyaXRvcnkgaWYgbm8gdGVycml0b3J5IGlzIGRlcml2YWJsZSBmcm9tIENMRFIuXG4gIC8vIEZhaWxpbmcgdG8gdXNlIENMRFIgc3VwcGxlbWVudGFsIChub3QgbG9hZGVkPyksIHJldmVydCB0byB0aGUgb3JpZ2luYWxcbiAgLy8gbWV0aG9kIG9mIGdldHRpbmcgZmlyc3QgZGF5IG9mIHdlZWsuXG5cblxuICBmdW5jdGlvbiBmaXJzdE9mV2VlayhjdWx0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkYXlzID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcbiAgICAgIHZhciBjbGRyID0gbG9jYWxlKGN1bHR1cmUpLmNsZHI7XG4gICAgICB2YXIgdGVycml0b3J5ID0gY2xkci5hdHRyaWJ1dGVzLnRlcnJpdG9yeTtcbiAgICAgIHZhciB3ZWVrRGF0YSA9IGNsZHIuZ2V0KCdzdXBwbGVtZW50YWwnKS53ZWVrRGF0YTtcbiAgICAgIHZhciBmaXJzdERheSA9IHdlZWtEYXRhLmZpcnN0RGF5W3RlcnJpdG9yeSB8fCAnMDAxJ107XG4gICAgICByZXR1cm4gZGF5cy5pbmRleE9mKGZpcnN0RGF5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHRydWUsIFwiRmFpbGVkIHRvIGFjY3VyYXRlbHkgZGV0ZXJtaW5lIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cXG4gICAgICAgICAgICBJcyBzdXBwbGVtZW50YWwgZGF0YSBsb2FkZWQgaW50byBDTERSP1wiKSA6IHZvaWQgMDsgLy8gbWF5YmUgY2xkciBzdXBwbGVtZW50YWwgaXMgbm90IGxvYWRlZD8gcmV2ZXJ0IHRvIG9yaWdpbmFsIG1ldGhvZFxuXG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7IC8vY2xkci1kYXRhIGRvZXNuJ3Qgc2VlbSB0byBiZSB6ZXJvIGJhc2VkXG5cbiAgICAgIHZhciBsb2NhbGVEYXkgPSBNYXRoLm1heChwYXJzZUludChsb2NhbGUoY3VsdHVyZSkuZm9ybWF0RGF0ZShkYXRlLCB7XG4gICAgICAgIHJhdzogJ2UnXG4gICAgICB9KSwgMTApIC0gMSwgMCk7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoZGF0ZS5nZXREYXkoKSAtIGxvY2FsZURheSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFnbG9iYWxpemUubG9hZCkgcmV0dXJuIG9sZEdsb2JhbGl6ZShnbG9iYWxpemUpO1xuICByZXR1cm4gbmV3IERhdGVMb2NhbGl6ZXIoe1xuICAgIGZpcnN0T2ZXZWVrOiBmaXJzdE9mV2VlayxcbiAgICBmb3JtYXRzOiBmb3JtYXRzJDIsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIF9mb3JtYXQsIGN1bHR1cmUpIHtcbiAgICAgIF9mb3JtYXQgPSB0eXBlb2YgX2Zvcm1hdCA9PT0gJ3N0cmluZycgPyB7XG4gICAgICAgIHJhdzogX2Zvcm1hdFxuICAgICAgfSA6IF9mb3JtYXQ7XG4gICAgICByZXR1cm4gbG9jYWxlKGN1bHR1cmUpLmZvcm1hdERhdGUodmFsdWUsIF9mb3JtYXQpO1xuICAgIH1cbiAgfSk7XG59XG5cbl9leHRlbmRzKENhbGVuZGFyJDEsIHtcbiAgZ2xvYmFsaXplTG9jYWxpemVyOiBnbG9iYWxpemVMb2NhbGl6ZXIsXG4gIG1vbWVudExvY2FsaXplcjogbW9tZW50TG9jYWxpemVyLFxuICBWaWV3czogdmlld3MsXG4gIE5hdmlnYXRlOiBuYXZpZ2F0ZSxcbiAgbW92ZTogbW92ZURhdGUsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBldmVudFdyYXBwZXI6IE5vb3BXcmFwcGVyLFxuICAgIGRheVdyYXBwZXI6IE5vb3BXcmFwcGVyLFxuICAgIGRhdGVDZWxsV3JhcHBlcjogTm9vcFdyYXBwZXJcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyJDE7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZXh0ZW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIikpO1xuXG52YXIgX2RhdGVBcml0aG1ldGljID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGF0ZS1hcml0aG1ldGljXCIpKTtcblxuLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBvZmYgKi9cbnZhciBNSUxMSSA9IHtcbiAgc2Vjb25kczogMTAwMCxcbiAgbWludXRlczogMTAwMCAqIDYwLFxuICBob3VyczogMTAwMCAqIDYwICogNjAsXG4gIGRheTogMTAwMCAqIDYwICogNjAgKiAyNFxufTtcbnZhciBNT05USFMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExXTtcbnZhciBkYXRlcyA9ICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe30sIF9kYXRlQXJpdGhtZXRpYy5kZWZhdWx0LCB7XG4gIG1vbnRoc0luWWVhcjogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKHllYXIpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICAgIHJldHVybiBNT05USFMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gZGF0ZXMubW9udGgoZGF0ZSwgaSk7XG4gICAgfSk7XG4gIH0sXG4gIGZpcnN0VmlzaWJsZURheTogZnVuY3Rpb24gZmlyc3RWaXNpYmxlRGF5KGRhdGUsIGxvY2FsaXplcikge1xuICAgIHZhciBmaXJzdE9mTW9udGggPSBkYXRlcy5zdGFydE9mKGRhdGUsICdtb250aCcpO1xuICAgIHJldHVybiBkYXRlcy5zdGFydE9mKGZpcnN0T2ZNb250aCwgJ3dlZWsnLCBsb2NhbGl6ZXIuc3RhcnRPZldlZWsoKSk7XG4gIH0sXG4gIGxhc3RWaXNpYmxlRGF5OiBmdW5jdGlvbiBsYXN0VmlzaWJsZURheShkYXRlLCBsb2NhbGl6ZXIpIHtcbiAgICB2YXIgZW5kT2ZNb250aCA9IGRhdGVzLmVuZE9mKGRhdGUsICdtb250aCcpO1xuICAgIHJldHVybiBkYXRlcy5lbmRPZihlbmRPZk1vbnRoLCAnd2VlaycsIGxvY2FsaXplci5zdGFydE9mV2VlaygpKTtcbiAgfSxcbiAgdmlzaWJsZURheXM6IGZ1bmN0aW9uIHZpc2libGVEYXlzKGRhdGUsIGxvY2FsaXplcikge1xuICAgIHZhciBjdXJyZW50ID0gZGF0ZXMuZmlyc3RWaXNpYmxlRGF5KGRhdGUsIGxvY2FsaXplciksXG4gICAgICAgIGxhc3QgPSBkYXRlcy5sYXN0VmlzaWJsZURheShkYXRlLCBsb2NhbGl6ZXIpLFxuICAgICAgICBkYXlzID0gW107XG5cbiAgICB3aGlsZSAoZGF0ZXMubHRlKGN1cnJlbnQsIGxhc3QsICdkYXknKSkge1xuICAgICAgZGF5cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IGRhdGVzLmFkZChjdXJyZW50LCAxLCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH0sXG4gIGNlaWw6IGZ1bmN0aW9uIGNlaWwoZGF0ZSwgdW5pdCkge1xuICAgIHZhciBmbG9vciA9IGRhdGVzLnN0YXJ0T2YoZGF0ZSwgdW5pdCk7XG4gICAgcmV0dXJuIGRhdGVzLmVxKGZsb29yLCBkYXRlKSA/IGZsb29yIDogZGF0ZXMuYWRkKGZsb29yLCAxLCB1bml0KTtcbiAgfSxcbiAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB1bml0ID0gJ2RheSc7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgZGF5cyA9IFtdO1xuXG4gICAgd2hpbGUgKGRhdGVzLmx0ZShjdXJyZW50LCBlbmQsIHVuaXQpKSB7XG4gICAgICBkYXlzLnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gZGF0ZXMuYWRkKGN1cnJlbnQsIDEsIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlzO1xuICB9LFxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoZGF0ZSwgdGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwgJiYgZGF0ZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodGltZSA9PSBudWxsKSB0aW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAoZGF0ZSA9PSBudWxsKSBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlID0gZGF0ZXMuc3RhcnRPZihkYXRlLCAnZGF5Jyk7XG4gICAgZGF0ZSA9IGRhdGVzLmhvdXJzKGRhdGUsIGRhdGVzLmhvdXJzKHRpbWUpKTtcbiAgICBkYXRlID0gZGF0ZXMubWludXRlcyhkYXRlLCBkYXRlcy5taW51dGVzKHRpbWUpKTtcbiAgICBkYXRlID0gZGF0ZXMuc2Vjb25kcyhkYXRlLCBkYXRlcy5zZWNvbmRzKHRpbWUpKTtcbiAgICByZXR1cm4gZGF0ZXMubWlsbGlzZWNvbmRzKGRhdGUsIGRhdGVzLm1pbGxpc2Vjb25kcyh0aW1lKSk7XG4gIH0sXG4gIGVxVGltZTogZnVuY3Rpb24gZXFUaW1lKGRhdGVBLCBkYXRlQikge1xuICAgIHJldHVybiBkYXRlcy5ob3VycyhkYXRlQSkgPT09IGRhdGVzLmhvdXJzKGRhdGVCKSAmJiBkYXRlcy5taW51dGVzKGRhdGVBKSA9PT0gZGF0ZXMubWludXRlcyhkYXRlQikgJiYgZGF0ZXMuc2Vjb25kcyhkYXRlQSkgPT09IGRhdGVzLnNlY29uZHMoZGF0ZUIpO1xuICB9LFxuICBpc0p1c3REYXRlOiBmdW5jdGlvbiBpc0p1c3REYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZXMuaG91cnMoZGF0ZSkgPT09IDAgJiYgZGF0ZXMubWludXRlcyhkYXRlKSA9PT0gMCAmJiBkYXRlcy5zZWNvbmRzKGRhdGUpID09PSAwICYmIGRhdGVzLm1pbGxpc2Vjb25kcyhkYXRlKSA9PT0gMDtcbiAgfSxcbiAgZHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKHN0YXJ0LCBlbmQsIHVuaXQsIGZpcnN0T2ZXZWVrKSB7XG4gICAgaWYgKHVuaXQgPT09ICdkYXknKSB1bml0ID0gJ2RhdGUnO1xuICAgIHJldHVybiBNYXRoLmFicyhkYXRlc1t1bml0XShzdGFydCwgdW5kZWZpbmVkLCBmaXJzdE9mV2VlaykgLSBkYXRlc1t1bml0XShlbmQsIHVuZGVmaW5lZCwgZmlyc3RPZldlZWspKTtcbiAgfSxcbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRlQSwgZGF0ZUIsIHVuaXQpIHtcbiAgICBpZiAoIXVuaXQgfHwgdW5pdCA9PT0gJ21pbGxpc2Vjb25kcycpIHJldHVybiBNYXRoLmFicygrZGF0ZUEgLSArZGF0ZUIpOyAvLyB0aGUgLnJvdW5kKCkgaGFuZGxlcyBhbiBlZGdlIGNhc2VcbiAgICAvLyB3aXRoIERTVCB3aGVyZSB0aGUgdG90YWwgd29uJ3QgYmUgZXhhY3RcbiAgICAvLyBzaW5jZSBvbmUgZGF5IGluIHRoZSByYW5nZSBtYXkgYmUgc2hvcnRlci9sb25nZXIgYnkgYW4gaG91clxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5hYnMoK2RhdGVzLnN0YXJ0T2YoZGF0ZUEsIHVuaXQpIC8gTUlMTElbdW5pdF0gLSArZGF0ZXMuc3RhcnRPZihkYXRlQiwgdW5pdCkgLyBNSUxMSVt1bml0XSkpO1xuICB9LFxuICB0b3RhbDogZnVuY3Rpb24gdG90YWwoZGF0ZSwgdW5pdCkge1xuICAgIHZhciBtcyA9IGRhdGUuZ2V0VGltZSgpLFxuICAgICAgICBkaXYgPSAxO1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgZGl2ICo9IDc7XG5cbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGRpdiAqPSAyNDtcblxuICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICBkaXYgKj0gNjA7XG5cbiAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICBkaXYgKj0gNjA7XG5cbiAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICBkaXYgKj0gMTAwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbXMgLyBkaXY7XG4gIH0sXG4gIHdlZWs6IGZ1bmN0aW9uIHdlZWsoZGF0ZSkge1xuICAgIHZhciBkID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgZC5zZXRIb3VycygwLCAwLCAwKTtcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyA0IC0gKGQuZ2V0RGF5KCkgfHwgNykpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKChkIC0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkgLyA4LjY0ZTcgKyAxKSAvIDcpO1xuICB9LFxuICB0b2RheTogZnVuY3Rpb24gdG9kYXkoKSB7XG4gICAgcmV0dXJuIGRhdGVzLnN0YXJ0T2YobmV3IERhdGUoKSwgJ2RheScpO1xuICB9LFxuICB5ZXN0ZXJkYXk6IGZ1bmN0aW9uIHllc3RlcmRheSgpIHtcbiAgICByZXR1cm4gZGF0ZXMuYWRkKGRhdGVzLnN0YXJ0T2YobmV3IERhdGUoKSwgJ2RheScpLCAtMSwgJ2RheScpO1xuICB9LFxuICB0b21vcnJvdzogZnVuY3Rpb24gdG9tb3Jyb3coKSB7XG4gICAgcmV0dXJuIGRhdGVzLmFkZChkYXRlcy5zdGFydE9mKG5ldyBEYXRlKCksICdkYXknKSwgMSwgJ2RheScpO1xuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IGRhdGVzO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsInZhciBzaW1wbGVJc0VxdWFsID0gZnVuY3Rpb24gc2ltcGxlSXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gaW5kZXggKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHtcbiAgICBpc0VxdWFsID0gc2ltcGxlSXNFcXVhbDtcbiAgfVxuXG4gIHZhciBsYXN0VGhpcztcbiAgdmFyIGxhc3RBcmdzID0gW107XG4gIHZhciBsYXN0UmVzdWx0O1xuICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuXG4gIHZhciBpc05ld0FyZ0VxdWFsVG9MYXN0ID0gZnVuY3Rpb24gaXNOZXdBcmdFcXVhbFRvTGFzdChuZXdBcmcsIGluZGV4KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobmV3QXJnLCBsYXN0QXJnc1tpbmRleF0sIGluZGV4KTtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdBcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBuZXdBcmdzLmxlbmd0aCA9PT0gbGFzdEFyZ3MubGVuZ3RoICYmIG5ld0FyZ3MuZXZlcnkoaXNOZXdBcmdFcXVhbFRvTGFzdCkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RSZXN1bHQgPSByZXN1bHRGbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdEFyZ3MgPSBuZXdBcmdzO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBfX0RFVl9fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoX19ERVZfXykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMSA/IGxlbiAtIDEgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAxOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDFdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkobnVsbCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuOC42XG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSk7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlO1xuXG4vLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9jb21wb25lbnRPckVsZW1lbnQgPSByZXF1aXJlKCdwcm9wLXR5cGVzLWV4dHJhL2xpYi9jb21wb25lbnRPckVsZW1lbnQnKTtcblxudmFyIF9jb21wb25lbnRPckVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50T3JFbGVtZW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2dldENvbnRhaW5lciA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0Q29udGFpbmVyJyk7XG5cbnZhciBfZ2V0Q29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbnRhaW5lcik7XG5cbnZhciBfb3duZXJEb2N1bWVudCA9IHJlcXVpcmUoJy4vdXRpbHMvb3duZXJEb2N1bWVudCcpO1xuXG52YXIgX293bmVyRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3duZXJEb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgYDxQb3J0YWwvPmAgY29tcG9uZW50IHJlbmRlcnMgaXRzIGNoaWxkcmVuIGludG8gYSBuZXcgXCJzdWJ0cmVlXCIgb3V0c2lkZSBvZiBjdXJyZW50IGNvbXBvbmVudCBoaWVyYXJjaHkuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGl0IGFzIGEgZGVjbGFyYXRpdmUgYGFwcGVuZENoaWxkKClgLCBvciBqUXVlcnkncyBgJC5mbi5hcHBlbmRUbygpYC5cbiAqIFRoZSBjaGlsZHJlbiBvZiBgPFBvcnRhbC8+YCBjb21wb25lbnQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgYGNvbnRhaW5lcmAgc3BlY2lmaWVkLlxuICovXG52YXIgUG9ydGFsID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcnRhbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9ydGFsKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9ydGFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5fbW91bnRPdmVybGF5VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5fb3ZlcmxheVRhcmdldCkge1xuICAgICAgICBfdGhpcy5fb3ZlcmxheVRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBfdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZSA9ICgwLCBfZ2V0Q29udGFpbmVyMi5kZWZhdWx0KShfdGhpcy5wcm9wcy5jb250YWluZXIsICgwLCBfb3duZXJEb2N1bWVudDIuZGVmYXVsdCkoX3RoaXMpLmJvZHkpO1xuICAgICAgICBfdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZChfdGhpcy5fb3ZlcmxheVRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuX3VubW91bnRPdmVybGF5VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLl9vdmVybGF5VGFyZ2V0KSB7XG4gICAgICAgIF90aGlzLl9wb3J0YWxDb250YWluZXJOb2RlLnJlbW92ZUNoaWxkKF90aGlzLl9vdmVybGF5VGFyZ2V0KTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgX3RoaXMuX3BvcnRhbENvbnRhaW5lck5vZGUgPSBudWxsO1xuICAgIH0sIF90aGlzLl9yZW5kZXJPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG92ZXJsYXkgPSAhX3RoaXMucHJvcHMuY2hpbGRyZW4gPyBudWxsIDogX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoX3RoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAvLyBTYXZlIHJlZmVyZW5jZSBmb3IgZnV0dXJlIGFjY2Vzcy5cbiAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgIF90aGlzLl9tb3VudE92ZXJsYXlUYXJnZXQoKTtcblxuICAgICAgICB2YXIgaW5pdGlhbFJlbmRlciA9ICFfdGhpcy5fb3ZlcmxheUluc3RhbmNlO1xuXG4gICAgICAgIF90aGlzLl9vdmVybGF5SW5zdGFuY2UgPSBfcmVhY3REb20yLmRlZmF1bHQudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoX3RoaXMsIG92ZXJsYXksIF90aGlzLl9vdmVybGF5VGFyZ2V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGluaXRpYWxSZW5kZXIgJiYgX3RoaXMucHJvcHMub25SZW5kZXJlZCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25SZW5kZXJlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVbnJlbmRlciBpZiB0aGUgY29tcG9uZW50IGlzIG51bGwgZm9yIHRyYW5zaXRpb25zIHRvIG51bGxcbiAgICAgICAgX3RoaXMuX3VucmVuZGVyT3ZlcmxheSgpO1xuICAgICAgICBfdGhpcy5fdW5tb3VudE92ZXJsYXlUYXJnZXQoKTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5fdW5yZW5kZXJPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLl9vdmVybGF5VGFyZ2V0KSB7XG4gICAgICAgIF9yZWFjdERvbTIuZGVmYXVsdC51bm1vdW50Q29tcG9uZW50QXROb2RlKF90aGlzLl9vdmVybGF5VGFyZ2V0KTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlJbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuZ2V0TW91bnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9vdmVybGF5VGFyZ2V0O1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyT3ZlcmxheSgpO1xuICB9O1xuXG4gIFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuX3JlbmRlck92ZXJsYXkoKTtcbiAgfTtcblxuICBQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLl9vdmVybGF5VGFyZ2V0ICYmIG5leHRQcm9wcy5jb250YWluZXIgIT09IHRoaXMucHJvcHMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9wb3J0YWxDb250YWluZXJOb2RlLnJlbW92ZUNoaWxkKHRoaXMuX292ZXJsYXlUYXJnZXQpO1xuICAgICAgdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZSA9ICgwLCBfZ2V0Q29udGFpbmVyMi5kZWZhdWx0KShuZXh0UHJvcHMuY29udGFpbmVyLCAoMCwgX293bmVyRG9jdW1lbnQyLmRlZmF1bHQpKHRoaXMpLmJvZHkpO1xuICAgICAgdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9vdmVybGF5VGFyZ2V0KTtcbiAgICB9XG4gIH07XG5cbiAgUG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3VucmVuZGVyT3ZlcmxheSgpO1xuICAgIHRoaXMuX3VubW91bnRPdmVybGF5VGFyZ2V0KCk7XG4gIH07XG5cbiAgUG9ydGFsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFBvcnRhbDtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblBvcnRhbC5kaXNwbGF5TmFtZSA9ICdQb3J0YWwnO1xuUG9ydGFsLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIEEgTm9kZSwgQ29tcG9uZW50IGluc3RhbmNlLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLiBUaGUgYGNvbnRhaW5lcmAgd2lsbCBoYXZlIHRoZSBQb3J0YWwgY2hpbGRyZW5cbiAgICogYXBwZW5kZWQgdG8gaXQuXG4gICAqL1xuICBjb250YWluZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfY29tcG9uZW50T3JFbGVtZW50Mi5kZWZhdWx0LCBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmNdKSxcblxuICBvblJlbmRlcmVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmNcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBQb3J0YWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2VsZW1lbnRUeXBlID0gcmVxdWlyZSgncHJvcC10eXBlcy1leHRyYS9saWIvZWxlbWVudFR5cGUnKTtcblxudmFyIF9lbGVtZW50VHlwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVtZW50VHlwZSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Qb3J0YWwgPSByZXF1aXJlKCcuL1BvcnRhbCcpO1xuXG52YXIgX1BvcnRhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3J0YWwpO1xuXG52YXIgX1Bvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG52YXIgX1Bvc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Bvc2l0aW9uKTtcblxudmFyIF9Sb290Q2xvc2VXcmFwcGVyID0gcmVxdWlyZSgnLi9Sb290Q2xvc2VXcmFwcGVyJyk7XG5cbnZhciBfUm9vdENsb3NlV3JhcHBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb290Q2xvc2VXcmFwcGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQnVpbHQgb24gdG9wIG9mIGA8UG9zaXRpb24vPmAgYW5kIGA8UG9ydGFsLz5gLCB0aGUgb3ZlcmxheSBjb21wb25lbnQgaXMgZ3JlYXQgZm9yIGN1c3RvbSB0b29sdGlwIG92ZXJsYXlzLlxuICovXG52YXIgT3ZlcmxheSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPdmVybGF5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBPdmVybGF5KHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICBfdGhpcy5oYW5kbGVIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGV4aXRlZDogdHJ1ZSB9KTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25FeGl0ZWQuYXBwbHkoX3RoaXMkcHJvcHMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnN0YXRlID0geyBleGl0ZWQ6ICFwcm9wcy5zaG93IH07XG4gICAgX3RoaXMub25IaWRkZW5MaXN0ZW5lciA9IF90aGlzLmhhbmRsZUhpZGRlbi5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPdmVybGF5LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNob3cpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBleGl0ZWQ6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAoIW5leHRQcm9wcy50cmFuc2l0aW9uKSB7XG4gICAgICAvLyBPdGhlcndpc2UgbGV0IGhhbmRsZUhpZGRlbiB0YWtlIGNhcmUgb2YgbWFya2luZyBleGl0ZWQuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXhpdGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBPdmVybGF5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbnRhaW5lciA9IF9wcm9wcy5jb250YWluZXIsXG4gICAgICAgIGNvbnRhaW5lclBhZGRpbmcgPSBfcHJvcHMuY29udGFpbmVyUGFkZGluZyxcbiAgICAgICAgdGFyZ2V0ID0gX3Byb3BzLnRhcmdldCxcbiAgICAgICAgcGxhY2VtZW50ID0gX3Byb3BzLnBsYWNlbWVudCxcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb24gPSBfcHJvcHMuc2hvdWxkVXBkYXRlUG9zaXRpb24sXG4gICAgICAgIHJvb3RDbG9zZSA9IF9wcm9wcy5yb290Q2xvc2UsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBUcmFuc2l0aW9uID0gX3Byb3BzLnRyYW5zaXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydjb250YWluZXInLCAnY29udGFpbmVyUGFkZGluZycsICd0YXJnZXQnLCAncGxhY2VtZW50JywgJ3Nob3VsZFVwZGF0ZVBvc2l0aW9uJywgJ3Jvb3RDbG9zZScsICdjaGlsZHJlbicsICd0cmFuc2l0aW9uJ10pO1xuXG4gICAgLy8gRG9uJ3QgdW4tcmVuZGVyIHRoZSBvdmVybGF5IHdoaWxlIGl0J3MgdHJhbnNpdGlvbmluZyBvdXQuXG5cblxuICAgIHZhciBtb3VudE92ZXJsYXkgPSBwcm9wcy5zaG93IHx8IFRyYW5zaXRpb24gJiYgIXRoaXMuc3RhdGUuZXhpdGVkO1xuICAgIGlmICghbW91bnRPdmVybGF5KSB7XG4gICAgICAvLyBEb24ndCBib3RoZXIgc2hvd2luZyBhbnl0aGluZyBpZiB3ZSBkb24ndCBoYXZlIHRvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW47XG5cbiAgICAvLyBQb3NpdGlvbiBpcyBiZSBpbm5lci1tb3N0IGJlY2F1c2UgaXQgYWRkcyBpbmxpbmUgc3R5bGVzIGludG8gdGhlIGNoaWxkLFxuICAgIC8vIHdoaWNoIHRoZSBvdGhlciB3cmFwcGVycyBkb24ndCBmb3J3YXJkIGNvcnJlY3RseS5cbiAgICBjaGlsZCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgX1Bvc2l0aW9uMi5kZWZhdWx0LFxuICAgICAgeyBjb250YWluZXI6IGNvbnRhaW5lciwgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZywgdGFyZ2V0OiB0YXJnZXQsIHBsYWNlbWVudDogcGxhY2VtZW50LCBzaG91bGRVcGRhdGVQb3NpdGlvbjogc2hvdWxkVXBkYXRlUG9zaXRpb24gfSxcbiAgICAgIGNoaWxkXG4gICAgKTtcblxuICAgIGlmIChUcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgb25FeGl0ID0gcHJvcHMub25FeGl0LFxuICAgICAgICAgIG9uRXhpdGluZyA9IHByb3BzLm9uRXhpdGluZyxcbiAgICAgICAgICBvbkVudGVyID0gcHJvcHMub25FbnRlcixcbiAgICAgICAgICBvbkVudGVyaW5nID0gcHJvcHMub25FbnRlcmluZyxcbiAgICAgICAgICBvbkVudGVyZWQgPSBwcm9wcy5vbkVudGVyZWQ7XG5cbiAgICAgIC8vIFRoaXMgYW5pbWF0ZXMgdGhlIGNoaWxkIG5vZGUgYnkgaW5qZWN0aW5nIHByb3BzLCBzbyBpdCBtdXN0IHByZWNlZGVcbiAgICAgIC8vIGFueXRoaW5nIHRoYXQgYWRkcyBhIHdyYXBwaW5nIGRpdi5cblxuICAgICAgY2hpbGQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgVHJhbnNpdGlvbixcbiAgICAgICAge1xuICAgICAgICAgICdpbic6IHByb3BzLnNob3csXG4gICAgICAgICAgYXBwZWFyOiB0cnVlLFxuICAgICAgICAgIG9uRXhpdDogb25FeGl0LFxuICAgICAgICAgIG9uRXhpdGluZzogb25FeGl0aW5nLFxuICAgICAgICAgIG9uRXhpdGVkOiB0aGlzLm9uSGlkZGVuTGlzdGVuZXIsXG4gICAgICAgICAgb25FbnRlcjogb25FbnRlcixcbiAgICAgICAgICBvbkVudGVyaW5nOiBvbkVudGVyaW5nLFxuICAgICAgICAgIG9uRW50ZXJlZDogb25FbnRlcmVkXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZ29lcyBhZnRlciBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBhZGRzIGEgd3JhcHBpbmcgZGl2LlxuICAgIGlmIChyb290Q2xvc2UpIHtcbiAgICAgIGNoaWxkID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9Sb290Q2xvc2VXcmFwcGVyMi5kZWZhdWx0LFxuICAgICAgICB7IG9uUm9vdENsb3NlOiBwcm9wcy5vbkhpZGUgfSxcbiAgICAgICAgY2hpbGRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgX1BvcnRhbDIuZGVmYXVsdCxcbiAgICAgIHsgY29udGFpbmVyOiBjb250YWluZXIgfSxcbiAgICAgIGNoaWxkXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gT3ZlcmxheTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbk92ZXJsYXkucHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIF9Qb3J0YWwyLmRlZmF1bHQucHJvcFR5cGVzLCBfUG9zaXRpb24yLmRlZmF1bHQucHJvcFR5cGVzLCB7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgT3ZlcmxheVxuICAgKi9cbiAgc2hvdzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIG92ZXJsYXkgc2hvdWxkIHRyaWdnZXIgYG9uSGlkZWAgd2hlbiB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgb3ZlcmxheVxuICAgKi9cbiAgcm9vdENsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgQ2FsbGJhY2sgZmlyZWQgYnkgdGhlIE92ZXJsYXkgd2hlbiBpdCB3aXNoZXMgdG8gYmUgaGlkZGVuLlxuICAgKlxuICAgKiBfX3JlcXVpcmVkX18gd2hlbiBgcm9vdENsb3NlYCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqIEB0eXBlIGZ1bmNcbiAgICovXG4gIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKHByb3BzKSB7XG4gICAgdmFyIHByb3BUeXBlID0gX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jO1xuICAgIGlmIChwcm9wcy5yb290Q2xvc2UpIHtcbiAgICAgIHByb3BUeXBlID0gcHJvcFR5cGUuaXNSZXF1aXJlZDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wVHlwZS5hcHBseSh1bmRlZmluZWQsIFtwcm9wc10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBIGByZWFjdC10cmFuc2l0aW9uLWdyb3VwQDIuMC4wYCBgPFRyYW5zaXRpb24vPmAgY29tcG9uZW50XG4gICAqIHVzZWQgdG8gYW5pbWF0ZSB0aGUgb3ZlcmxheSBhcyBpdCBjaGFuZ2VzIHZpc2liaWxpdHkuXG4gICAqL1xuICB0cmFuc2l0aW9uOiBfZWxlbWVudFR5cGUyLmRlZmF1bHQsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgT3ZlcmxheSB0cmFuc2l0aW9ucyBpblxuICAgKi9cbiAgb25FbnRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhcyB0aGUgT3ZlcmxheSBiZWdpbnMgdG8gdHJhbnNpdGlvbiBpblxuICAgKi9cbiAgb25FbnRlcmluZzogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgT3ZlcmxheSBmaW5pc2hlcyB0cmFuc2l0aW9uaW5nIGluXG4gICAqL1xuICBvbkVudGVyZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgcmlnaHQgYmVmb3JlIHRoZSBPdmVybGF5IHRyYW5zaXRpb25zIG91dFxuICAgKi9cbiAgb25FeGl0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFzIHRoZSBPdmVybGF5IGJlZ2lucyB0byB0cmFuc2l0aW9uIG91dFxuICAgKi9cbiAgb25FeGl0aW5nOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBPdmVybGF5IGZpbmlzaGVzIHRyYW5zaXRpb25pbmcgb3V0XG4gICAqL1xuICBvbkV4aXRlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxheTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfY29tcG9uZW50T3JFbGVtZW50ID0gcmVxdWlyZSgncHJvcC10eXBlcy1leHRyYS9saWIvY29tcG9uZW50T3JFbGVtZW50Jyk7XG5cbnZhciBfY29tcG9uZW50T3JFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudE9yRWxlbWVudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9nZXRDb250YWluZXIgPSByZXF1aXJlKCcuL3V0aWxzL2dldENvbnRhaW5lcicpO1xuXG52YXIgX2dldENvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb250YWluZXIpO1xuXG52YXIgX293bmVyRG9jdW1lbnQgPSByZXF1aXJlKCcuL3V0aWxzL293bmVyRG9jdW1lbnQnKTtcblxudmFyIF9vd25lckRvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX293bmVyRG9jdW1lbnQpO1xuXG52YXIgX0xlZ2FjeVBvcnRhbCA9IHJlcXVpcmUoJy4vTGVnYWN5UG9ydGFsJyk7XG5cbnZhciBfTGVnYWN5UG9ydGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xlZ2FjeVBvcnRhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaGUgYDxQb3J0YWwvPmAgY29tcG9uZW50IHJlbmRlcnMgaXRzIGNoaWxkcmVuIGludG8gYSBuZXcgXCJzdWJ0cmVlXCIgb3V0c2lkZSBvZiBjdXJyZW50IGNvbXBvbmVudCBoaWVyYXJjaHkuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGl0IGFzIGEgZGVjbGFyYXRpdmUgYGFwcGVuZENoaWxkKClgLCBvciBqUXVlcnkncyBgJC5mbi5hcHBlbmRUbygpYC5cbiAqIFRoZSBjaGlsZHJlbiBvZiBgPFBvcnRhbC8+YCBjb21wb25lbnQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgYGNvbnRhaW5lcmAgc3BlY2lmaWVkLlxuICovXG52YXIgUG9ydGFsID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcnRhbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9ydGFsKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9ydGFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF90aGlzLnByb3BzO1xuXG4gICAgICBfdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZSA9ICgwLCBfZ2V0Q29udGFpbmVyMi5kZWZhdWx0KShwcm9wcy5jb250YWluZXIsICgwLCBfb3duZXJEb2N1bWVudDIuZGVmYXVsdCkoX3RoaXMpLmJvZHkpO1xuICAgIH0sIF90aGlzLmdldE1vdW50Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fcG9ydGFsQ29udGFpbmVyTm9kZTtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldENvbnRhaW5lcigpO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUodGhpcy5wcm9wcy5vblJlbmRlcmVkKTtcbiAgfTtcblxuICBQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuY29udGFpbmVyICE9PSB0aGlzLnByb3BzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5zZXRDb250YWluZXIobmV4dFByb3BzKTtcbiAgICB9XG4gIH07XG5cbiAgUG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX3BvcnRhbENvbnRhaW5lck5vZGUgPSBudWxsO1xuICB9O1xuXG4gIFBvcnRhbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuICYmIHRoaXMuX3BvcnRhbENvbnRhaW5lck5vZGUgPyBfcmVhY3REb20yLmRlZmF1bHQuY3JlYXRlUG9ydGFsKHRoaXMucHJvcHMuY2hpbGRyZW4sIHRoaXMuX3BvcnRhbENvbnRhaW5lck5vZGUpIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUG9ydGFsO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuUG9ydGFsLmRpc3BsYXlOYW1lID0gJ1BvcnRhbCc7XG5Qb3J0YWwucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQSBOb2RlLCBDb21wb25lbnQgaW5zdGFuY2UsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuIFRoZSBgY29udGFpbmVyYCB3aWxsIGhhdmUgdGhlIFBvcnRhbCBjaGlsZHJlblxuICAgKiBhcHBlbmRlZCB0byBpdC5cbiAgICovXG4gIGNvbnRhaW5lcjogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19jb21wb25lbnRPckVsZW1lbnQyLmRlZmF1bHQsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY10pLFxuXG4gIG9uUmVuZGVyZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9yZWFjdERvbTIuZGVmYXVsdC5jcmVhdGVQb3J0YWwgPyBQb3J0YWwgOiBfTGVnYWN5UG9ydGFsMi5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfY29tcG9uZW50T3JFbGVtZW50ID0gcmVxdWlyZSgncHJvcC10eXBlcy1leHRyYS9saWIvY29tcG9uZW50T3JFbGVtZW50Jyk7XG5cbnZhciBfY29tcG9uZW50T3JFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudE9yRWxlbWVudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9jYWxjdWxhdGVQb3NpdGlvbiA9IHJlcXVpcmUoJy4vdXRpbHMvY2FsY3VsYXRlUG9zaXRpb24nKTtcblxudmFyIF9jYWxjdWxhdGVQb3NpdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYWxjdWxhdGVQb3NpdGlvbik7XG5cbnZhciBfZ2V0Q29udGFpbmVyID0gcmVxdWlyZSgnLi91dGlscy9nZXRDb250YWluZXInKTtcblxudmFyIF9nZXRDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29udGFpbmVyKTtcblxudmFyIF9vd25lckRvY3VtZW50ID0gcmVxdWlyZSgnLi91dGlscy9vd25lckRvY3VtZW50Jyk7XG5cbnZhciBfb3duZXJEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vd25lckRvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhlIFBvc2l0aW9uIGNvbXBvbmVudCBjYWxjdWxhdGVzIHRoZSBjb29yZGluYXRlcyBmb3IgaXRzIGNoaWxkLCB0byBwb3NpdGlvblxuICogaXQgcmVsYXRpdmUgdG8gYSBgdGFyZ2V0YCBjb21wb25lbnQgb3Igbm9kZS4gVXNlZnVsIGZvciBjcmVhdGluZyBjYWxsb3V0c1xuICogYW5kIHRvb2x0aXBzLCB0aGUgUG9zaXRpb24gY29tcG9uZW50IGluamVjdHMgYSBgc3R5bGVgIHByb3BzIHdpdGggYGxlZnRgIGFuZFxuICogYHRvcGAgdmFsdWVzIGZvciBwb3NpdGlvbmluZyB5b3VyIGNvbXBvbmVudC5cbiAqXG4gKiBJdCBhbHNvIGluamVjdHMgXCJhcnJvd1wiIGBsZWZ0YCwgYW5kIGB0b3BgIHZhbHVlcyBmb3Igc3R5bGluZyBjYWxsb3V0IGFycm93c1xuICogZm9yIGdpdmluZyB5b3VyIGNvbXBvbmVudHMgYSBzZW5zZSBvZiBkaXJlY3Rpb25hbGl0eS5cbiAqL1xudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3NpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3NpdGlvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgIF90aGlzLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5wcm9wcy50YXJnZXQ7XG5cbiAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHRhcmdldCgpIDogdGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldEVsZW1lbnQgJiYgX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKHRhcmdldEVsZW1lbnQpIHx8IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLm1heWJlVXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocGxhY2VtZW50Q2hhbmdlZCkge1xuICAgICAgdmFyIHRhcmdldCA9IF90aGlzLmdldFRhcmdldCgpO1xuXG4gICAgICBpZiAoIV90aGlzLnByb3BzLnNob3VsZFVwZGF0ZVBvc2l0aW9uICYmIHRhcmdldCA9PT0gX3RoaXMuX2xhc3RUYXJnZXQgJiYgIXBsYWNlbWVudENoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVQb3NpdGlvbih0YXJnZXQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHBvc2l0aW9uTGVmdDogMCxcbiAgICAgIHBvc2l0aW9uVG9wOiAwLFxuICAgICAgYXJyb3dPZmZzZXRMZWZ0OiBudWxsLFxuICAgICAgYXJyb3dPZmZzZXRUb3A6IG51bGxcbiAgICB9O1xuXG4gICAgX3RoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcbiAgICBfdGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbih0aGlzLmdldFRhcmdldCgpKTtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gIH07XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IGZhbHNlO1xuICAgICAgdGhpcy5tYXliZVVwZGF0ZVBvc2l0aW9uKHRoaXMucHJvcHMucGxhY2VtZW50ICE9PSBwcmV2UHJvcHMucGxhY2VtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydjaGlsZHJlbicsICdjbGFzc05hbWUnXSk7XG5cbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgcG9zaXRpb25MZWZ0ID0gX3N0YXRlLnBvc2l0aW9uTGVmdCxcbiAgICAgICAgcG9zaXRpb25Ub3AgPSBfc3RhdGUucG9zaXRpb25Ub3AsXG4gICAgICAgIGFycm93UG9zaXRpb24gPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3N0YXRlLCBbJ3Bvc2l0aW9uTGVmdCcsICdwb3NpdGlvblRvcCddKTtcblxuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgZm9yd2FyZGVkIHRvIHRoZSBjaGlsZC5cblxuXG4gICAgZGVsZXRlIHByb3BzLnRhcmdldDtcbiAgICBkZWxldGUgcHJvcHMuY29udGFpbmVyO1xuICAgIGRlbGV0ZSBwcm9wcy5jb250YWluZXJQYWRkaW5nO1xuICAgIGRlbGV0ZSBwcm9wcy5zaG91bGRVcGRhdGVQb3NpdGlvbjtcblxuICAgIHZhciBjaGlsZCA9IF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICByZXR1cm4gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIGFycm93UG9zaXRpb24sIHtcbiAgICAgIC8vIEZJWE1FOiBEb24ndCBmb3J3YXJkIGBwb3NpdGlvbkxlZnRgIGFuZCBgcG9zaXRpb25Ub3BgIHZpYSBib3RoIHByb3BzXG4gICAgICAvLyBhbmQgYHByb3BzLnN0eWxlYC5cbiAgICAgIHBvc2l0aW9uTGVmdDogcG9zaXRpb25MZWZ0LFxuICAgICAgcG9zaXRpb25Ub3A6IHBvc2l0aW9uVG9wLFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyLmRlZmF1bHQpKGNsYXNzTmFtZSwgY2hpbGQucHJvcHMuY2xhc3NOYW1lKSxcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2hpbGQucHJvcHMuc3R5bGUsIHtcbiAgICAgICAgbGVmdDogcG9zaXRpb25MZWZ0LFxuICAgICAgICB0b3A6IHBvc2l0aW9uVG9wXG4gICAgICB9KVxuICAgIH0pKTtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbih0YXJnZXQpIHtcbiAgICB0aGlzLl9sYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwb3NpdGlvbkxlZnQ6IDAsXG4gICAgICAgIHBvc2l0aW9uVG9wOiAwLFxuICAgICAgICBhcnJvd09mZnNldExlZnQ6IG51bGwsXG4gICAgICAgIGFycm93T2Zmc2V0VG9wOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVybGF5ID0gX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBjb250YWluZXIgPSAoMCwgX2dldENvbnRhaW5lcjIuZGVmYXVsdCkodGhpcy5wcm9wcy5jb250YWluZXIsICgwLCBfb3duZXJEb2N1bWVudDIuZGVmYXVsdCkodGhpcykuYm9keSk7XG5cbiAgICB0aGlzLnNldFN0YXRlKCgwLCBfY2FsY3VsYXRlUG9zaXRpb24yLmRlZmF1bHQpKHRoaXMucHJvcHMucGxhY2VtZW50LCBvdmVybGF5LCB0YXJnZXQsIGNvbnRhaW5lciwgdGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nKSk7XG4gIH07XG5cbiAgcmV0dXJuIFBvc2l0aW9uO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuUG9zaXRpb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQSBub2RlLCBlbGVtZW50LCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLiBUaGUgY2hpbGQgd2lsbCBiZVxuICAgKiBiZSBwb3NpdGlvbmVkIG5leHQgdG8gdGhlIGB0YXJnZXRgIHNwZWNpZmllZC5cbiAgICovXG4gIHRhcmdldDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19jb21wb25lbnRPckVsZW1lbnQyLmRlZmF1bHQsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBcIm9mZnNldFBhcmVudFwiIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIGNvbnRhaW5lcjogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19jb21wb25lbnRPckVsZW1lbnQyLmRlZmF1bHQsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY10pLFxuICAvKipcbiAgICogTWluaW11bSBzcGFjaW5nIGluIHBpeGVscyBiZXR3ZWVuIGNvbnRhaW5lciBib3JkZXIgYW5kIGNvbXBvbmVudCBib3JkZXJcbiAgICovXG4gIGNvbnRhaW5lclBhZGRpbmc6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAvKipcbiAgICogSG93IHRvIHBvc2l0aW9uIHRoZSBjb21wb25lbnQgcmVsYXRpdmUgdG8gdGhlIHRhcmdldFxuICAgKi9cbiAgcGxhY2VtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10pLFxuICAvKipcbiAgICogV2hldGhlciB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNoYW5nZWQgb24gZWFjaCB1cGRhdGVcbiAgICovXG4gIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2xcbn07XG5cblBvc2l0aW9uLmRpc3BsYXlOYW1lID0gJ1Bvc2l0aW9uJztcblxuUG9zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXJQYWRkaW5nOiAwLFxuICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gIHNob3VsZFVwZGF0ZVBvc2l0aW9uOiBmYWxzZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zaXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY29udGFpbnMgPSByZXF1aXJlKCdkb20taGVscGVycy9xdWVyeS9jb250YWlucycpO1xuXG52YXIgX2NvbnRhaW5zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRhaW5zKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9hZGRFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi91dGlscy9hZGRFdmVudExpc3RlbmVyJyk7XG5cbnZhciBfYWRkRXZlbnRMaXN0ZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRFdmVudExpc3RlbmVyKTtcblxudmFyIF9vd25lckRvY3VtZW50ID0gcmVxdWlyZSgnLi91dGlscy9vd25lckRvY3VtZW50Jyk7XG5cbnZhciBfb3duZXJEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vd25lckRvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZXNjYXBlS2V5Q29kZSA9IDI3O1xuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8qKlxuICogVGhlIGA8Um9vdENsb3NlV3JhcHBlci8+YCBjb21wb25lbnQgcmVnaXN0ZXJzIHlvdXIgY2FsbGJhY2sgb24gdGhlIGRvY3VtZW50XG4gKiB3aGVuIHJlbmRlcmVkLiBQb3dlcnMgdGhlIGA8T3ZlcmxheS8+YCBjb21wb25lbnQuIFRoaXMgaXMgdXNlZCBhY2hpZXZlIG1vZGFsXG4gKiBzdHlsZSBiZWhhdmlvciB3aGVyZSB5b3VyIGNhbGxiYWNrIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvXG4gKiBpbnRlcmFjdCB3aXRoIHRoZSByZXN0IG9mIHRoZSBkb2N1bWVudCBvciBoaXRzIHRoZSBgZXNjYCBrZXkuXG4gKi9cblxudmFyIFJvb3RDbG9zZVdyYXBwZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm9vdENsb3NlV3JhcHBlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm9vdENsb3NlV3JhcHBlcihwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb290Q2xvc2VXcmFwcGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnQgPSBfdGhpcy5wcm9wcy5ldmVudDtcblxuICAgICAgdmFyIGRvYyA9ICgwLCBfb3duZXJEb2N1bWVudDIuZGVmYXVsdCkoX3RoaXMpO1xuXG4gICAgICAvLyBVc2UgY2FwdHVyZSBmb3IgdGhpcyBsaXN0ZW5lciBzbyBpdCBmaXJlcyBiZWZvcmUgUmVhY3QncyBsaXN0ZW5lciwgdG9cbiAgICAgIC8vIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyBpbiB0aGUgY29udGFpbnMoKSBjaGVjayBiZWxvdyBpZiB0aGUgdGFyZ2V0IERPTVxuICAgICAgLy8gZWxlbWVudCBpcyByZW1vdmVkIGluIHRoZSBSZWFjdCBtb3VzZSBjYWxsYmFjay5cbiAgICAgIF90aGlzLmRvY3VtZW50TW91c2VDYXB0dXJlTGlzdGVuZXIgPSAoMCwgX2FkZEV2ZW50TGlzdGVuZXIyLmRlZmF1bHQpKGRvYywgZXZlbnQsIF90aGlzLmhhbmRsZU1vdXNlQ2FwdHVyZSwgdHJ1ZSk7XG5cbiAgICAgIF90aGlzLmRvY3VtZW50TW91c2VMaXN0ZW5lciA9ICgwLCBfYWRkRXZlbnRMaXN0ZW5lcjIuZGVmYXVsdCkoZG9jLCBldmVudCwgX3RoaXMuaGFuZGxlTW91c2UpO1xuXG4gICAgICBfdGhpcy5kb2N1bWVudEtleXVwTGlzdGVuZXIgPSAoMCwgX2FkZEV2ZW50TGlzdGVuZXIyLmRlZmF1bHQpKGRvYywgJ2tleXVwJywgX3RoaXMuaGFuZGxlS2V5VXApO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5kb2N1bWVudE1vdXNlQ2FwdHVyZUxpc3RlbmVyKSB7XG4gICAgICAgIF90aGlzLmRvY3VtZW50TW91c2VDYXB0dXJlTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5kb2N1bWVudE1vdXNlTGlzdGVuZXIpIHtcbiAgICAgICAgX3RoaXMuZG9jdW1lbnRNb3VzZUxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuZG9jdW1lbnRLZXl1cExpc3RlbmVyKSB7XG4gICAgICAgIF90aGlzLmRvY3VtZW50S2V5dXBMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTW91c2VDYXB0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLnByZXZlbnRNb3VzZVJvb3RDbG9zZSA9IGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChlKSB8fCAoMCwgX2NvbnRhaW5zMi5kZWZhdWx0KShfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoX3RoaXMpLCBlLnRhcmdldCk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU1vdXNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMucHJldmVudE1vdXNlUm9vdENsb3NlICYmIF90aGlzLnByb3BzLm9uUm9vdENsb3NlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uUm9vdENsb3NlKGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVLZXlVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSBlc2NhcGVLZXlDb2RlICYmIF90aGlzLnByb3BzLm9uUm9vdENsb3NlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uUm9vdENsb3NlKGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5wcmV2ZW50TW91c2VSb290Q2xvc2UgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSb290Q2xvc2VXcmFwcGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfTtcblxuICBSb290Q2xvc2VXcmFwcGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmRpc2FibGVkICYmIHByZXZQcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCAmJiAhcHJldlByb3BzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xuXG4gIFJvb3RDbG9zZVdyYXBwZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xuXG4gIFJvb3RDbG9zZVdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gUm9vdENsb3NlV3JhcHBlcjtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cblJvb3RDbG9zZVdyYXBwZXIuZGlzcGxheU5hbWUgPSAnUm9vdENsb3NlV3JhcHBlcic7XG5cblJvb3RDbG9zZVdyYXBwZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgY2xpY2sgb3IgbW91c2Vkb3duLiBBbHNvIHRyaWdnZXJzIHdoZW4gdXNlciBoaXRzIGBlc2NgLlxuICAgKi9cbiAgb25Sb290Q2xvc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENoaWxkcmVuIHRvIHJlbmRlci5cbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmVsZW1lbnQsXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSB0aGUgUm9vdENsb3NlV3JhcHBlciwgcHJldmVudGluZyBpdCBmcm9tIHRyaWdnZXJpbmcgYG9uUm9vdENsb3NlYC5cbiAgICovXG4gIGRpc2FibGVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIC8qKlxuICAgKiBDaG9vc2Ugd2hpY2ggZG9jdW1lbnQgbW91c2UgZXZlbnQgdG8gYmluZCB0by5cbiAgICovXG4gIGV2ZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsnY2xpY2snLCAnbW91c2Vkb3duJ10pXG59O1xuXG5Sb290Q2xvc2VXcmFwcGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZXZlbnQ6ICdjbGljaydcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvb3RDbG9zZVdyYXBwZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlLCBldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAoMCwgX29uMi5kZWZhdWx0KShub2RlLCBldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG5cbiAgcmV0dXJuIHtcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICgwLCBfb2ZmMi5kZWZhdWx0KShub2RlLCBldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIF9vbiA9IHJlcXVpcmUoJ2RvbS1oZWxwZXJzL2V2ZW50cy9vbicpO1xuXG52YXIgX29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uKTtcblxudmFyIF9vZmYgPSByZXF1aXJlKCdkb20taGVscGVycy9ldmVudHMvb2ZmJyk7XG5cbnZhciBfb2ZmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29mZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhbGN1bGF0ZVBvc2l0aW9uO1xuXG52YXIgX29mZnNldCA9IHJlcXVpcmUoJ2RvbS1oZWxwZXJzL3F1ZXJ5L29mZnNldCcpO1xuXG52YXIgX29mZnNldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQpO1xuXG52YXIgX3Bvc2l0aW9uID0gcmVxdWlyZSgnZG9tLWhlbHBlcnMvcXVlcnkvcG9zaXRpb24nKTtcblxudmFyIF9wb3NpdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NpdGlvbik7XG5cbnZhciBfc2Nyb2xsVG9wID0gcmVxdWlyZSgnZG9tLWhlbHBlcnMvcXVlcnkvc2Nyb2xsVG9wJyk7XG5cbnZhciBfc2Nyb2xsVG9wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbFRvcCk7XG5cbnZhciBfb3duZXJEb2N1bWVudCA9IHJlcXVpcmUoJy4vb3duZXJEb2N1bWVudCcpO1xuXG52YXIgX293bmVyRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3duZXJEb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lckRpbWVuc2lvbnMoY29udGFpbmVyTm9kZSkge1xuICB2YXIgd2lkdGggPSB2b2lkIDAsXG4gICAgICBoZWlnaHQgPSB2b2lkIDAsXG4gICAgICBzY3JvbGwgPSB2b2lkIDA7XG5cbiAgaWYgKGNvbnRhaW5lck5vZGUudGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICBzY3JvbGwgPSAoMCwgX3Njcm9sbFRvcDIuZGVmYXVsdCkoKDAsIF9vd25lckRvY3VtZW50Mi5kZWZhdWx0KShjb250YWluZXJOb2RlKS5kb2N1bWVudEVsZW1lbnQpIHx8ICgwLCBfc2Nyb2xsVG9wMi5kZWZhdWx0KShjb250YWluZXJOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2dldE9mZnNldCA9ICgwLCBfb2Zmc2V0Mi5kZWZhdWx0KShjb250YWluZXJOb2RlKTtcblxuICAgIHdpZHRoID0gX2dldE9mZnNldC53aWR0aDtcbiAgICBoZWlnaHQgPSBfZ2V0T2Zmc2V0LmhlaWdodDtcblxuICAgIHNjcm9sbCA9ICgwLCBfc2Nyb2xsVG9wMi5kZWZhdWx0KShjb250YWluZXJOb2RlKTtcbiAgfVxuXG4gIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHNjcm9sbDogc2Nyb2xsIH07XG59XG5cbmZ1bmN0aW9uIGdldFRvcERlbHRhKHRvcCwgb3ZlcmxheUhlaWdodCwgY29udGFpbmVyLCBwYWRkaW5nKSB7XG4gIHZhciBjb250YWluZXJEaW1lbnNpb25zID0gZ2V0Q29udGFpbmVyRGltZW5zaW9ucyhjb250YWluZXIpO1xuICB2YXIgY29udGFpbmVyU2Nyb2xsID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGw7XG4gIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJEaW1lbnNpb25zLmhlaWdodDtcblxuICB2YXIgdG9wRWRnZU9mZnNldCA9IHRvcCAtIHBhZGRpbmcgLSBjb250YWluZXJTY3JvbGw7XG4gIHZhciBib3R0b21FZGdlT2Zmc2V0ID0gdG9wICsgcGFkZGluZyAtIGNvbnRhaW5lclNjcm9sbCArIG92ZXJsYXlIZWlnaHQ7XG5cbiAgaWYgKHRvcEVkZ2VPZmZzZXQgPCAwKSB7XG4gICAgcmV0dXJuIC10b3BFZGdlT2Zmc2V0O1xuICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICByZXR1cm4gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tRWRnZU9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMZWZ0RGVsdGEobGVmdCwgb3ZlcmxheVdpZHRoLCBjb250YWluZXIsIHBhZGRpbmcpIHtcbiAgdmFyIGNvbnRhaW5lckRpbWVuc2lvbnMgPSBnZXRDb250YWluZXJEaW1lbnNpb25zKGNvbnRhaW5lcik7XG4gIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lckRpbWVuc2lvbnMud2lkdGg7XG5cbiAgdmFyIGxlZnRFZGdlT2Zmc2V0ID0gbGVmdCAtIHBhZGRpbmc7XG4gIHZhciByaWdodEVkZ2VPZmZzZXQgPSBsZWZ0ICsgcGFkZGluZyArIG92ZXJsYXlXaWR0aDtcblxuICBpZiAobGVmdEVkZ2VPZmZzZXQgPCAwKSB7XG4gICAgcmV0dXJuIC1sZWZ0RWRnZU9mZnNldDtcbiAgfSBlbHNlIGlmIChyaWdodEVkZ2VPZmZzZXQgPiBjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiBjb250YWluZXJXaWR0aCAtIHJpZ2h0RWRnZU9mZnNldDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihwbGFjZW1lbnQsIG92ZXJsYXlOb2RlLCB0YXJnZXQsIGNvbnRhaW5lciwgcGFkZGluZykge1xuICB2YXIgY2hpbGRPZmZzZXQgPSBjb250YWluZXIudGFnTmFtZSA9PT0gJ0JPRFknID8gKDAsIF9vZmZzZXQyLmRlZmF1bHQpKHRhcmdldCkgOiAoMCwgX3Bvc2l0aW9uMi5kZWZhdWx0KSh0YXJnZXQsIGNvbnRhaW5lcik7XG5cbiAgdmFyIF9nZXRPZmZzZXQyID0gKDAsIF9vZmZzZXQyLmRlZmF1bHQpKG92ZXJsYXlOb2RlKSxcbiAgICAgIG92ZXJsYXlIZWlnaHQgPSBfZ2V0T2Zmc2V0Mi5oZWlnaHQsXG4gICAgICBvdmVybGF5V2lkdGggPSBfZ2V0T2Zmc2V0Mi53aWR0aDtcblxuICB2YXIgcG9zaXRpb25MZWZ0ID0gdm9pZCAwLFxuICAgICAgcG9zaXRpb25Ub3AgPSB2b2lkIDAsXG4gICAgICBhcnJvd09mZnNldExlZnQgPSB2b2lkIDAsXG4gICAgICBhcnJvd09mZnNldFRvcCA9IHZvaWQgMDtcblxuICBpZiAocGxhY2VtZW50ID09PSAnbGVmdCcgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9zaXRpb25Ub3AgPSBjaGlsZE9mZnNldC50b3AgKyAoY2hpbGRPZmZzZXQuaGVpZ2h0IC0gb3ZlcmxheUhlaWdodCkgLyAyO1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICBwb3NpdGlvbkxlZnQgPSBjaGlsZE9mZnNldC5sZWZ0IC0gb3ZlcmxheVdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbkxlZnQgPSBjaGlsZE9mZnNldC5sZWZ0ICsgY2hpbGRPZmZzZXQud2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIHRvcERlbHRhID0gZ2V0VG9wRGVsdGEocG9zaXRpb25Ub3AsIG92ZXJsYXlIZWlnaHQsIGNvbnRhaW5lciwgcGFkZGluZyk7XG5cbiAgICBwb3NpdGlvblRvcCArPSB0b3BEZWx0YTtcbiAgICBhcnJvd09mZnNldFRvcCA9IDUwICogKDEgLSAyICogdG9wRGVsdGEgLyBvdmVybGF5SGVpZ2h0KSArICclJztcbiAgICBhcnJvd09mZnNldExlZnQgPSB2b2lkIDA7XG4gIH0gZWxzZSBpZiAocGxhY2VtZW50ID09PSAndG9wJyB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9zaXRpb25MZWZ0ID0gY2hpbGRPZmZzZXQubGVmdCArIChjaGlsZE9mZnNldC53aWR0aCAtIG92ZXJsYXlXaWR0aCkgLyAyO1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvc2l0aW9uVG9wID0gY2hpbGRPZmZzZXQudG9wIC0gb3ZlcmxheUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb25Ub3AgPSBjaGlsZE9mZnNldC50b3AgKyBjaGlsZE9mZnNldC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGxlZnREZWx0YSA9IGdldExlZnREZWx0YShwb3NpdGlvbkxlZnQsIG92ZXJsYXlXaWR0aCwgY29udGFpbmVyLCBwYWRkaW5nKTtcblxuICAgIHBvc2l0aW9uTGVmdCArPSBsZWZ0RGVsdGE7XG4gICAgYXJyb3dPZmZzZXRMZWZ0ID0gNTAgKiAoMSAtIDIgKiBsZWZ0RGVsdGEgLyBvdmVybGF5V2lkdGgpICsgJyUnO1xuICAgIGFycm93T2Zmc2V0VG9wID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsY092ZXJsYXlQb3NpdGlvbigpOiBObyBzdWNoIHBsYWNlbWVudCBvZiBcIicgKyBwbGFjZW1lbnQgKyAnXCIgZm91bmQuJyk7XG4gIH1cblxuICByZXR1cm4geyBwb3NpdGlvbkxlZnQ6IHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3A6IHBvc2l0aW9uVG9wLCBhcnJvd09mZnNldExlZnQ6IGFycm93T2Zmc2V0TGVmdCwgYXJyb3dPZmZzZXRUb3A6IGFycm93T2Zmc2V0VG9wIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb250YWluZXI7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcihjb250YWluZXIsIGRlZmF1bHRDb250YWluZXIpIHtcbiAgY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRhaW5lcigpIDogY29udGFpbmVyO1xuICByZXR1cm4gX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKGNvbnRhaW5lcikgfHwgZGVmYXVsdENvbnRhaW5lcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICByZXR1cm4gKDAsIF9vd25lckRvY3VtZW50Mi5kZWZhdWx0KShfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSk7XG59O1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX293bmVyRG9jdW1lbnQgPSByZXF1aXJlKCdkb20taGVscGVycy9vd25lckRvY3VtZW50Jyk7XG5cbnZhciBfb3duZXJEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vd25lckRvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1bmNvbnRyb2xsYWJsZTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9pbnZhcmlhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJpbnZhcmlhbnRcIikpO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gdW5jb250cm9sbGFibGUoQ29tcG9uZW50LCBjb250cm9sbGVkVmFsdWVzLCBtZXRob2RzKSB7XG4gIGlmIChtZXRob2RzID09PSB2b2lkIDApIHtcbiAgICBtZXRob2RzID0gW107XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gIHZhciBjYW5BY2NlcHRSZWYgPSBVdGlscy5jYW5BY2NlcHRSZWYoQ29tcG9uZW50KTtcbiAgdmFyIGNvbnRyb2xsZWRQcm9wcyA9IE9iamVjdC5rZXlzKGNvbnRyb2xsZWRWYWx1ZXMpO1xuICB2YXIgUFJPUFNfVE9fT01JVCA9IGNvbnRyb2xsZWRQcm9wcy5tYXAoVXRpbHMuZGVmYXVsdEtleSk7XG4gICEoY2FuQWNjZXB0UmVmIHx8ICFtZXRob2RzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX2ludmFyaWFudC5kZWZhdWx0KShmYWxzZSwgJ1t1bmNvbnRyb2xsYWJsZV0gc3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IHBhc3MgdGhyb3VnaCBtZXRob2RzICcgKyAnYmVjYXVzZSB0aGV5IGhhdmUgbm8gYXNzb2NpYXRlZCBpbnN0YW5jZXMuIENoZWNrIGNvbXBvbmVudDogJyArIGRpc3BsYXlOYW1lICsgJywgJyArICdhdHRlbXB0aW5nIHRvIHBhc3MgdGhyb3VnaCBtZXRob2RzOiAnICsgbWV0aG9kcy5qb2luKCcsICcpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIFVuY29udHJvbGxlZENvbXBvbmVudCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShVbmNvbnRyb2xsZWRDb21wb25lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVW5jb250cm9sbGVkQ29tcG9uZW50KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnRyb2xsZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB2YXIgaGFuZGxlck5hbWUgPSBjb250cm9sbGVkVmFsdWVzW3Byb3BOYW1lXTtcblxuICAgICAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICAgICAgICBfdGhpcy5fbm90aWZ5aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMpW2hhbmRsZXJOYW1lXS5hcHBseShfdGhpcyRwcm9wcywgW3ZhbHVlXS5jb25jYXQoYXJncykpO1xuXG4gICAgICAgICAgICBfdGhpcy5fbm90aWZ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuX3ZhbHVlc1twcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoIV90aGlzLnVubW91bnRlZCkgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVyc1toYW5kbGVyTmFtZV0gPSBoYW5kbGVDaGFuZ2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCkgX3RoaXMuYXR0YWNoUmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICBfdGhpcy5pbm5lciA9IHJlZjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFVuY29udHJvbGxlZENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgLy9sZXQgdGhlIGZvcmNlVXBkYXRlIHRyaWdnZXIgdGhlIHVwZGF0ZVxuICAgICAgcmV0dXJuICF0aGlzLl9ub3RpZnlpbmc7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb250cm9sbGVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzMi5fdmFsdWVzW2tleV0gPSBwcm9wc1tVdGlscy5kZWZhdWx0S2V5KGtleSldO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgY29udHJvbGxlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBwcm9wIHN3aXRjaGVzIGZyb20gY29udHJvbGxlZCB0byBVbmNvbnRyb2xsZWRcbiAgICAgICAgICogcmVzZXQgaXRzIHZhbHVlIHRvIHRoZSBkZWZhdWx0VmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGlmICghVXRpbHMuaXNQcm9wKG5leHRQcm9wcywga2V5KSAmJiBVdGlscy5pc1Byb3AocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICBfdGhpczMuX3ZhbHVlc1trZXldID0gbmV4dFByb3BzW1V0aWxzLmRlZmF1bHRLZXkoa2V5KV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzMi5pbm5lclJlZixcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgW1wiaW5uZXJSZWZcIl0pO1xuXG4gICAgICBQUk9QU19UT19PTUlULmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgICAgIGNvbnRyb2xsZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gX3RoaXM0LnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgbmV3UHJvcHNbcHJvcE5hbWVdID0gcHJvcFZhbHVlICE9PSB1bmRlZmluZWQgPyBwcm9wVmFsdWUgOiBfdGhpczQuX3ZhbHVlc1twcm9wTmFtZV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHByb3BzLCBuZXdQcm9wcywgdGhpcy5oYW5kbGVycywge1xuICAgICAgICByZWY6IGlubmVyUmVmIHx8IHRoaXMuYXR0YWNoUmVmXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBVbmNvbnRyb2xsZWRDb21wb25lbnQ7XG4gIH0oX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KTtcblxuICBVbmNvbnRyb2xsZWRDb21wb25lbnQuZGlzcGxheU5hbWUgPSBcIlVuY29udHJvbGxlZChcIiArIGRpc3BsYXlOYW1lICsgXCIpXCI7XG4gIFVuY29udHJvbGxlZENvbXBvbmVudC5wcm9wVHlwZXMgPSBfZXh0ZW5kcyh7XG4gICAgaW5uZXJSZWY6IGZ1bmN0aW9uIGlubmVyUmVmKCkge31cbiAgfSwgVXRpbHMudW5jb250cm9sbGVkUHJvcFR5cGVzKGNvbnRyb2xsZWRWYWx1ZXMsIGRpc3BsYXlOYW1lKSk7XG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgVW5jb250cm9sbGVkQ29tcG9uZW50LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gJHByb3hpZWRNZXRob2QoKSB7XG4gICAgICB2YXIgX3RoaXMkaW5uZXI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkaW5uZXIgPSB0aGlzLmlubmVyKVttZXRob2RdLmFwcGx5KF90aGlzJGlubmVyLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuICB2YXIgV3JhcHBlZENvbXBvbmVudCA9IFVuY29udHJvbGxlZENvbXBvbmVudDtcblxuICBpZiAoX3JlYWN0LmRlZmF1bHQuZm9yd2FyZFJlZikge1xuICAgIFdyYXBwZWRDb21wb25lbnQgPSBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChVbmNvbnRyb2xsZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBpbm5lclJlZjogcmVmXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgV3JhcHBlZENvbXBvbmVudC5wcm9wVHlwZXMgPSBVbmNvbnRyb2xsZWRDb21wb25lbnQucHJvcFR5cGVzO1xuICB9XG5cbiAgV3JhcHBlZENvbXBvbmVudC5Db250cm9sbGVkQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAvKipcbiAgICogdXNlZnVsIHdoZW4gd3JhcHBpbmcgYSBDb21wb25lbnQgYW5kIHlvdSB3YW50IHRvIGNvbnRyb2xcbiAgICogZXZlcnl0aGluZ1xuICAgKi9cblxuICBXcmFwcGVkQ29tcG9uZW50LmRlZmVyQ29udHJvbFRvID0gZnVuY3Rpb24gKG5ld0NvbXBvbmVudCwgYWRkaXRpb25zLCBuZXh0TWV0aG9kcykge1xuICAgIGlmIChhZGRpdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgYWRkaXRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuY29udHJvbGxhYmxlKG5ld0NvbXBvbmVudCwgX2V4dGVuZHMoe30sIGNvbnRyb2xsZWRWYWx1ZXMsIGFkZGl0aW9ucyksIG5leHRNZXRob2RzKTtcbiAgfTtcblxuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5jb250cm9sbGVkUHJvcFR5cGVzID0gdW5jb250cm9sbGVkUHJvcFR5cGVzO1xuZXhwb3J0cy5pc1Byb3AgPSBpc1Byb3A7XG5leHBvcnRzLmRlZmF1bHRLZXkgPSBkZWZhdWx0S2V5O1xuZXhwb3J0cy5jYW5BY2NlcHRSZWYgPSBjYW5BY2NlcHRSZWY7XG5cbnZhciBfaW52YXJpYW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmZ1bmN0aW9uIHJlYWRPbmx5UHJvcFR5cGUoaGFuZGxlciwgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSkge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwcm9wc1toYW5kbGVyXSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiWW91IGhhdmUgcHJvdmlkZWQgYSBgXCIgKyBwcm9wTmFtZSArIFwiYCBwcm9wIHRvIGBcIiArIG5hbWUgKyBcImAgXCIgKyAoXCJ3aXRob3V0IGFuIGBcIiArIGhhbmRsZXIgKyBcImAgaGFuZGxlciBwcm9wLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBcIikgKyAoXCJJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBcIiArIGRlZmF1bHRLZXkocHJvcE5hbWUpICsgXCJgLiBcIikgKyAoXCJPdGhlcndpc2UsIHNldCBgXCIgKyBoYW5kbGVyICsgXCJgLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bmNvbnRyb2xsZWRQcm9wVHlwZXMoY29udHJvbGxlZFZhbHVlcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHByb3BUeXBlcyA9IHt9O1xuICBPYmplY3Qua2V5cyhjb250cm9sbGVkVmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgLy8gYWRkIGRlZmF1bHQgcHJvcFR5cGVzIGZvciBmb2xrcyB0aGF0IHVzZSBydW50aW1lIGNoZWNrc1xuICAgIHByb3BUeXBlc1tkZWZhdWx0S2V5KHByb3ApXSA9IG5vb3A7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGhhbmRsZXIgPSBjb250cm9sbGVkVmFsdWVzW3Byb3BdO1xuICAgICAgISh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycgJiYgaGFuZGxlci50cmltKCkubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgwLCBfaW52YXJpYW50LmRlZmF1bHQpKGZhbHNlLCAnVW5jb250cm9sbGFibGUgLSBbJXNdOiB0aGUgcHJvcCBgJXNgIG5lZWRzIGEgdmFsaWQgaGFuZGxlciBrZXkgbmFtZSBpbiBvcmRlciB0byBtYWtlIGl0IHVuY29udHJvbGxhYmxlJywgZGlzcGxheU5hbWUsIHByb3ApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHByb3BUeXBlc1twcm9wXSA9IHJlYWRPbmx5UHJvcFR5cGUoaGFuZGxlciwgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9wVHlwZXM7XG59XG5cbmZ1bmN0aW9uIGlzUHJvcChwcm9wcywgcHJvcCkge1xuICByZXR1cm4gcHJvcHNbcHJvcF0gIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEtleShrZXkpIHtcbiAgcmV0dXJuICdkZWZhdWx0JyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSk7XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXG5mdW5jdGlvbiBjYW5BY2NlcHRSZWYoY29tcG9uZW50KSB7XG4gIHJldHVybiAhIWNvbXBvbmVudCAmJiAodHlwZW9mIGNvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCBjb21wb25lbnQucHJvdG90eXBlICYmIGNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59IiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFFQTtBQUNBOzs7Ozs7QUFNQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BOzs7O0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBekJBO0FBNEJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzRUE7QUE4RUE7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUN2R0E7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBM0JBOzs7Ozs7Ozs7Ozs7QUNwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7O0FBVUE7QUFFQTtBQUVBOzs7O0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTtBQUVBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBVEE7QUFrQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBbkZBOzs7Ozs7Ozs7Ozs7QUM5Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTZCQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JEQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBckJBOzs7Ozs7Ozs7Ozs7O0FDcEVBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBdEJBO0FBQ0E7QUF3QkE7QUFFQTtBQUNBO0FBNUtBO0FBQ0E7QUE4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdCQTs7Ozs7O0FBT0E7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDL0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQy9CQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7Ozs7QUNOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQzFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQzFCQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7O0FDTEE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7OztBQ0xBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7OztBQ05BOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hEQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBOzs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUdBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFBQTtBQUNBO0FBV0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUtBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUdBOzs7Ozs7Ozs7O0FBUUE7QUFFQTs7Ozs7Ozs7Ozs7QUNiQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBRUE7Ozs7Ozs7Ozs7O0FDZkE7QUFBQTtBQUdBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFBQTtBQUdBOzs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQUE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUdBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUFBO0FBQUE7QUFBQTtBQUtBOzs7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBS0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBU0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFBQTtBQUdBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUlBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBR0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQUE7QUFHQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTs7Ozs7Ozs7Ozs7QUNyQkE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFBQTtBQUtBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFLQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUdBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4Q0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUdBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFBQTtBQUdBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7Ozs7QUNMQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQUNBO0FBNERBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9HQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hGQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FDSEE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBR0E7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQUE7QUFHQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7OztBQ0xBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQzdCQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BOzs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekRBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUE7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUVBO0FBQUE7QUFBQTtBQUlBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQUE7QUFBQTtBQUFBO0FBS0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUdBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7OztBQ0xBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7Ozs7QUNMQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFHQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7QUFRQTtBQUVBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQzFCQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQy9EQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQUE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7O0FDbkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUVBOzs7Ozs7Ozs7OztBQ3pCQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFFQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFFQTs7Ozs7Ozs7Ozs7OztBQzFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBRUE7Ozs7Ozs7Ozs7O0FDMUJBO0FBQUE7QUFBQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQ3hFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUN4REE7QUFBQTtBQUFBO0FBQUE7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7QUFFQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFBQTtBQUFBO0FBQUE7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUMvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hFQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFjQTtBQUdBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUF4QkE7OztBQTZCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBQ0E7QUFLQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTs7Ozs7Ozs7Ozs7Ozs7QUN0bkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7O0FDMUNBOzs7Ozs7QUFPQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JHQTs7Ozs7O0FBT0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQTFDQTtBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOWtCQTs7Ozs7O0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZEE7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlHQTtBQUNBO0FBZ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFKQTtBQVVBO0FBekRBO0FBQ0E7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQkE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBREE7QUFHQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkE7QUE0QkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBekJBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUEzREE7QUE2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUF4QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUZBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFSQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFHQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBdEJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBcEVBO0FBQ0E7QUFzRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBdEJBO0FBQ0E7QUE0QkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQXhvQkE7QUF3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQW5CQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFOQTtBQUNBO0FBWUE7Ozs7Ozs7Ozs7OztBQzl5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5R0E7QUFnSEE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNySUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQ0E7Ozs7OztBQU9BO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBOzs7Ozs7OztBQVNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBQ0E7QUFaQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsT0E7QUFDQTtBQUNBLGFBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBUEE7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBbkVBO0FBc0VBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlOQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBUEE7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBTkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUFBOzs7QUFHQTtBQXRCQTtBQXlCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2TUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUFBOzs7QUFHQTtBQUNBO0FBQUE7OztBQUdBO0FBaEJBO0FBbUJBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=
